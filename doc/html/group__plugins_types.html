<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libyang: Plugins: Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libyang<span id="projectnumber">&#160;2.1.148</span>
   </div>
   <div id="projectbrief">libyang is YANG data modelling language parser and toolkit written (and providing API) in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__plugins_types.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Plugins: Types</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Plugins: Types:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__plugins_types.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_binary.html">Plugins: Binary built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_bits.html">Plugins: Bits built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_boolean.html">Plugins: Boolean built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_decimal64.html">Plugins: Decimal64 built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_empty.html">Plugins: Empty built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_enumeration.html">Plugins: Enumeration built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_identityref.html">Plugins: Identityref built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_instanceid.html">Plugins: Instance-identifier built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_integer.html">Plugins: Integer built-in types callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_leafref.html">Plugins: Leafref built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_simple.html">Plugins: Simple Types Callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_string.html">Plugins: String built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugintypestoreopts.html">Plugins: Type store callback options.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_union.html">Plugins: Union built-in type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugins_types_xpath10.html">Plugins: xpath1.0 &lt;tt&gt;ietf-yang-types&lt;/tt&gt; type callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structlyplg__type" id="r_structlyplg__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyplg__type">lyplg_type</a></td></tr>
<tr class="memdesc:structlyplg__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold type-specific functions for various operations with the data values.  <a href="#structlyplg__type">More...</a><br /></td></tr>
<tr class="separator:structlyplg__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyplg__type__record" id="r_structlyplg__type__record"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyplg__type__record">lyplg_type_record</a></td></tr>
<tr class="separator:structlyplg__type__record"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga16febd72f11c8ca6de40d37ce10d681d" id="r_ga16febd72f11c8ca6de40d37ce10d681d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16febd72f11c8ca6de40d37ce10d681d">LYPLG_TYPE_API_VERSION</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga16febd72f11c8ca6de40d37ce10d681d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type API version.  <br /></td></tr>
<tr class="separator:ga16febd72f11c8ca6de40d37ce10d681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac3fd6a5213bfe87320301f35a63d34" id="r_ga6ac3fd6a5213bfe87320301f35a63d34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ac3fd6a5213bfe87320301f35a63d34">LYPLG_TYPE_VAL_INLINE_DESTROY</a>(type_val)</td></tr>
<tr class="memdesc:ga6ac3fd6a5213bfe87320301f35a63d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a prepared value.  <br /></td></tr>
<tr class="separator:ga6ac3fd6a5213bfe87320301f35a63d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084b759fef7b73323900a31d1d20a8fd" id="r_ga084b759fef7b73323900a31d1d20a8fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga084b759fef7b73323900a31d1d20a8fd">LYPLG_TYPE_VAL_INLINE_PREPARE</a>(storage,  type_val)</td></tr>
<tr class="memdesc:ga084b759fef7b73323900a31d1d20a8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare value memory for storing a specific type value, may be allocated dynamically.  <br /></td></tr>
<tr class="separator:ga084b759fef7b73323900a31d1d20a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97c807077909b9230d0a56f620ca812" id="r_gab97c807077909b9230d0a56f620ca812"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab97c807077909b9230d0a56f620ca812">LYPLG_TYPE_VAL_IS_DYN</a>(type_val)</td></tr>
<tr class="memdesc:gab97c807077909b9230d0a56f620ca812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether specific type value needs to be allocated dynamically.  <br /></td></tr>
<tr class="separator:gab97c807077909b9230d0a56f620ca812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04053542bf0f9e2b69e8f4635600cc7" id="r_gaa04053542bf0f9e2b69e8f4635600cc7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa04053542bf0f9e2b69e8f4635600cc7">LYPLG_TYPES</a></td></tr>
<tr class="memdesc:gaa04053542bf0f9e2b69e8f4635600cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to define plugin information in external plugins.  <br /></td></tr>
<tr class="separator:gaa04053542bf0f9e2b69e8f4635600cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad35cccf37d36f79416730ba072e2907d" id="r_gad35cccf37d36f79416730ba072e2907d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad35cccf37d36f79416730ba072e2907d">lyplg_type_compare_clb</a>) (const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val1, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val2)</td></tr>
<tr class="memdesc:gad35cccf37d36f79416730ba072e2907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for comparing 2 values of the same type.  <br /></td></tr>
<tr class="separator:gad35cccf37d36f79416730ba072e2907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413c9bb3a6795b7257a0efb9e0429abb" id="r_ga413c9bb3a6795b7257a0efb9e0429abb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga413c9bb3a6795b7257a0efb9e0429abb">lyplg_type_dup_clb</a>) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *original, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *dup)</td></tr>
<tr class="memdesc:ga413c9bb3a6795b7257a0efb9e0429abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to duplicate data in the data structure.  <br /></td></tr>
<tr class="separator:ga413c9bb3a6795b7257a0efb9e0429abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27eeb5b50501c21110fb4dc81c1ed8f" id="r_gaf27eeb5b50501c21110fb4dc81c1ed8f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf27eeb5b50501c21110fb4dc81c1ed8f">lyplg_type_free_clb</a>) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *value)</td></tr>
<tr class="memdesc:gaf27eeb5b50501c21110fb4dc81c1ed8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for freeing the user type values stored by <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>.  <br /></td></tr>
<tr class="separator:gaf27eeb5b50501c21110fb4dc81c1ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c300e10b9dd292970cc95854f1f338" id="r_gac0c300e10b9dd292970cc95854f1f338"><td class="memItemLeft" align="right" valign="top">typedef const void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0c300e10b9dd292970cc95854f1f338">lyplg_type_print_clb</a>) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *value, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *dynamic, size_t *value_len)</td></tr>
<tr class="memdesc:gac0c300e10b9dd292970cc95854f1f338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for getting the value of the data stored in <code>value</code>.  <br /></td></tr>
<tr class="separator:gac0c300e10b9dd292970cc95854f1f338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14fae180bc745cff33f190f55a15c38" id="r_gac14fae180bc745cff33f190f55a15c38"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac14fae180bc745cff33f190f55a15c38">lyplg_type_sort_clb</a>) (const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val1, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val2)</td></tr>
<tr class="memdesc:gac14fae180bc745cff33f190f55a15c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unused callback for sorting values.  <br /></td></tr>
<tr class="separator:gac14fae180bc745cff33f190f55a15c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga57427367fc3afcd961be2515c4796f42" id="r_ga57427367fc3afcd961be2515c4796f42"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga57427367fc3afcd961be2515c4796f42">ly_err_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga57427367fc3afcd961be2515c4796f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the error records created with <a class="el" href="#ga37846e55b009a1a21e4adf78f18d2ceb" title="Create and fill error structure.">ly_err_new()</a>.  <br /></td></tr>
<tr class="separator:ga57427367fc3afcd961be2515c4796f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37846e55b009a1a21e4adf78f18d2ceb" id="r_ga37846e55b009a1a21e4adf78f18d2ceb"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga37846e55b009a1a21e4adf78f18d2ceb">ly_err_new</a> (struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err, <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ecode, <a class="el" href="group__errors.html#ga3a14e6f4648dadfac48302ae1f5ae26e">LY_VECODE</a> vecode, char *path, char *apptag, const char *err_format,...) _FORMAT_PRINTF(6</td></tr>
<tr class="memdesc:ga37846e55b009a1a21e4adf78f18d2ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and fill error structure.  <br /></td></tr>
<tr class="separator:ga37846e55b009a1a21e4adf78f18d2ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5894e4cc96952d84d75cf11b4e2870" id="r_gacf5894e4cc96952d84d75cf11b4e2870"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf5894e4cc96952d84d75cf11b4e2870">lyplg_type_bits_bitmap_size</a> (const struct <a class="el" href="group__schematree.html#structlysc__type__bits">lysc_type_bits</a> *type)</td></tr>
<tr class="memdesc:gacf5894e4cc96952d84d75cf11b4e2870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bitmap size of a bits value bitmap.  <br /></td></tr>
<tr class="separator:gacf5894e4cc96952d84d75cf11b4e2870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780c6d8a7a228f3c05d2f806d206d3ea" id="r_ga780c6d8a7a228f3c05d2f806d206d3ea"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga780c6d8a7a228f3c05d2f806d206d3ea">lyplg_type_bits_is_bit_set</a> (const char *bitmap, size_t size, uint32_t bit_position)</td></tr>
<tr class="memdesc:ga780c6d8a7a228f3c05d2f806d206d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a particular bit of a bitmap is set.  <br /></td></tr>
<tr class="separator:ga780c6d8a7a228f3c05d2f806d206d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ba2d69957c53309aad5202749c3cd6" id="r_gac6ba2d69957c53309aad5202749c3cd6"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6ba2d69957c53309aad5202749c3cd6">lyplg_type_check_hints</a> (uint32_t hints, const char *value, size_t value_len, <a class="el" href="group__trees.html#ga1d29870a66477e9cba0c489cca9c4da7">LY_DATA_TYPE</a> type, int *base, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:gac6ba2d69957c53309aad5202749c3cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the type is suitable for the parser's hints (if any) in the specified format.  <br /></td></tr>
<tr class="separator:gac6ba2d69957c53309aad5202749c3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87347cd60efd1cd6c6b75a7b5d0f9c8e" id="r_ga87347cd60efd1cd6c6b75a7b5d0f9c8e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga87347cd60efd1cd6c6b75a7b5d0f9c8e">lyplg_type_check_status</a> (const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, uint16_t val_flags, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, const char *val_name, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga87347cd60efd1cd6c6b75a7b5d0f9c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the value of a type is allowed based on its status.  <br /></td></tr>
<tr class="separator:ga87347cd60efd1cd6c6b75a7b5d0f9c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f45fe441940b862a3285c1be671af71" id="r_ga9f45fe441940b862a3285c1be671af71"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f45fe441940b862a3285c1be671af71">lyplg_type_get_prefix</a> (const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *mod, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data)</td></tr>
<tr class="memdesc:ga9f45fe441940b862a3285c1be671af71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get format-specific prefix for a module.  <br /></td></tr>
<tr class="separator:ga9f45fe441940b862a3285c1be671af71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf017fa7c164d6e2c19383dec32d82f" id="r_ga9bf017fa7c164d6e2c19383dec32d82f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bf017fa7c164d6e2c19383dec32d82f">lyplg_type_identity_isderived</a> (const struct <a class="el" href="group__schematree.html#structlysc__ident">lysc_ident</a> *base, const struct <a class="el" href="group__schematree.html#structlysc__ident">lysc_ident</a> *derived)</td></tr>
<tr class="memdesc:ga9bf017fa7c164d6e2c19383dec32d82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if the <code>derived</code> identity is derived from (based on) the <code>base</code> identity.  <br /></td></tr>
<tr class="separator:ga9bf017fa7c164d6e2c19383dec32d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6596a253e080abcc23c0ea3709ac06" id="r_gafe6596a253e080abcc23c0ea3709ac06"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe6596a253e080abcc23c0ea3709ac06">lyplg_type_identity_module</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, const char *prefix, size_t prefix_len, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, const void *prefix_data)</td></tr>
<tr class="memdesc:gafe6596a253e080abcc23c0ea3709ac06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding module for the identity value.  <br /></td></tr>
<tr class="separator:gafe6596a253e080abcc23c0ea3709ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5a5b41422f2e1b61552b2d0a943d20" id="r_gaba5a5b41422f2e1b61552b2d0a943d20"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba5a5b41422f2e1b61552b2d0a943d20">lyplg_type_lypath_check_status</a> (const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, const struct ly_path *path, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:gaba5a5b41422f2e1b61552b2d0a943d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the lypath instance-identifier value is allowed based on the status of the nodes.  <br /></td></tr>
<tr class="separator:gaba5a5b41422f2e1b61552b2d0a943d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0d6a3d41ecd42557a9167fd769618d" id="r_gaef0d6a3d41ecd42557a9167fd769618d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef0d6a3d41ecd42557a9167fd769618d">lyplg_type_lypath_free</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct ly_path *path)</td></tr>
<tr class="memdesc:gaef0d6a3d41ecd42557a9167fd769618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free ly_path structure used by instanceid value representation.  <br /></td></tr>
<tr class="separator:gaef0d6a3d41ecd42557a9167fd769618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0957320b6625600676e7165497d6bd" id="r_gaed0957320b6625600676e7165497d6bd"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed0957320b6625600676e7165497d6bd">lyplg_type_lypath_new</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const char *value, size_t value_len, uint32_t options, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, struct lys_glob_unres *unres, struct ly_path **path, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:gaed0957320b6625600676e7165497d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create internal schema path representation for instance-identifier value representation.  <br /></td></tr>
<tr class="separator:gaed0957320b6625600676e7165497d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1547b87bc39f12e7807e8fb62520e594" id="r_ga1547b87bc39f12e7807e8fb62520e594"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1547b87bc39f12e7807e8fb62520e594">lyplg_type_make_implemented</a> (struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *mod, const char **features, struct lys_glob_unres *unres)</td></tr>
<tr class="memdesc:ga1547b87bc39f12e7807e8fb62520e594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a module (just like <a class="el" href="group__schematree.html#gaa85994eab6b0edf898d65e3181743959" title="Make the specific module implemented.">lys_set_implemented()</a>), but keep maintaining unresolved items.  <br /></td></tr>
<tr class="separator:ga1547b87bc39f12e7807e8fb62520e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae274e3a8d23a90f28796e12abb324f82" id="r_gae274e3a8d23a90f28796e12abb324f82"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae274e3a8d23a90f28796e12abb324f82">lyplg_type_parse_dec64</a> (uint8_t fraction_digits, const char *value, size_t value_len, int64_t *ret, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:gae274e3a8d23a90f28796e12abb324f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string with a decimal64 value into libyang representation: ret = value * 10^fraction-digits.  <br /></td></tr>
<tr class="separator:gae274e3a8d23a90f28796e12abb324f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07feb435691d153f344918470c7bce5d" id="r_ga07feb435691d153f344918470c7bce5d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga07feb435691d153f344918470c7bce5d">lyplg_type_parse_int</a> (const char *datatype, int base, int64_t min, int64_t max, const char *value, size_t value_len, int64_t *ret, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga07feb435691d153f344918470c7bce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer value parser and validator.  <br /></td></tr>
<tr class="separator:ga07feb435691d153f344918470c7bce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55904b6dabb1e677bc1b7533f125e533" id="r_ga55904b6dabb1e677bc1b7533f125e533"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55904b6dabb1e677bc1b7533f125e533">lyplg_type_parse_uint</a> (const char *datatype, int base, uint64_t max, const char *value, size_t value_len, uint64_t *ret, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga55904b6dabb1e677bc1b7533f125e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer value parser and validator.  <br /></td></tr>
<tr class="separator:ga55904b6dabb1e677bc1b7533f125e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad719f266a017c87ce4cade1dce7bb05e" id="r_gad719f266a017c87ce4cade1dce7bb05e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad719f266a017c87ce4cade1dce7bb05e">lyplg_type_prefix_data_dup</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, const void *orig, void **dup)</td></tr>
<tr class="memdesc:gad719f266a017c87ce4cade1dce7bb05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate prefix data.  <br /></td></tr>
<tr class="separator:gad719f266a017c87ce4cade1dce7bb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9684b4fce23acb8fddd32ec023d83ce" id="r_gaf9684b4fce23acb8fddd32ec023d83ce"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9684b4fce23acb8fddd32ec023d83ce">lyplg_type_prefix_data_free</a> (<a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data)</td></tr>
<tr class="memdesc:gaf9684b4fce23acb8fddd32ec023d83ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free internal prefix data.  <br /></td></tr>
<tr class="separator:gaf9684b4fce23acb8fddd32ec023d83ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad322db5f3c9dc1d0cbf133b7aa7b3a2f" id="r_gad322db5f3c9dc1d0cbf133b7aa7b3a2f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad322db5f3c9dc1d0cbf133b7aa7b3a2f">lyplg_type_prefix_data_new</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const void *value, size_t value_len, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, const void *prefix_data, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> *format_p, void **prefix_data_p)</td></tr>
<tr class="memdesc:gad322db5f3c9dc1d0cbf133b7aa7b3a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store used prefixes in a string into an internal libyang structure used in <a class="el" href="tree__data_8h.html#structlyd__value" title="YANG data representation.">lyd_value</a>.  <br /></td></tr>
<tr class="separator:gad322db5f3c9dc1d0cbf133b7aa7b3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518daffd7d9eca77ee6997055b022d5d" id="r_ga518daffd7d9eca77ee6997055b022d5d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga518daffd7d9eca77ee6997055b022d5d">lyplg_type_print_xpath10_value</a> (const struct <a class="el" href="tree__data_8h.html#structlyd__value__xpath10">lyd_value_xpath10</a> *xp_val, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, char **str_value, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga518daffd7d9eca77ee6997055b022d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print xpath1.0 value in the specific format.  <br /></td></tr>
<tr class="separator:ga518daffd7d9eca77ee6997055b022d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae473e5395bc779e9abf8c3c5501eeec9" id="r_gae473e5395bc779e9abf8c3c5501eeec9"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae473e5395bc779e9abf8c3c5501eeec9">lyplg_type_resolve_leafref</a> (const struct <a class="el" href="group__schematree.html#structlysc__type__leafref">lysc_type_leafref</a> *lref, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *node, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *value, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *tree, struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> **target, char **errmsg)</td></tr>
<tr class="memdesc:gae473e5395bc779e9abf8c3c5501eeec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find leafref target in data.  <br /></td></tr>
<tr class="separator:gae473e5395bc779e9abf8c3c5501eeec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6047ecfe5a8b94583ca61c10e1c7c0" id="r_ga2e6047ecfe5a8b94583ca61c10e1c7c0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e6047ecfe5a8b94583ca61c10e1c7c0">lyplg_type_validate_patterns</a> (struct <a class="el" href="group__schematree.html#structlysc__pattern">lysc_pattern</a> **patterns, const char *str, size_t str_len, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga2e6047ecfe5a8b94583ca61c10e1c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type validator for pattern-restricted string values.  <br /></td></tr>
<tr class="separator:ga2e6047ecfe5a8b94583ca61c10e1c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb155161a68bc8b8737c1654f49be63" id="r_ga9cb155161a68bc8b8737c1654f49be63"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cb155161a68bc8b8737c1654f49be63">lyplg_type_validate_range</a> (<a class="el" href="group__trees.html#ga1d29870a66477e9cba0c489cca9c4da7">LY_DATA_TYPE</a> basetype, struct <a class="el" href="group__schematree.html#structlysc__range">lysc_range</a> *range, int64_t value, const char *strval, size_t strval_len, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga9cb155161a68bc8b8737c1654f49be63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type validator for a range/length-restricted values.  <br /></td></tr>
<tr class="separator:ga9cb155161a68bc8b8737c1654f49be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349c435a36eea29b153459acbc90855e" id="r_ga349c435a36eea29b153459acbc90855e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DEF <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga349c435a36eea29b153459acbc90855e">lyplg_type_xpath10_print_token</a> (const char *token, uint16_t tok_len, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> is_nametest, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> **context_mod, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *resolve_ctx, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> resolve_format, const void *resolve_prefix_data, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> get_format, void *get_prefix_data, char **token_p, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga349c435a36eea29b153459acbc90855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print xpath1.0 token in the specific format.  <br /></td></tr>
<tr class="separator:ga349c435a36eea29b153459acbc90855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga81738abddbf65a7d7ce445724743241b" id="r_ga81738abddbf65a7d7ce445724743241b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga81738abddbf65a7d7ce445724743241b">lyplg_type_store_clb</a> )(const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *type, const void *value, size_t value_len, uint32_t options, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, uint32_t hints, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *storage, struct lys_glob_unres *unres, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga81738abddbf65a7d7ce445724743241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to store the given <code>value</code> according to the given <code>type</code>.  <br /></td></tr>
<tr class="separator:ga81738abddbf65a7d7ce445724743241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e84f119ae5d6588309a4cf39ea9e986" id="r_ga3e84f119ae5d6588309a4cf39ea9e986"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e84f119ae5d6588309a4cf39ea9e986">lyplg_type_validate_clb</a> )(const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *type, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *tree, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *storage, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err)</td></tr>
<tr class="memdesc:ga3e84f119ae5d6588309a4cf39ea9e986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate the stored value in data.  <br /></td></tr>
<tr class="separator:ga3e84f119ae5d6588309a4cf39ea9e986"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Structures and functions to for libyang plugins implementing specific YANG types defined in YANG modules. For more information, see <a class="el" href="howto_plugins_types.html">Type Plugins</a>.</p>
<p>This part of libyang API is available by including <code>&lt;libyang/plugins_types.h&gt;</code> header file. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structlyplg__type" id="structlyplg__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyplg__type">&#9670;&#160;</a></span>lyplg_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyplg_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Hold type-specific functions for various operations with the data values. </p>
<p>libyang includes set of plugins for all the built-in types. They are, by default, inherited to the derived types. However, if the user type plugin for the specific type is loaded, the plugin can provide it's own functions. The built-in types plugin callbacks are public, so even the user type plugins can use them to do part of their own functionality. </p>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00609">609</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4197a42db8da4b6c95448556b213dec3" name="a4197a42db8da4b6c95448556b213dec3"></a><a class="el" href="#gad35cccf37d36f79416730ba072e2907d">lyplg_type_compare_clb</a></td>
<td class="fieldname">
compare</td>
<td class="fielddoc">
<p>comparison callback to compare 2 values of the same type </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adb0c88a9f19eb66fededefed23770d2a" name="adb0c88a9f19eb66fededefed23770d2a"></a><a class="el" href="#ga413c9bb3a6795b7257a0efb9e0429abb">lyplg_type_dup_clb</a></td>
<td class="fieldname">
duplicate</td>
<td class="fielddoc">
<p>data duplication callback </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeb325aad251f90632d2ddd93efba207d" name="aeb325aad251f90632d2ddd93efba207d"></a><a class="el" href="#gaf27eeb5b50501c21110fb4dc81c1ed8f">lyplg_type_free_clb</a></td>
<td class="fieldname">
free</td>
<td class="fielddoc">
<p>optional function to free the type-spceific way stored value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa2c5615ae6529ac8966096edc0ccfce4" name="aa2c5615ae6529ac8966096edc0ccfce4"></a>const char *</td>
<td class="fieldname">
id</td>
<td class="fielddoc">
<p>Plugin identification (mainly for distinguish incompatible versions when used by external tools) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7060e8d7afaa2bf62c1301b069e06950" name="a7060e8d7afaa2bf62c1301b069e06950"></a>int32_t</td>
<td class="fieldname">
lyb_data_len</td>
<td class="fielddoc">
<p>Length of the data in <a class="el" href="howto_data_l_y_b.html">LYB format</a>. For variable-length is set to -1. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a20bc74e3f842cc9bff5a839d8b1ecf79" name="a20bc74e3f842cc9bff5a839d8b1ecf79"></a><a class="el" href="#gac0c300e10b9dd292970cc95854f1f338">lyplg_type_print_clb</a></td>
<td class="fieldname">
print</td>
<td class="fielddoc">
<p>printer callback to get string representing the value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af95722dfffb22a9e9797ffbcc456ddb5" name="af95722dfffb22a9e9797ffbcc456ddb5"></a><a class="el" href="#gac14fae180bc745cff33f190f55a15c38">lyplg_type_sort_clb</a></td>
<td class="fieldname">
sort</td>
<td class="fielddoc">
<p>unused comparison callback for sorting values </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2d2fcb9108a777ae8f89890ee24a9b44" name="a2d2fcb9108a777ae8f89890ee24a9b44"></a><a class="el" href="#ga81738abddbf65a7d7ce445724743241b">lyplg_type_store_clb</a></td>
<td class="fieldname">
store</td>
<td class="fielddoc">
<p>store and canonize the value in the type-specific way </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6d366f5648f7520619cbbc92f87040d6" name="a6d366f5648f7520619cbbc92f87040d6"></a><a class="el" href="#ga3e84f119ae5d6588309a4cf39ea9e986">lyplg_type_validate_clb</a></td>
<td class="fieldname">
validate</td>
<td class="fielddoc">
<p>optional, validate the value in the type-specific way in data </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyplg__type__record" id="structlyplg__type__record"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyplg__type__record">&#9670;&#160;</a></span>lyplg_type_record</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyplg_type_record</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00623">623</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1ed01e90e43cfb30c0f696ed5f77e040" name="a1ed01e90e43cfb30c0f696ed5f77e040"></a>const char *</td>
<td class="fieldname">
module</td>
<td class="fielddoc">
<p>name of the module where the type is defined (top-level typedef) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aace20a3efbae33f61e7f9f35407dda29" name="aace20a3efbae33f61e7f9f35407dda29"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>name of the typedef </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afc2f69c3420df4a83ddb79652de9a8f1" name="afc2f69c3420df4a83ddb79652de9a8f1"></a>struct <a class="el" href="#structlyplg__type">lyplg_type</a></td>
<td class="fieldname">
plugin</td>
<td class="fielddoc">
<p>data to utilize plugin implementation </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adf8284fdb11004b21789464fbde8c335" name="adf8284fdb11004b21789464fbde8c335"></a>const char *</td>
<td class="fieldname">
revision</td>
<td class="fielddoc">
<p>optional module revision - if not specified, the plugin applies to any revision, which is not an optimal approach due to a possible future revisions of the module. Instead, there should be defined multiple items in the plugins list, each with the different revision, but all with the same pointer to the plugin functions. The only valid use case for the NULL revision is the case the module has no revision. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga16febd72f11c8ca6de40d37ce10d681d" name="ga16febd72f11c8ca6de40d37ce10d681d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16febd72f11c8ca6de40d37ce10d681d">&#9670;&#160;</a></span>LYPLG_TYPE_API_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYPLG_TYPE_API_VERSION&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type API version. </p>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00164">164</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="ga6ac3fd6a5213bfe87320301f35a63d34" name="ga6ac3fd6a5213bfe87320301f35a63d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac3fd6a5213bfe87320301f35a63d34">&#9670;&#160;</a></span>LYPLG_TYPE_VAL_INLINE_DESTROY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYPLG_TYPE_VAL_INLINE_DESTROY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type_val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { <span class="keywordflow">if</span> (<a class="code hl_define" href="#gab97c807077909b9230d0a56f620ca812">LYPLG_TYPE_VAL_IS_DYN</a>(type_val)) free(type_val); } <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="agroup__plugins_types_html_gab97c807077909b9230d0a56f620ca812"><div class="ttname"><a href="#gab97c807077909b9230d0a56f620ca812">LYPLG_TYPE_VAL_IS_DYN</a></div><div class="ttdeci">#define LYPLG_TYPE_VAL_IS_DYN(type_val)</div><div class="ttdoc">Check whether specific type value needs to be allocated dynamically.</div><div class="ttdef"><b>Definition</b> <a href="plugins__types_8h_source.html#l00181">plugins_types.h:181</a></div></div>
</div><!-- fragment -->
<p>Destroy a prepared value. </p>
<p>Must be called for values prepared with <a class="el" href="#ga084b759fef7b73323900a31d1d20a8fd" title="Prepare value memory for storing a specific type value, may be allocated dynamically.">LYPLG_TYPE_VAL_INLINE_PREPARE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_val</td><td>Pointer to specific type value structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00205">205</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="ga084b759fef7b73323900a31d1d20a8fd" name="ga084b759fef7b73323900a31d1d20a8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084b759fef7b73323900a31d1d20a8fd">&#9670;&#160;</a></span>LYPLG_TYPE_VAL_INLINE_PREPARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYPLG_TYPE_VAL_INLINE_PREPARE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type_val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="#gab97c807077909b9230d0a56f620ca812">LYPLG_TYPE_VAL_IS_DYN</a>(type_val) \</div>
<div class="line">     ? ((type_val) = ((storage)-&gt;dyn_mem = calloc(1, <span class="keyword">sizeof</span> *(type_val)))) \</div>
<div class="line">     : ((type_val) = memset((storage)-&gt;fixed_mem, 0, sizeof *(type_val))))</div>
</div><!-- fragment -->
<p>Prepare value memory for storing a specific type value, may be allocated dynamically. </p>
<p>Must be called for values larger than 8 bytes. To be used in <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>Pointer to the value storage to use (struct <a class="el" href="tree__data_8h.html#structlyd__value" title="YANG data representation.">lyd_value</a> *). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">type_val</td><td>Pointer to specific type value structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00193">193</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="gab97c807077909b9230d0a56f620ca812" name="gab97c807077909b9230d0a56f620ca812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97c807077909b9230d0a56f620ca812">&#9670;&#160;</a></span>LYPLG_TYPE_VAL_IS_DYN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYPLG_TYPE_VAL_IS_DYN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type_val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<span class="keyword">sizeof</span> *(type_val) &gt; LYD_VALUE_FIXED_MEM_SIZE)</div>
</div><!-- fragment -->
<p>Check whether specific type value needs to be allocated dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_val</td><td>Pointer to specific type value storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00181">181</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="gaa04053542bf0f9e2b69e8f4635600cc7" name="gaa04053542bf0f9e2b69e8f4635600cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04053542bf0f9e2b69e8f4635600cc7">&#9670;&#160;</a></span>LYPLG_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYPLG_TYPES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    uint32_t plugins_types_apiver__ = <a class="code hl_define" href="#ga16febd72f11c8ca6de40d37ce10d681d">LYPLG_TYPE_API_VERSION</a>; \</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code hl_struct" href="#structlyplg__type__record">lyplg_type_record</a> plugins_types__[]</div>
<div class="ttc" id="agroup__plugins_types_html_ga16febd72f11c8ca6de40d37ce10d681d"><div class="ttname"><a href="#ga16febd72f11c8ca6de40d37ce10d681d">LYPLG_TYPE_API_VERSION</a></div><div class="ttdeci">#define LYPLG_TYPE_API_VERSION</div><div class="ttdoc">Type API version.</div><div class="ttdef"><b>Definition</b> <a href="plugins__types_8h_source.html#l00164">plugins_types.h:164</a></div></div>
<div class="ttc" id="agroup__plugins_types_html_structlyplg__type__record"><div class="ttname"><a href="#structlyplg__type__record">lyplg_type_record</a></div><div class="ttdef"><b>Definition</b> <a href="plugins__types_8h_source.html#l00623">plugins_types.h:623</a></div></div>
</div><!-- fragment -->
<p>Macro to define plugin information in external plugins. </p>
<p>Use as follows: LYPLG_TYPES = {{&lt;filled information of <a class="el" href="#structlyplg__type__record">lyplg_type_record</a>&gt;}, ..., {0}}; </p>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00172">172</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad35cccf37d36f79416730ba072e2907d" name="gad35cccf37d36f79416730ba072e2907d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad35cccf37d36f79416730ba072e2907d">&#9670;&#160;</a></span>lyplg_type_compare_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyplg_type_compare_clb) (const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val1, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for comparing 2 values of the same type. </p>
<p>It can be assumed that the same context (dictionary) was used for storing both values and the realtype member of both the values is the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val1</td><td>First value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val2</td><td>Second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if values are considered equal. </dd>
<dd>
LY_ENOT if values differ. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00544">544</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="ga413c9bb3a6795b7257a0efb9e0429abb" name="ga413c9bb3a6795b7257a0efb9e0429abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga413c9bb3a6795b7257a0efb9e0429abb">&#9670;&#160;</a></span>lyplg_type_dup_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyplg_type_dup_clb) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *original, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *dup)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to duplicate data in the data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context of the <code>dup</code>. Note that the context of <code>original</code> and <code>dup</code> might not be the same. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>Original data structure to be duplicated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dup</td><td>Prepared data structure to be filled with the duplicated data of <code>original</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS after successful duplication. </dd>
<dd>
LY_ERR value on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00589">589</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="gaf27eeb5b50501c21110fb4dc81c1ed8f" name="gaf27eeb5b50501c21110fb4dc81c1ed8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27eeb5b50501c21110fb4dc81c1ed8f">&#9670;&#160;</a></span>lyplg_type_free_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* lyplg_type_free_clb) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for freeing the user type values stored by <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>. </p>
<p>Note that this callback is responsible also for freeing the canonized member in the <code>value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang ctx to enable correct manipulation with values that are in the dictionary. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>Value structure to free the data stored there by the plugin's <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> callback </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00599">599</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="gac0c300e10b9dd292970cc95854f1f338" name="gac0c300e10b9dd292970cc95854f1f338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0c300e10b9dd292970cc95854f1f338">&#9670;&#160;</a></span>lyplg_type_print_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void *(* lyplg_type_print_clb) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *value, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *dynamic, size_t *value_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for getting the value of the data stored in <code>value</code>. </p>
<p>Canonical value (<code>format</code> of <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a6e77cde4a1edbafa863e953403b75d02">LY_VALUE_CANON</a>) must always be a zero-terminated const string stored in the dictionary. The <a class="el" href="tree__data_8h.html#aeb325cb6a5ece5afc90b51d78e622d55">lyd_value._canonical</a> member should be used for storing (caching) it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context for storing the canonical value. May not be set for <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953ad0cfebc1101a1e297d76d3e2ccf7e0c1">LY_VALUE_LYB</a> format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format in which the data are supposed to be printed. Formats <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a40435ec94c5886a1a27256bd92b20de6">LY_VALUE_SCHEMA</a> and <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a899ca3688bb4632840bb9602bfbf298f">LY_VALUE_SCHEMA_RESOLVED</a> are not supported and should not be implemented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data for processing prefixes. In case of using one of the built-in's print callback (or <a class="el" href="group__plugins_types_simple.html#ga078b0ce90790d49d0304633e2bca6442" title="Implementation of lyplg_type_print_clb for a generic simple type.">lyplg_type_print_simple()</a>), the argument is just simply passed in. If you need to handle prefixes in the value on your own, there is <a class="el" href="#ga9f45fe441940b862a3285c1be671af71" title="Get format-specific prefix for a module.">lyplg_type_get_prefix()</a> function to help. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dynamic</td><td>Flag if the returned value is dynamically allocated. In such a case the caller is responsible for freeing it. Will not be set and should be ignored for <code>format</code> <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a6e77cde4a1edbafa863e953403b75d02">LY_VALUE_CANON</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value_len</td><td>Optional returned value length in bytes. For strings it EXCLUDES the terminating zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>value</code> in the specified <code>format</code>. According to the returned <code>dynamic</code> flag, caller can be responsible for freeing allocated memory. </dd>
<dd>
NULL in case of error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00577">577</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="gac14fae180bc745cff33f190f55a15c38" name="gac14fae180bc745cff33f190f55a15c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14fae180bc745cff33f190f55a15c38">&#9670;&#160;</a></span>lyplg_type_sort_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* lyplg_type_sort_clb) (const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val1, const struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *val2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unused callback for sorting values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val1</td><td>First value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val2</td><td>Second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if val1 &lt; val2, </dd>
<dd>
0 if val1 == val2, </dd>
<dd>
1 if val1 &gt; val2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00555">555</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga57427367fc3afcd961be2515c4796f42" name="ga57427367fc3afcd961be2515c4796f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57427367fc3afcd961be2515c4796f42">&#9670;&#160;</a></span>ly_err_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> LIBYANG_API_DECL void ly_err_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the error records created with <a class="el" href="#ga37846e55b009a1a21e4adf78f18d2ceb" title="Create and fill error structure.">ly_err_new()</a>. </p>
<p>Compatible with the free(), so usable as a generic callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Error record (<a class="el" href="group__errors.html#structly__err__item" title="Libyang full error structure.">ly_err_item</a>, the void pointer is here only for compatibility with a generic free() function) to free. With the record, also all the records (if any) connected after this one are freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37846e55b009a1a21e4adf78f18d2ceb" name="ga37846e55b009a1a21e4adf78f18d2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37846e55b009a1a21e4adf78f18d2ceb">&#9670;&#160;</a></span>ly_err_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_err_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a></td>          <td class="paramname"><span class="paramname"><em>ecode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga3a14e6f4648dadfac48302ae1f5ae26e">LY_VECODE</a></td>          <td class="paramname"><span class="paramname"><em>vecode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>apptag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>err_format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and fill error structure. </p>
<p>Helper function for various plugin functions to generate error information structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>Pointer to store a new error structure filled according to the input parameters. If the storage already contains error information, the new record is appended into the errors list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecode</td><td>Code of the error to fill. In case LY_SUCCESS value, nothing is done and LY_SUCCESS is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecode</td><td>Validity error code in case of LY_EVALID error code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the node causing the error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">apptag</td><td>Error-app-tag value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err_format</td><td>Format string (same like at printf) or string literal. If you want to print just an unknown string, use "%s" for the <code>err_format</code>, otherwise undefined behavior may occur because the unknown string may contain the % character, which is interpreted as conversion specifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>ecode</code> value if the <code>err</code> is successfully created. The structure can be freed using <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a> or passed back from callback into libyang. </dd>
<dd>
LY_EMEM If there is not enough memory for allocating error record, the <code>err</code> is not touched in that case. </dd>
<dd>
LY_SUCCESS if <code>ecode</code> is LY_SUCCESS, the <code>err</code> is not touched in this case. </dd></dl>

</div>
</div>
<a id="gacf5894e4cc96952d84d75cf11b4e2870" name="gacf5894e4cc96952d84d75cf11b4e2870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf5894e4cc96952d84d75cf11b4e2870">&#9670;&#160;</a></span>lyplg_type_bits_bitmap_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL size_t lyplg_type_bits_bitmap_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__type__bits">lysc_type_bits</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bitmap size of a bits value bitmap. </p>
<p>Bitmap size is rounded up to the smallest integer size (1, 2, 4, or 8 bytes). If more than 8 bytes are needed to hold all the bit positions, no rounding is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Bits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitmap size in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bits_8c_source.html#l00055">55</a> of file <a class="el" href="bits_8c_source.html">bits.c</a>.</p>

</div>
</div>
<a id="ga780c6d8a7a228f3c05d2f806d206d3ea" name="ga780c6d8a7a228f3c05d2f806d206d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga780c6d8a7a228f3c05d2f806d206d3ea">&#9670;&#160;</a></span>lyplg_type_bits_is_bit_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> lyplg_type_bits_is_bit_set </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bitmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>bit_position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a particular bit of a bitmap is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmap</td><td>Bitmap to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of <code>bitmap</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_position</td><td>Bit position to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the bit is set or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bits_8c_source.html#l00083">83</a> of file <a class="el" href="bits_8c_source.html">bits.c</a>.</p>

</div>
</div>
<a id="gac6ba2d69957c53309aad5202749c3cd6" name="gac6ba2d69957c53309aad5202749c3cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ba2d69957c53309aad5202749c3cd6">&#9670;&#160;</a></span>lyplg_type_check_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_check_hints </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>hints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga1d29870a66477e9cba0c489cca9c4da7">LY_DATA_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the type is suitable for the parser's hints (if any) in the specified format. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hints</td><td>Bitmap of <a class="el" href="group__lydvalhints.html">value hints</a> of all the allowed value types provided by parsers to <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Lexical representation of the value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length (number of bytes) of the given <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Expected base type of the <code>value</code> by the caller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>Pointer to store the numeric base for parsing numeric values using strtol()/strtoll() function. Returned (and required) only for numeric <code>type</code> values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Pointer to store error information in case of failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value </dd></dl>

</div>
</div>
<a id="ga87347cd60efd1cd6c6b75a7b5d0f9c8e" name="ga87347cd60efd1cd6c6b75a7b5d0f9c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87347cd60efd1cd6c6b75a7b5d0f9c8e">&#9670;&#160;</a></span>lyplg_type_check_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_check_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>val_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the value of a type is allowed based on its status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Context node (which references the value). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_flags</td><td>Flags fo the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Prefix data of the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_name</td><td>Name of the value, only for logging. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Pointer to store error information in case of failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ga9f45fe441940b862a3285c1be671af71" name="ga9f45fe441940b862a3285c1be671af71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f45fe441940b862a3285c1be671af71">&#9670;&#160;</a></span>lyplg_type_get_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const char * lyplg_type_get_prefix </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get format-specific prefix for a module. </p>
<p>Use only in implementations of <a class="el" href="#gac0c300e10b9dd292970cc95854f1f338" title="Callback for getting the value of the data stored in value.">lyplg_type_print_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Module whose prefix to get - the module somehow connected with the value to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the prefix (<a class="el" href="#gac0c300e10b9dd292970cc95854f1f338" title="Callback for getting the value of the data stored in value.">lyplg_type_print_clb</a>'s format parameter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data (<a class="el" href="#gac0c300e10b9dd292970cc95854f1f338" title="Callback for getting the value of the data stored in value.">lyplg_type_print_clb</a>'s prefix_data parameter). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Module prefix to print. </dd>
<dd>
NULL on using the current module/namespace. </dd></dl>

</div>
</div>
<a id="ga9bf017fa7c164d6e2c19383dec32d82f" name="ga9bf017fa7c164d6e2c19383dec32d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf017fa7c164d6e2c19383dec32d82f">&#9670;&#160;</a></span>lyplg_type_identity_isderived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_identity_isderived </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__ident">lysc_ident</a> *</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__ident">lysc_ident</a> *</td>          <td class="paramname"><span class="paramname"><em>derived</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide if the <code>derived</code> identity is derived from (based on) the <code>base</code> identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Expected base identity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">derived</td><td>Expected derived identity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if <code>derived</code> IS based on the <code>base</code> identity. </dd>
<dd>
LY_ENOTFOUND if <code>derived</code> IS NOT not based on the <code>base</code> identity. </dd></dl>

</div>
</div>
<a id="gafe6596a253e080abcc23c0ea3709ac06" name="gafe6596a253e080abcc23c0ea3709ac06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe6596a253e080abcc23c0ea3709ac06">&#9670;&#160;</a></span>lyplg_type_identity_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * lyplg_type_identity_module </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefix_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the corresponding module for the identity value. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Schema node where the value is instantiated to determine the module in case of unprefixed value in specific <code>format</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Prefix to resolve - identified beginning of a prefix in <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>'s value parameter. If NULL, an unprefixed identity is resolved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_len</td><td>Length of <code>prefix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the prefix (<a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>'s format parameter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data (<a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>'s prefix_data parameter). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resolved prefix module, </dd>
<dd>
NULL otherwise. </dd></dl>

</div>
</div>
<a id="gaba5a5b41422f2e1b61552b2d0a943d20" name="gaba5a5b41422f2e1b61552b2d0a943d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5a5b41422f2e1b61552b2d0a943d20">&#9670;&#160;</a></span>lyplg_type_lypath_check_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_lypath_check_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ly_path *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the lypath instance-identifier value is allowed based on the status of the nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Context node (which references the value). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the instance-identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Prefix data of the value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Pointer to store error information in case of failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="gaef0d6a3d41ecd42557a9167fd769618d" name="gaef0d6a3d41ecd42557a9167fd769618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0d6a3d41ecd42557a9167fd769618d">&#9670;&#160;</a></span>lyplg_type_lypath_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyplg_type_lypath_free </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ly_path *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free ly_path structure used by instanceid value representation. </p>
<p>The ly_path representation can be created by <a class="el" href="#gaed0957320b6625600676e7165497d6bd" title="Helper function to create internal schema path representation for instance-identifier value represent...">lyplg_type_lypath_new()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The structure (<a class="el" href="howto_structures.html#sizedarrays">sized array</a>) to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed0957320b6625600676e7165497d6bd" name="gaed0957320b6625600676e7165497d6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed0957320b6625600676e7165497d6bd">&#9670;&#160;</a></span>lyplg_type_lypath_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_lypath_new </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lys_glob_unres *</td>          <td class="paramname"><span class="paramname"><em>unres</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ly_path **</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create internal schema path representation for instance-identifier value representation. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang Context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Lexical representation of the value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length (number of bytes) of the given <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="group__plugintypestoreopts.html">Type plugin store options</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Input format of the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data for resolving any prefixes (see ly_resolve_prefix()). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>The <code>value</code> schema context node. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">unres</td><td>Global unres structure for newly implemented modules. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>Pointer to store the created structure representing the schema path from the <code>value</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Pointer to store the error information provided in case of failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERECOMPILE if the context need to be recompiled, should be returned. </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="ga1547b87bc39f12e7807e8fb62520e594" name="ga1547b87bc39f12e7807e8fb62520e594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1547b87bc39f12e7807e8fb62520e594">&#9670;&#160;</a></span>lyplg_type_make_implemented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_make_implemented </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lys_glob_unres *</td>          <td class="paramname"><span class="paramname"><em>unres</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement a module (just like <a class="el" href="group__schematree.html#gaa85994eab6b0edf898d65e3181743959" title="Make the specific module implemented.">lys_set_implemented()</a>), but keep maintaining unresolved items. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Module to implement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Array of features to enable. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">unres</td><td>Global unres to add to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERECOMPILE if the context need to be recompiled, should be returned. </dd>
<dd>
LY_ERR value. </dd></dl>

</div>
</div>
<a id="gae274e3a8d23a90f28796e12abb324f82" name="gae274e3a8d23a90f28796e12abb324f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae274e3a8d23a90f28796e12abb324f82">&#9670;&#160;</a></span>lyplg_type_parse_dec64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_parse_dec64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>fraction_digits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string with a decimal64 value into libyang representation: ret = value * 10^fraction-digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fraction_digits</td><td>Fraction-digits of the decimal64 type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value string to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of the <code>value</code> (mandatory parameter). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Parsed decimal64 value representing original value * 10^fraction-digits (optional). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error information in case of failure. The error structure can be freed by <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value according to the result of the parsing and validation. </dd></dl>

</div>
</div>
<a id="ga07feb435691d153f344918470c7bce5d" name="ga07feb435691d153f344918470c7bce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07feb435691d153f344918470c7bce5d">&#9670;&#160;</a></span>lyplg_type_parse_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_parse_int </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>datatype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer value parser and validator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Type of the integer for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Base of the integer's lexical representation. In case of built-in types, data must be represented in decimal format (base 10), but default values in schemas can be represented also as hexadecimal or octal values (base 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>Lower bound of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Upper bound of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value string to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of the <code>value</code> (mandatory parameter). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Parsed integer value (optional). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error information in case of failure. The error structure can be freed by <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value according to the result of the parsing and validation. </dd></dl>

</div>
</div>
<a id="ga55904b6dabb1e677bc1b7533f125e533" name="ga55904b6dabb1e677bc1b7533f125e533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55904b6dabb1e677bc1b7533f125e533">&#9670;&#160;</a></span>lyplg_type_parse_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_parse_uint </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>datatype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer value parser and validator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Type of the unsigned integer for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Base of the integer's lexical representation. In case of built-in types, data must be represented in decimal format (base 10), but default values in schemas can be represented also as hexadecimal or octal values (base 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Upper bound of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value string to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of the <code>value</code> (mandatory parameter). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>Parsed unsigned integer value (optional). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error information in case of failure. The error structure can be freed by <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value according to the result of the parsing and validation. </dd></dl>

</div>
</div>
<a id="gad719f266a017c87ce4cade1dce7bb05e" name="gad719f266a017c87ce4cade1dce7bb05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad719f266a017c87ce4cade1dce7bb05e">&#9670;&#160;</a></span>lyplg_type_prefix_data_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_prefix_data_dup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate prefix data. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the prefixes in the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig</td><td>Prefix data to duplicate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Duplicated prefix data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="gaf9684b4fce23acb8fddd32ec023d83ce" name="gaf9684b4fce23acb8fddd32ec023d83ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9684b4fce23acb8fddd32ec023d83ce">&#9670;&#160;</a></span>lyplg_type_prefix_data_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyplg_type_prefix_data_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free internal prefix data. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the prefixes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad322db5f3c9dc1d0cbf133b7aa7b3a2f" name="gad322db5f3c9dc1d0cbf133b7aa7b3a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad322db5f3c9dc1d0cbf133b7aa7b3a2f">&#9670;&#160;</a></span>lyplg_type_prefix_data_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_prefix_data_new </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> *</td>          <td class="paramname"><span class="paramname"><em>format_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>prefix_data_p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store used prefixes in a string into an internal libyang structure used in <a class="el" href="tree__data_8h.html#structlyd__value" title="YANG data representation.">lyd_value</a>. </p>
<p>Use only in implementations of <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> which provide all the necessary parameters for this function.</p>
<p>If <code>prefix_data_p</code> are non-NULL, they are treated as valid according to the <code>format_p</code> and new possible prefixes are simply added. This way it is possible to store prefix data for several strings together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to be parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the prefixes in the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data for resolving any prefixes (see ly_resolve_prefix()). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">format_p</td><td>Resulting format of the prefixes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prefix_data_p</td><td>Resulting prefix data for the value in format <code>format_p</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ga518daffd7d9eca77ee6997055b022d5d" name="ga518daffd7d9eca77ee6997055b022d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga518daffd7d9eca77ee6997055b022d5d">&#9670;&#160;</a></span>lyplg_type_print_xpath10_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_print_xpath10_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__value__xpath10">lyd_value_xpath10</a> *</td>          <td class="paramname"><span class="paramname"><em>xp_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>str_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print xpath1.0 value in the specific format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xp_val</td><td>xpath1.0 value structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format to print in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific prefix data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">str_value</td><td>Printed value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error structure on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpath1_80_8c_source.html#l00214">214</a> of file <a class="el" href="xpath1_80_8c_source.html">xpath1.0.c</a>.</p>

</div>
</div>
<a id="gae473e5395bc779e9abf8c3c5501eeec9" name="gae473e5395bc779e9abf8c3c5501eeec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae473e5395bc779e9abf8c3c5501eeec9">&#9670;&#160;</a></span>lyplg_type_resolve_leafref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_resolve_leafref </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__type__leafref">lysc_type_leafref</a> *</td>          <td class="paramname"><span class="paramname"><em>lref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>errmsg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find leafref target in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lref</td><td>Leafref type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Target value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Full data tree to search in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>Optional found target. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>Error message in case of error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ga2e6047ecfe5a8b94583ca61c10e1c7c0" name="ga2e6047ecfe5a8b94583ca61c10e1c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6047ecfe5a8b94583ca61c10e1c7c0">&#9670;&#160;</a></span>lyplg_type_validate_patterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_validate_patterns </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__schematree.html#structlysc__pattern">lysc_pattern</a> **</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>str_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type validator for pattern-restricted string values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patterns</td><td>(<a class="el" href="howto_structures.html#sizedarrays">Sized array</a>) of the compiled list of pointers to the pattern restrictions. The array can be found in the <a class="el" href="group__schematree.html#a60edcced5c999f3d57f7f8cc49ce8129">lysc_type_str.patterns</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to validate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_len</td><td>Length (number of bytes) of the string to validate (mandatory). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error information in case of failure or non-matching <code>str</code>. The error structure can be freed by <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS when <code>matches</code> all the patterns. </dd>
<dd>
LY_EVALID when <code>does</code> not match any of the patterns. </dd>
<dd>
LY_ESYS in case of PCRE2 error. </dd></dl>

</div>
</div>
<a id="ga9cb155161a68bc8b8737c1654f49be63" name="ga9cb155161a68bc8b8737c1654f49be63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb155161a68bc8b8737c1654f49be63">&#9670;&#160;</a></span>lyplg_type_validate_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_validate_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga1d29870a66477e9cba0c489cca9c4da7">LY_DATA_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>basetype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__schematree.html#structlysc__range">lysc_range</a> *</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>strval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>strval_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type validator for a range/length-restricted values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basetype</td><td>Base built-in type of the type with the range specified to get know if the <code>range</code> structure represents range or length restriction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>Range (length) restriction information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to check. In case of basetypes using unsigned integer values, the value is actually cast to uint64_t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strval</td><td>String representation of the <code>value</code> for error logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strval_len</td><td>Length of <code>strval</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error information in case of failure. The error structure can be freed by <a class="el" href="#ga57427367fc3afcd961be2515c4796f42" title="Destructor for the error records created with ly_err_new().">ly_err_free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value according to the result of the validation. </dd></dl>

</div>
</div>
<a id="ga349c435a36eea29b153459acbc90855e" name="ga349c435a36eea29b153459acbc90855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga349c435a36eea29b153459acbc90855e">&#9670;&#160;</a></span>lyplg_type_xpath10_print_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DEF <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyplg_type_xpath10_print_token </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>tok_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>is_nametest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> **</td>          <td class="paramname"><span class="paramname"><em>context_mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>resolve_ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>resolve_format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>resolve_prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>get_format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>get_prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>token_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print xpath1.0 token in the specific format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>Token to transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tok_len</td><td>Lenghth of <code>token</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_nametest</td><td>Whether the token is a nametest, it then always requires a prefix in XML <code>get_format</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context_mod</td><td>Current context module, may be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_ctx</td><td>Context to use for resolving prefixes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_format</td><td>Format of the resolved prefixes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_prefix_data</td><td>Resolved prefixes prefix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_format</td><td>Format of the output prefixes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_prefix_data</td><td>Format-specific prefix data for the output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">token_p</td><td>Printed token. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error structure on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpath1_80_8c_source.html#l00043">43</a> of file <a class="el" href="xpath1_80_8c_source.html">xpath1.0.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga81738abddbf65a7d7ce445724743241b" name="ga81738abddbf65a7d7ce445724743241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81738abddbf65a7d7ce445724743241b">&#9670;&#160;</a></span>lyplg_type_store_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyplg_type_store_clb) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *type, const void *value, size_t value_len, uint32_t options, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, uint32_t hints, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *ctx_node, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *storage, struct lys_glob_unres *unres, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err) </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>hints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lys_glob_unres *</td>          <td class="paramname"><span class="paramname"><em>unres</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to store the given <code>value</code> according to the given <code>type</code>. </p>
<p>Value must always be correctly stored meaning all the other type callbacks (such as print or compare) must function as expected. However, <a class="el" href="tree__data_8h.html#aeb325cb6a5ece5afc90b51d78e622d55">lyd_value._canonical</a> can be left NULL and will be generated and stored on-demand. But if <code>format</code> is <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a6e77cde4a1edbafa863e953403b75d02">LY_VALUE_CANON</a> (or another, which must be equal to the canonical value), the canonical value should be stored so that it does not have to be generated later.</p>
<p>Note that the <code>value</code> is not necessarily used whole (may not be zero-terminated if a string). The provided <code>value_len</code> is always correct. All store functions have to free a dynamically allocated <code>value</code> in all cases (even on error).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the value being stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length (number of bytes) of the given <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="group__plugintypestoreopts.html">Type plugin store options</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Input format of the value, see the description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific data for resolving any prefixes (see ly_resolve_prefix()). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hints</td><td>Bitmap of <a class="el" href="group__lydvalhints.html">value hints</a> of all the allowed value types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Schema context node of <code>value</code>, may be NULL for metadata. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">storage</td><td>Storage for the value in the type's specific encoding. Except for <em>canonical</em>, all the members should be filled by the plugin (if it fills them at all). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">unres</td><td>Global unres structure for newly implemented modules. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Optionally provided error information in case of failure. If not provided to the caller, a generic error message is prepared instead. The error structure can be created by <a class="el" href="#ga37846e55b009a1a21e4adf78f18d2ceb" title="Create and fill error structure.">ly_err_new()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_EINCOMPLETE in case the <a class="el" href="#ga3e84f119ae5d6588309a4cf39ea9e986" title="Callback to validate the stored value in data.">lyplg_type_validate_clb</a> should be called to finish value validation in data, </dd>
<dd>
LY_ERR value on error, <code>storage</code> must not have any pointers to dynamic memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00509">509</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
<a id="ga3e84f119ae5d6588309a4cf39ea9e986" name="ga3e84f119ae5d6588309a4cf39ea9e986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e84f119ae5d6588309a4cf39ea9e986">&#9670;&#160;</a></span>lyplg_type_validate_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyplg_type_validate_clb) (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *type, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *tree, struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *storage, struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **err) </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="tree__data_8h.html#structlyd__value">lyd_value</a> *</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__errors.html#structly__err__item">ly_err_item</a> **</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to validate the stored value in data. </p>
<p>This callback is optional for types that can only be validated in a data tree. It must be called and succeed in case the <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a> callback returned <a class="el" href="group__errors.html#ggabfc4235478f06567d878806b8c0c6992ae6e061fa1dc6f6c200de678e8dee7792">LY_EINCOMPLETE</a> for the value to be valid. However, this callback can be called even in other cases (such as separate/repeated validation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Original type of the value (not necessarily the stored one) being validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>The value data context node for validation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>External data tree (e.g. when validating RPC/Notification) with possibly referenced data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>Storage of the value successfully filled by <a class="el" href="#ga81738abddbf65a7d7ce445724743241b" title="Callback to store the given value according to the given type.">lyplg_type_store_clb</a>. May be modified. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Optionally provided error information in case of failure. If not provided to the caller, a generic error message is prepared instead. The error structure can be created by <a class="el" href="#ga37846e55b009a1a21e4adf78f18d2ceb" title="Create and fill error structure.">ly_err_new()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR value on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="plugins__types_8h_source.html#l00530">530</a> of file <a class="el" href="plugins__types_8h_source.html">plugins_types.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 28 2025 10:44:40 for libyang by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
