<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libyang: Context</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libyang<span id="projectnumber">&#160;2.1.148</span>
   </div>
   <div id="projectbrief">libyang is YANG data modelling language parser and toolkit written (and providing API) in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__context.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Context</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Context:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__context.svg" width="240" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__contextoptions.html">Context options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structly__ctx" id="r_structly__ctx"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structly__ctx">ly_ctx</a></td></tr>
<tr class="memdesc:structly__ctx"><td class="mdescLeft">&#160;</td><td class="mdescRight">libyang context handler.  <a href="#structly__ctx">More...</a><br /></td></tr>
<tr class="separator:structly__ctx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5513a90fe7a64af7ec5217e6fd8af187" id="r_ga5513a90fe7a64af7ec5217e6fd8af187"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5513a90fe7a64af7ec5217e6fd8af187">ly_ext_data_clb</a>) (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, void *user_data, void **ext_data, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *ext_data_free)</td></tr>
<tr class="memdesc:ga5513a90fe7a64af7ec5217e6fd8af187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for getting arbitrary run-time data required by an extension instance.  <br /></td></tr>
<tr class="separator:ga5513a90fe7a64af7ec5217e6fd8af187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a077cfc7d38cc086c1f3b5e45e71e10" id="r_ga2a077cfc7d38cc086c1f3b5e45e71e10"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">ly_module_imp_clb</a>) (const char *mod_name, const char *mod_rev, const char *submod_name, const char *submod_rev, void *user_data, <a class="el" href="group__schematree.html#gab97e95b1813682b313d1c26207b6881a">LYS_INFORMAT</a> *format, const char **module_data, <a class="el" href="#gabaf4757f516e5b1473087c5527196cb9">ly_module_imp_data_free_clb</a> *free_module_data)</td></tr>
<tr class="memdesc:ga2a077cfc7d38cc086c1f3b5e45e71e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for retrieving missing included or imported models in a custom way.  <br /></td></tr>
<tr class="separator:ga2a077cfc7d38cc086c1f3b5e45e71e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf4757f516e5b1473087c5527196cb9" id="r_gabaf4757f516e5b1473087c5527196cb9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabaf4757f516e5b1473087c5527196cb9">ly_module_imp_data_free_clb</a>) (void *module_data, void *user_data)</td></tr>
<tr class="memdesc:gabaf4757f516e5b1473087c5527196cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for freeing returned module data in <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10" title="Callback for retrieving missing included or imported models in a custom way.">ly_module_imp_clb</a>.  <br /></td></tr>
<tr class="separator:gabaf4757f516e5b1473087c5527196cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabd07ff68e2f9c5df8c1cf8a8334c994d" id="r_gabd07ff68e2f9c5df8c1cf8a8334c994d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabd07ff68e2f9c5df8c1cf8a8334c994d">ly_ctx_compile</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:gabd07ff68e2f9c5df8c1cf8a8334c994d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile (recompile) the context applying all the performed changes after the last context compilation. Should be used only if <a class="el" href="group__contextoptions.html#ga17ce7b15b2b448860197416e48d62fd9">LY_CTX_EXPLICIT_COMPILE</a> option is set, has no effect otherwise.  <br /></td></tr>
<tr class="separator:gabd07ff68e2f9c5df8c1cf8a8334c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7677ab72c8bcaa621e0ae4063076d7f7" id="r_ga7677ab72c8bcaa621e0ae4063076d7f7"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7677ab72c8bcaa621e0ae4063076d7f7">ly_ctx_destroy</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga7677ab72c8bcaa621e0ae4063076d7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all internal structures of the specified context.  <br /></td></tr>
<tr class="separator:ga7677ab72c8bcaa621e0ae4063076d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfb3bae1347b1ff07ee3b3e55e96dac" id="r_gaecfb3bae1347b1ff07ee3b3e55e96dac"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaecfb3bae1347b1ff07ee3b3e55e96dac">ly_ctx_get_change_count</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:gaecfb3bae1347b1ff07ee3b3e55e96dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the change count of the context (module set) during its life-time.  <br /></td></tr>
<tr class="separator:gaecfb3bae1347b1ff07ee3b3e55e96dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f96a2aa769ba4910bbb6af479abd101" id="r_ga3f96a2aa769ba4910bbb6af479abd101"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f96a2aa769ba4910bbb6af479abd101">ly_ctx_get_module</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *name, const char *revision)</td></tr>
<tr class="memdesc:ga3f96a2aa769ba4910bbb6af479abd101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get YANG module of the given name and revision.  <br /></td></tr>
<tr class="separator:ga3f96a2aa769ba4910bbb6af479abd101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026fc9d4ecfa61ee4c6c92662b47ead2" id="r_ga026fc9d4ecfa61ee4c6c92662b47ead2"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">ly_module_imp_clb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga026fc9d4ecfa61ee4c6c92662b47ead2">ly_ctx_get_module_imp_clb</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, void **user_data)</td></tr>
<tr class="memdesc:ga026fc9d4ecfa61ee4c6c92662b47ead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the custom callback for missing import/include module retrieval.  <br /></td></tr>
<tr class="separator:ga026fc9d4ecfa61ee4c6c92662b47ead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3103754834298177ec380a555cea70f0" id="r_ga3103754834298177ec380a555cea70f0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3103754834298177ec380a555cea70f0">ly_ctx_get_module_implemented</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *name)</td></tr>
<tr class="memdesc:ga3103754834298177ec380a555cea70f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (only) implemented YANG module specified by its name.  <br /></td></tr>
<tr class="separator:ga3103754834298177ec380a555cea70f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51dc9a3127acfd4a551f21c30bec49b" id="r_gac51dc9a3127acfd4a551f21c30bec49b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac51dc9a3127acfd4a551f21c30bec49b">ly_ctx_get_module_implemented_ns</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *ns)</td></tr>
<tr class="memdesc:gac51dc9a3127acfd4a551f21c30bec49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (only) implemented YANG module specified by its namespace.  <br /></td></tr>
<tr class="separator:gac51dc9a3127acfd4a551f21c30bec49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00189c75d3d0ebb3071558dced622af" id="r_gac00189c75d3d0ebb3071558dced622af"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac00189c75d3d0ebb3071558dced622af">ly_ctx_get_module_iter</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, uint32_t *index)</td></tr>
<tr class="memdesc:gac00189c75d3d0ebb3071558dced622af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all modules in the given context.  <br /></td></tr>
<tr class="separator:gac00189c75d3d0ebb3071558dced622af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8af16b91e25869a784f32eb86d8f3f" id="r_gafe8af16b91e25869a784f32eb86d8f3f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe8af16b91e25869a784f32eb86d8f3f">ly_ctx_get_module_latest</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *name)</td></tr>
<tr class="memdesc:gafe8af16b91e25869a784f32eb86d8f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latest revision of the YANG module specified by its name.  <br /></td></tr>
<tr class="separator:gafe8af16b91e25869a784f32eb86d8f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87a30c6b9b75eb9acbae04e253ce96b" id="r_gaa87a30c6b9b75eb9acbae04e253ce96b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa87a30c6b9b75eb9acbae04e253ce96b">ly_ctx_get_module_latest_ns</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *ns)</td></tr>
<tr class="memdesc:gaa87a30c6b9b75eb9acbae04e253ce96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latest revision of the YANG module specified by its namespace.  <br /></td></tr>
<tr class="separator:gaa87a30c6b9b75eb9acbae04e253ce96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aeee46c2c84a3138d7fc164a4168613" id="r_ga9aeee46c2c84a3138d7fc164a4168613"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9aeee46c2c84a3138d7fc164a4168613">ly_ctx_get_module_ns</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *ns, const char *revision)</td></tr>
<tr class="memdesc:ga9aeee46c2c84a3138d7fc164a4168613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get YANG module of the given namespace and revision.  <br /></td></tr>
<tr class="separator:ga9aeee46c2c84a3138d7fc164a4168613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f19af25468b1507aa5da5101000c59" id="r_ga35f19af25468b1507aa5da5101000c59"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga35f19af25468b1507aa5da5101000c59">ly_ctx_get_modules_hash</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga35f19af25468b1507aa5da5101000c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash of all the modules in the context. Since order of the modules is significant, even when 2 contexts have the same modules but loaded in a different order, the hash will differ.  <br /></td></tr>
<tr class="separator:ga35f19af25468b1507aa5da5101000c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb1237e1bff1c256d5bde73294fd28a" id="r_ga3eb1237e1bff1c256d5bde73294fd28a"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3eb1237e1bff1c256d5bde73294fd28a">ly_ctx_get_options</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga3eb1237e1bff1c256d5bde73294fd28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently set context's options.  <br /></td></tr>
<tr class="separator:ga3eb1237e1bff1c256d5bde73294fd28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac15831c1901cbdfe9970b060efa887" id="r_ga7ac15831c1901cbdfe9970b060efa887"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ac15831c1901cbdfe9970b060efa887">ly_ctx_get_searchdirs</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga7ac15831c1901cbdfe9970b060efa887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NULL-terminated list of the search paths in libyang context. Do not modify the result!  <br /></td></tr>
<tr class="separator:ga7ac15831c1901cbdfe9970b060efa887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fc25c4a14a47dde327f95f6016b59b" id="r_ga60fc25c4a14a47dde327f95f6016b59b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60fc25c4a14a47dde327f95f6016b59b">ly_ctx_get_submodule</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *submodule, const char *revision)</td></tr>
<tr class="memdesc:ga60fc25c4a14a47dde327f95f6016b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific submodule from context. If its belongs-to module is known, use <a class="el" href="#gadfecb8bfe0a51500a644a3de4ad852ac" title="Get a specific submodule from a module. If the belongs-to module is not known, use ly_ctx_get_submodu...">ly_ctx_get_submodule2()</a>.  <br /></td></tr>
<tr class="separator:ga60fc25c4a14a47dde327f95f6016b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfecb8bfe0a51500a644a3de4ad852ac" id="r_gadfecb8bfe0a51500a644a3de4ad852ac"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadfecb8bfe0a51500a644a3de4ad852ac">ly_ctx_get_submodule2</a> (const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *submodule, const char *revision)</td></tr>
<tr class="memdesc:gadfecb8bfe0a51500a644a3de4ad852ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific submodule from a module. If the belongs-to module is not known, use <a class="el" href="#ga60fc25c4a14a47dde327f95f6016b59b" title="Get a specific submodule from context. If its belongs-to module is known, use ly_ctx_get_submodule2()...">ly_ctx_get_submodule()</a>.  <br /></td></tr>
<tr class="separator:gadfecb8bfe0a51500a644a3de4ad852ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911278e5a9e0fbeeb71d99e34954f4f5" id="r_ga911278e5a9e0fbeeb71d99e34954f4f5"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga911278e5a9e0fbeeb71d99e34954f4f5">ly_ctx_get_submodule2_latest</a> (const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *submodule)</td></tr>
<tr class="memdesc:ga911278e5a9e0fbeeb71d99e34954f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latest revision of a submodule from a module. If the belongs-to module is not known, use <a class="el" href="#ga791db2a28a723fa4c5d3e0c0648d8c85" title="Get the latests revision of a submodule from context. If its belongs-to module is known,...">ly_ctx_get_submodule_latest()</a>.  <br /></td></tr>
<tr class="separator:ga911278e5a9e0fbeeb71d99e34954f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791db2a28a723fa4c5d3e0c0648d8c85" id="r_ga791db2a28a723fa4c5d3e0c0648d8c85"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga791db2a28a723fa4c5d3e0c0648d8c85">ly_ctx_get_submodule_latest</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *submodule)</td></tr>
<tr class="memdesc:ga791db2a28a723fa4c5d3e0c0648d8c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latests revision of a submodule from context. If its belongs-to module is known, use <a class="el" href="#ga911278e5a9e0fbeeb71d99e34954f4f5" title="Get the latest revision of a submodule from a module. If the belongs-to module is not known,...">ly_ctx_get_submodule2_latest()</a>.  <br /></td></tr>
<tr class="separator:ga791db2a28a723fa4c5d3e0c0648d8c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a07a3afcc26cd0615e629924179945" id="r_ga34a07a3afcc26cd0615e629924179945"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34a07a3afcc26cd0615e629924179945">ly_ctx_get_yanglib_data</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> **root, const char *content_id_format,...)</td></tr>
<tr class="memdesc:ga34a07a3afcc26cd0615e629924179945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data of the internal ietf-yang-library module with information about all the loaded modules. ietf-yang-library module must be loaded.  <br /></td></tr>
<tr class="separator:ga34a07a3afcc26cd0615e629924179945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e9bb7dd7f70dff6e00f821f2b40969" id="r_ga50e9bb7dd7f70dff6e00f821f2b40969"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50e9bb7dd7f70dff6e00f821f2b40969">ly_ctx_internal_modules_count</a> (const struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga50e9bb7dd7f70dff6e00f821f2b40969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn the number of internal modules of a context. Internal modules is considered one that was loaded during the context creation.  <br /></td></tr>
<tr class="separator:ga50e9bb7dd7f70dff6e00f821f2b40969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a4fb33c996e06ce3dde4f578905c87" id="r_gab2a4fb33c996e06ce3dde4f578905c87"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab2a4fb33c996e06ce3dde4f578905c87">ly_ctx_load_module</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *name, const char *revision, const char **features)</td></tr>
<tr class="memdesc:gab2a4fb33c996e06ce3dde4f578905c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find the model in the searchpaths of <code>ctx</code> and load it into it. If custom missing module callback is set, it is used instead.  <br /></td></tr>
<tr class="separator:gab2a4fb33c996e06ce3dde4f578905c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a2bdf484be8dd3657a141d2cc0500e" id="r_ga16a2bdf484be8dd3657a141d2cc0500e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16a2bdf484be8dd3657a141d2cc0500e">ly_ctx_new</a> (const char *search_dir, uint16_t options, struct <a class="el" href="#structly__ctx">ly_ctx</a> **new_ctx)</td></tr>
<tr class="memdesc:ga16a2bdf484be8dd3657a141d2cc0500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create libyang context.  <br /></td></tr>
<tr class="separator:ga16a2bdf484be8dd3657a141d2cc0500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916d69eee34fa948012658297155f2ed" id="r_ga916d69eee34fa948012658297155f2ed"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga916d69eee34fa948012658297155f2ed">ly_ctx_new_yldata</a> (const char *search_dir, const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *tree, int options, struct <a class="el" href="#structly__ctx">ly_ctx</a> **ctx)</td></tr>
<tr class="memdesc:ga916d69eee34fa948012658297155f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create libyang context according to the provided yang-library data in a data tree.  <br /></td></tr>
<tr class="separator:ga916d69eee34fa948012658297155f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e904e97a3c621c0691dae664b5b3e52" id="r_ga7e904e97a3c621c0691dae664b5b3e52"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7e904e97a3c621c0691dae664b5b3e52">ly_ctx_new_ylmem</a> (const char *search_dir, const char *data, <a class="el" href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">LYD_FORMAT</a> format, int options, struct <a class="el" href="#structly__ctx">ly_ctx</a> **ctx)</td></tr>
<tr class="memdesc:ga7e904e97a3c621c0691dae664b5b3e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create libyang context according to the provided yang-library data in a string.  <br /></td></tr>
<tr class="separator:ga7e904e97a3c621c0691dae664b5b3e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea2062363df5d00927ef36ccbeae7bd" id="r_gafea2062363df5d00927ef36ccbeae7bd"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafea2062363df5d00927ef36ccbeae7bd">ly_ctx_new_ylpath</a> (const char *search_dir, const char *path, <a class="el" href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">LYD_FORMAT</a> format, int options, struct <a class="el" href="#structly__ctx">ly_ctx</a> **ctx)</td></tr>
<tr class="memdesc:gafea2062363df5d00927ef36ccbeae7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create libyang context according to the provided yang-library data in a file.  <br /></td></tr>
<tr class="separator:gafea2062363df5d00927ef36ccbeae7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969426519ea501704daf6019ec934de5" id="r_ga969426519ea501704daf6019ec934de5"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga969426519ea501704daf6019ec934de5">ly_ctx_reset_latests</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ga969426519ea501704daf6019ec934de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset cached latest revision information of the schemas in the context.  <br /></td></tr>
<tr class="separator:ga969426519ea501704daf6019ec934de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14853fe1a338c94d9e81be9566438243" id="r_ga14853fe1a338c94d9e81be9566438243"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="#ga5513a90fe7a64af7ec5217e6fd8af187">ly_ext_data_clb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga14853fe1a338c94d9e81be9566438243">ly_ctx_set_ext_data_clb</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, <a class="el" href="#ga5513a90fe7a64af7ec5217e6fd8af187">ly_ext_data_clb</a> clb, void *user_data)</td></tr>
<tr class="memdesc:ga14853fe1a338c94d9e81be9566438243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback providing run-time extension instance data. The expected data depend on the extension. Data expected by internal extensions:  <br /></td></tr>
<tr class="separator:ga14853fe1a338c94d9e81be9566438243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704db60ea84aa35b1a54a77908949388" id="r_ga704db60ea84aa35b1a54a77908949388"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga704db60ea84aa35b1a54a77908949388">ly_ctx_set_module_imp_clb</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">ly_module_imp_clb</a> clb, void *user_data)</td></tr>
<tr class="memdesc:ga704db60ea84aa35b1a54a77908949388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set missing include or import module callback. It is meant to be used when the models are not locally available (such as when downloading modules from a NETCONF server), it should not be required in other cases.  <br /></td></tr>
<tr class="separator:ga704db60ea84aa35b1a54a77908949388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1891df928268ec799f11435d80a32e42" id="r_ga1891df928268ec799f11435d80a32e42"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1891df928268ec799f11435d80a32e42">ly_ctx_set_options</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, uint16_t option)</td></tr>
<tr class="memdesc:ga1891df928268ec799f11435d80a32e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set some of the context's options, see <a class="el" href="group__contextoptions.html">Context options</a>.  <br /></td></tr>
<tr class="separator:ga1891df928268ec799f11435d80a32e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779252a9f7d23e09c2ceade107c3578f" id="r_ga779252a9f7d23e09c2ceade107c3578f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga779252a9f7d23e09c2ceade107c3578f">ly_ctx_set_searchdir</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *search_dir)</td></tr>
<tr class="memdesc:ga779252a9f7d23e09c2ceade107c3578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the search path into libyang context.  <br /></td></tr>
<tr class="separator:ga779252a9f7d23e09c2ceade107c3578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542b84c9cdcf7f397259d7178ee38b7c" id="r_ga542b84c9cdcf7f397259d7178ee38b7c"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga542b84c9cdcf7f397259d7178ee38b7c">ly_ctx_unset_options</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, uint16_t option)</td></tr>
<tr class="memdesc:ga542b84c9cdcf7f397259d7178ee38b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset some of the context's options, see <a class="el" href="group__contextoptions.html">Context options</a>.  <br /></td></tr>
<tr class="separator:ga542b84c9cdcf7f397259d7178ee38b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fdeb55ccad44d3b4b78bb116959c9d4" id="r_ga0fdeb55ccad44d3b4b78bb116959c9d4"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fdeb55ccad44d3b4b78bb116959c9d4">ly_ctx_unset_searchdir</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, const char *value)</td></tr>
<tr class="memdesc:ga0fdeb55ccad44d3b4b78bb116959c9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the search path(s) from the libyang context.  <br /></td></tr>
<tr class="separator:ga0fdeb55ccad44d3b4b78bb116959c9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847a60f97cd514dd755d0b2e4e6d54c8" id="r_ga847a60f97cd514dd755d0b2e4e6d54c8"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga847a60f97cd514dd755d0b2e4e6d54c8">ly_ctx_unset_searchdir_last</a> (struct <a class="el" href="#structly__ctx">ly_ctx</a> *ctx, uint32_t count)</td></tr>
<tr class="memdesc:ga847a60f97cd514dd755d0b2e4e6d54c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the least recently added search path(s) from the libyang context.  <br /></td></tr>
<tr class="separator:ga847a60f97cd514dd755d0b2e4e6d54c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Structures and functions to manipulate with the libyang context containers.</p>
<p>The <em>context</em> concept allows callers to work in environments with different sets of YANG schemas. More detailed information can be found at <a class="el" href="howto_context.html">Context</a> page. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structly__ctx" id="structly__ctx"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structly__ctx">&#9670;&#160;</a></span>ly_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ly_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>libyang context handler. </p>
</div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5513a90fe7a64af7ec5217e6fd8af187" name="ga5513a90fe7a64af7ec5217e6fd8af187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5513a90fe7a64af7ec5217e6fd8af187">&#9670;&#160;</a></span>ly_ext_data_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* ly_ext_data_clb) (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, void *user_data, void **ext_data, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *ext_data_free)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for getting arbitrary run-time data required by an extension instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Compiled extension instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User-supplied callback data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ext_data</td><td>Provided extension instance data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ext_data_free</td><td>Whether the extension instance should free <code>ext_data</code> or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="context_8h_source.html#l00449">449</a> of file <a class="el" href="context_8h_source.html">context.h</a>.</p>

</div>
</div>
<a id="ga2a077cfc7d38cc086c1f3b5e45e71e10" name="ga2a077cfc7d38cc086c1f3b5e45e71e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">&#9670;&#160;</a></span>ly_module_imp_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* ly_module_imp_clb) (const char *mod_name, const char *mod_rev, const char *submod_name, const char *submod_rev, void *user_data, <a class="el" href="group__schematree.html#gab97e95b1813682b313d1c26207b6881a">LYS_INFORMAT</a> *format, const char **module_data, <a class="el" href="#gabaf4757f516e5b1473087c5527196cb9">ly_module_imp_data_free_clb</a> *free_module_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for retrieving missing included or imported models in a custom way. </p>
<p>When <code>submod_name</code> is provided, the submodule is requested instead of the module (in this case only the module name without its revision is provided).</p>
<p>If an </p><ul>
<li>free_module_data callback is provided, it will be used later to free the allegedly const data which were returned by this callback.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_name</td><td>Missing module name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_rev</td><td>Optional missing module revision. If NULL and submod_name is not provided, the latest revision is requested, the parsed module is then marked by the latest_revision flag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submod_name</td><td>Optional missing submodule name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submod_rev</td><td>Optional missing submodule revision. If NULL and submod_name is provided, the latest revision is requested, the parsed submodule is then marked by the latest_revision flag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User-supplied callback data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td>Format of the returned module data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_data</td><td>Requested module data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">free_module_data</td><td>Callback for freeing the returned module data. If not set, the data will be left untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. If the returned value differs from LY_SUCCESS, libyang continue in trying to get the module data according to the settings of its mechanism to search for the imported/included schemas. </dd></dl>

<p class="definition">Definition at line <a class="el" href="context_8h_source.html#l00417">417</a> of file <a class="el" href="context_8h_source.html">context.h</a>.</p>

</div>
</div>
<a id="gabaf4757f516e5b1473087c5527196cb9" name="gabaf4757f516e5b1473087c5527196cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf4757f516e5b1473087c5527196cb9">&#9670;&#160;</a></span>ly_module_imp_data_free_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ly_module_imp_data_free_clb) (void *module_data, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for freeing returned module data in <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10" title="Callback for retrieving missing included or imported models in a custom way.">ly_module_imp_clb</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_data</td><td>Data to free. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User-supplied callback data, same as for <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10" title="Callback for retrieving missing included or imported models in a custom way.">ly_module_imp_clb</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="context_8h_source.html#l00393">393</a> of file <a class="el" href="context_8h_source.html">context.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabd07ff68e2f9c5df8c1cf8a8334c994d" name="gabd07ff68e2f9c5df8c1cf8a8334c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd07ff68e2f9c5df8c1cf8a8334c994d">&#9670;&#160;</a></span>ly_ctx_compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_compile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile (recompile) the context applying all the performed changes after the last context compilation. Should be used only if <a class="el" href="group__contextoptions.html#ga17ce7b15b2b448860197416e48d62fd9">LY_CTX_EXPLICIT_COMPILE</a> option is set, has no effect otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to compile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value. </dd></dl>

</div>
</div>
<a id="ga7677ab72c8bcaa621e0ae4063076d7f7" name="ga7677ab72c8bcaa621e0ae4063076d7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7677ab72c8bcaa621e0ae4063076d7f7">&#9670;&#160;</a></span>ly_ctx_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void ly_ctx_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all internal structures of the specified context. </p>
<p>The function should be used before terminating the application to destroy and free all structures internally used by libyang. If the caller uses multiple contexts, the function should be called for each used context.</p>
<p>All instance data are supposed to be freed before destroying the context using <a class="el" href="tree__data_8h.html#a0678ec989c6861afc9d14b77630b4719" title="Free all the nodes (even parents of the node) in the data tree.">lyd_free_all()</a>, for example. Data models (schemas) are destroyed automatically as part of <a class="el" href="#ga7677ab72c8bcaa621e0ae4063076d7f7" title="Free all internal structures of the specified context.">ly_ctx_destroy()</a> call.</p>
<p>Note that the data stored by user into the <a class="el" href="group__schematree.html#a83d1dfdd6dc1c916094f62ec96213998">lysc_node.priv</a> pointer are kept untouched and the caller is responsible for freeing this private data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecfb3bae1347b1ff07ee3b3e55e96dac" name="gaecfb3bae1347b1ff07ee3b3e55e96dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfb3bae1347b1ff07ee3b3e55e96dac">&#9670;&#160;</a></span>ly_ctx_get_change_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL uint16_t ly_ctx_get_change_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the change count of the context (module set) during its life-time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Context change count. </dd></dl>

</div>
</div>
<a id="ga3f96a2aa769ba4910bbb6af479abd101" name="ga3f96a2aa769ba4910bbb6af479abd101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f96a2aa769ba4910bbb6af479abd101">&#9670;&#160;</a></span>ly_ctx_get_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>revision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get YANG module of the given name and revision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to work in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the YANG module to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revision</td><td>Requested revision date of the YANG module to get. If not specified, the schema with no revision is returned, if it is present in the context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the YANG module, NULL if no schema in the context follows the name and revision requirements. </dd></dl>

</div>
</div>
<a id="ga026fc9d4ecfa61ee4c6c92662b47ead2" name="ga026fc9d4ecfa61ee4c6c92662b47ead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga026fc9d4ecfa61ee4c6c92662b47ead2">&#9670;&#160;</a></span>ly_ctx_get_module_imp_clb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">ly_module_imp_clb</a> ly_ctx_get_module_imp_clb </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the custom callback for missing import/include module retrieval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Optional pointer for getting the user-supplied callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Callback or NULL if not set. </dd></dl>

</div>
</div>
<a id="ga3103754834298177ec380a555cea70f0" name="ga3103754834298177ec380a555cea70f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3103754834298177ec380a555cea70f0">&#9670;&#160;</a></span>ly_ctx_get_module_implemented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_implemented </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (only) implemented YANG module specified by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the YANG module to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The only implemented YANG module revision of the given name in the given context. NULL if there is no implemented module of the given name. </dd></dl>

</div>
</div>
<a id="gac51dc9a3127acfd4a551f21c30bec49b" name="gac51dc9a3127acfd4a551f21c30bec49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51dc9a3127acfd4a551f21c30bec49b">&#9670;&#160;</a></span>ly_ctx_get_module_implemented_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_implemented_ns </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (only) implemented YANG module specified by its namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ns</td><td>Namespace of the YANG module to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The only implemented YANG module revision of the given namespace in the given context. NULL if there is no implemented module of the given namespace. </dd></dl>

</div>
</div>
<a id="gac00189c75d3d0ebb3071558dced622af" name="gac00189c75d3d0ebb3071558dced622af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00189c75d3d0ebb3071558dced622af">&#9670;&#160;</a></span>ly_ctx_get_module_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_iter </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all modules in the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context with the modules. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Index of the next module to get. Value of 0 starts from the beginning. The value is updated with each call, so to iterate over all modules the same variable is supposed to be used in all calls starting with value 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next context module, NULL if the last was already returned. </dd></dl>

</div>
</div>
<a id="gafe8af16b91e25869a784f32eb86d8f3f" name="gafe8af16b91e25869a784f32eb86d8f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe8af16b91e25869a784f32eb86d8f3f">&#9670;&#160;</a></span>ly_ctx_get_module_latest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_latest </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the latest revision of the YANG module specified by its name. </p>
<p>YANG modules with no revision are supposed to be the oldest one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the YANG module to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latest revision of the specified YANG module in the given context, NULL if no YANG module of the given name is present in the context. </dd></dl>

</div>
</div>
<a id="gaa87a30c6b9b75eb9acbae04e253ce96b" name="gaa87a30c6b9b75eb9acbae04e253ce96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa87a30c6b9b75eb9acbae04e253ce96b">&#9670;&#160;</a></span>ly_ctx_get_module_latest_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_latest_ns </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the latest revision of the YANG module specified by its namespace. </p>
<p>YANG modules with no revision are supposed to be the oldest one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ns</td><td>Namespace of the YANG module to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latest revision of the specified YANG module in the given context, NULL if no YANG module of the given namespace is present in the context. </dd></dl>

</div>
</div>
<a id="ga9aeee46c2c84a3138d7fc164a4168613" name="ga9aeee46c2c84a3138d7fc164a4168613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aeee46c2c84a3138d7fc164a4168613">&#9670;&#160;</a></span>ly_ctx_get_module_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_get_module_ns </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>revision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get YANG module of the given namespace and revision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to work in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ns</td><td>Namespace of the YANG module to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revision</td><td>Requested revision date of the YANG module to get. If not specified, the schema with no revision is returned, if it is present in the context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the YANG module, NULL if no schema in the context follows the namespace and revision requirements. </dd></dl>

</div>
</div>
<a id="ga35f19af25468b1507aa5da5101000c59" name="ga35f19af25468b1507aa5da5101000c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35f19af25468b1507aa5da5101000c59">&#9670;&#160;</a></span>ly_ctx_get_modules_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL uint32_t ly_ctx_get_modules_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hash of all the modules in the context. Since order of the modules is significant, even when 2 contexts have the same modules but loaded in a different order, the hash will differ. </p>
<p>Hash consists of all module names (1), their revisions (2), all enabled features (3), and their imported/implemented state (4).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Context modules hash. </dd></dl>

</div>
</div>
<a id="ga3eb1237e1bff1c256d5bde73294fd28a" name="ga3eb1237e1bff1c256d5bde73294fd28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb1237e1bff1c256d5bde73294fd28a">&#9670;&#160;</a></span>ly_ctx_get_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL uint16_t ly_ctx_get_options </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently set context's options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Combination of all the currently set context's options, see <a class="el" href="group__contextoptions.html">Context options</a>. </dd></dl>

</div>
</div>
<a id="ga7ac15831c1901cbdfe9970b060efa887" name="ga7ac15831c1901cbdfe9970b060efa887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac15831c1901cbdfe9970b060efa887">&#9670;&#160;</a></span>ly_ctx_get_searchdirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const char *const  * ly_ctx_get_searchdirs </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NULL-terminated list of the search paths in libyang context. Do not modify the result! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated list (array) of the search paths, NULL if no searchpath was set. Do not modify the provided data in any way! </dd></dl>

</div>
</div>
<a id="ga60fc25c4a14a47dde327f95f6016b59b" name="ga60fc25c4a14a47dde327f95f6016b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fc25c4a14a47dde327f95f6016b59b">&#9670;&#160;</a></span>ly_ctx_get_submodule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> * ly_ctx_get_submodule </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>submodule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>revision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific submodule from context. If its belongs-to module is known, use <a class="el" href="#gadfecb8bfe0a51500a644a3de4ad852ac" title="Get a specific submodule from a module. If the belongs-to module is not known, use ly_ctx_get_submodu...">ly_ctx_get_submodule2()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submodule</td><td>Submodule name to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revision</td><td>Revision of the submodule to find, NULL for a submodule without a revision. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found submodule, NULL if there is none. </dd></dl>

</div>
</div>
<a id="gadfecb8bfe0a51500a644a3de4ad852ac" name="gadfecb8bfe0a51500a644a3de4ad852ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfecb8bfe0a51500a644a3de4ad852ac">&#9670;&#160;</a></span>ly_ctx_get_submodule2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> * ly_ctx_get_submodule2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>submodule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>revision</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific submodule from a module. If the belongs-to module is not known, use <a class="el" href="#ga60fc25c4a14a47dde327f95f6016b59b" title="Get a specific submodule from context. If its belongs-to module is known, use ly_ctx_get_submodule2()...">ly_ctx_get_submodule()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Belongs-to module to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submodule</td><td>Submodule name to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revision</td><td>Revision of the submodule to find, NULL for a submodule without a revision. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found submodule, NULL if there is none. </dd></dl>

</div>
</div>
<a id="ga911278e5a9e0fbeeb71d99e34954f4f5" name="ga911278e5a9e0fbeeb71d99e34954f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga911278e5a9e0fbeeb71d99e34954f4f5">&#9670;&#160;</a></span>ly_ctx_get_submodule2_latest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> * ly_ctx_get_submodule2_latest </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>submodule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the latest revision of a submodule from a module. If the belongs-to module is not known, use <a class="el" href="#ga791db2a28a723fa4c5d3e0c0648d8c85" title="Get the latests revision of a submodule from context. If its belongs-to module is known,...">ly_ctx_get_submodule_latest()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Belongs-to module to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submodule</td><td>Submodule name to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found submodule, NULL if there is none. </dd></dl>

</div>
</div>
<a id="ga791db2a28a723fa4c5d3e0c0648d8c85" name="ga791db2a28a723fa4c5d3e0c0648d8c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791db2a28a723fa4c5d3e0c0648d8c85">&#9670;&#160;</a></span>ly_ctx_get_submodule_latest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysp__submodule">lysp_submodule</a> * ly_ctx_get_submodule_latest </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>submodule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the latests revision of a submodule from context. If its belongs-to module is known, use <a class="el" href="#ga911278e5a9e0fbeeb71d99e34954f4f5" title="Get the latest revision of a submodule from a module. If the belongs-to module is not known,...">ly_ctx_get_submodule2_latest()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submodule</td><td>Submodule name to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found submodule, NULL if there is none. </dd></dl>

</div>
</div>
<a id="ga34a07a3afcc26cd0615e629924179945" name="ga34a07a3afcc26cd0615e629924179945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a07a3afcc26cd0615e629924179945">&#9670;&#160;</a></span>ly_ctx_get_yanglib_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_get_yanglib_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>content_id_format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get data of the internal ietf-yang-library module with information about all the loaded modules. ietf-yang-library module must be loaded. </p>
<p>Note that "/ietf-yang-library:yang-library/datastore" list instances are not created and should be appended by the caller. There is a single "/ietf-yang-library:yang-library/schema" instance created with the key value "complete".</p>
<p>If the data identifier can be limited to the existence and changes of this context, the following last 2 parameters can be used:</p>
<p>"%u" as <code>content_id_format</code> and <a class="el" href="#gaecfb3bae1347b1ff07ee3b3e55e96dac" title="Get the change count of the context (module set) during its life-time.">ly_ctx_get_change_count()</a> as its parameter; "%u" as <code>content_id_format</code> and <a class="el" href="#ga35f19af25468b1507aa5da5101000c59" title="Get the hash of all the modules in the context. Since order of the modules is significant,...">ly_ctx_get_modules_hash()</a> as its parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context with the modules. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">root</td><td>Generated yang-library data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">content_id_format</td><td>Format string (printf-like) for the yang-library data identifier, which is the "content_id" node in the 2019-01-04 revision of ietf-yang-library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Parameters for <code>content_id_format</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value </dd></dl>

</div>
</div>
<a id="ga50e9bb7dd7f70dff6e00f821f2b40969" name="ga50e9bb7dd7f70dff6e00f821f2b40969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e9bb7dd7f70dff6e00f821f2b40969">&#9670;&#160;</a></span>ly_ctx_internal_modules_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL uint32_t ly_ctx_internal_modules_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn the number of internal modules of a context. Internal modules is considered one that was loaded during the context creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of internal modules. </dd></dl>

</div>
</div>
<a id="gab2a4fb33c996e06ce3dde4f578905c87" name="gab2a4fb33c996e06ce3dde4f578905c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a4fb33c996e06ce3dde4f578905c87">&#9670;&#160;</a></span>ly_ctx_load_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * ly_ctx_load_module </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>revision</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find the model in the searchpaths of <code>ctx</code> and load it into it. If custom missing module callback is set, it is used instead. </p>
<p>The context itself is searched for the requested module first. If <code>revision</code> is not specified (the module of the latest revision is requested) and there is implemented revision of the requested module in the context, this implemented revision is returned despite there might be a newer revision. This behavior is cause by the fact that it is not possible to have multiple implemented revisions of the same module in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the module to load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revision</td><td>Optional revision date of the module. If not specified, the latest revision is loaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Optional array of features ended with NULL to be enabled if the module is being implemented. The feature string '*' enables all and array of length 1 with only the terminating NULL explicitly disables all the features. In case the parameter is NULL, the features are untouched - left disabled in newly loaded module or with the current features settings in case the module is already present in the context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data model structure, NULL if not found or some error occurred. </dd></dl>

</div>
</div>
<a id="ga16a2bdf484be8dd3657a141d2cc0500e" name="ga16a2bdf484be8dd3657a141d2cc0500e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a2bdf484be8dd3657a141d2cc0500e">&#9670;&#160;</a></span>ly_ctx_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_new </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> **</td>          <td class="paramname"><span class="paramname"><em>new_ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create libyang context. </p>
<p>Context is used to hold all information about schemas. Usually, the application is supposed to work with a single context in which libyang is holding all schemas (and other internal information) according to which the data trees will be processed and validated. So, the schema trees are tightly connected with the specific context and they are held by the context internally</p><ul>
<li>caller does not need to keep pointers to the schemas returned by <a class="el" href="group__schematree.html#ga00aca91d599c3cda36e58c3e0f280a31" title="Load a schema into the specified context.">lys_parse()</a>, context knows about them. The data trees created with <b>lyd_parse_*</b>() are still connected with the specific context, but they are not internally held by the context. The data tree just points and lean on some data held by the context (schema tree, string dictionary, etc.). Therefore, in case of data trees, caller is supposed to keep pointers returned by the <b>lyd_parse_*</b>() functions and manage the data tree on its own. This also affects the number of instances of both tree types. While you can have only one instance of specific schema connected with a single context, number of data tree instances is not connected.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">search_dir</td><td>Directory (or directories) where libyang will search for the imported or included modules and submodules. If no such directory is available, NULL is accepted. Several directories can be specified, delimited by colon ":" (on Windows, use semicolon ";" instead). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Context options, see <a class="el" href="group__contextoptions.html">Context options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_ctx</td><td>Pointer to the created libyang context if LY_SUCCESS returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value. </dd></dl>

</div>
</div>
<a id="ga916d69eee34fa948012658297155f2ed" name="ga916d69eee34fa948012658297155f2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga916d69eee34fa948012658297155f2ed">&#9670;&#160;</a></span>ly_ctx_new_yldata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_new_yldata </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="tree__data_8h.html#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> **</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create libyang context according to the provided yang-library data in a data tree. </p>
<p>Details in <a class="el" href="#gafea2062363df5d00927ef36ccbeae7bd" title="Create libyang context according to the provided yang-library data in a file.">ly_ctx_new_ylpath()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">search_dir</td><td>Directory where libyang will search for the imported or included modules and submodules. If no such directory is available, NULL is accepted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree containing yang-library data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Context options, see <a class="el" href="group__contextoptions.html">Context options</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>If *ctx is not NULL, the existing libyang context is modified. Otherwise, a pointer to a newly created context is returned here if LY_SUCCESS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value </dd></dl>

</div>
</div>
<a id="ga7e904e97a3c621c0691dae664b5b3e52" name="ga7e904e97a3c621c0691dae664b5b3e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e904e97a3c621c0691dae664b5b3e52">&#9670;&#160;</a></span>ly_ctx_new_ylmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_new_ylmem </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">LYD_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> **</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create libyang context according to the provided yang-library data in a string. </p>
<p>Details in <a class="el" href="#gafea2062363df5d00927ef36ccbeae7bd" title="Create libyang context according to the provided yang-library data in a file.">ly_ctx_new_ylpath()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">search_dir</td><td>Directory where libyang will search for the imported or included modules and submodules. If no such directory is available, NULL is accepted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>String containing yang-library data in the specified format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the data in the provided file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Context options, see <a class="el" href="group__contextoptions.html">Context options</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>If *ctx is not NULL, the existing libyang context is modified. Otherwise, a pointer to a newly created context is returned here if LY_SUCCESS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value </dd></dl>

</div>
</div>
<a id="gafea2062363df5d00927ef36ccbeae7bd" name="gafea2062363df5d00927ef36ccbeae7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafea2062363df5d00927ef36ccbeae7bd">&#9670;&#160;</a></span>ly_ctx_new_ylpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_new_ylpath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">LYD_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> **</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create libyang context according to the provided yang-library data in a file. </p>
<p>This function loads the yang-library data from the given path. If you need to pass the data as string, use ::<a class="el" href="#ga7e904e97a3c621c0691dae664b5b3e52" title="Create libyang context according to the provided yang-library data in a string.">ly_ctx_new_ylmem()</a>. Both functions extend functionality of <a class="el" href="#ga16a2bdf484be8dd3657a141d2cc0500e" title="Create libyang context.">ly_ctx_new()</a> by loading modules specified in the ietf-yang-library form into the context being created. The preferred tree model revision is 2019-01-04. However, only the first module-set is processed and loaded into the context. If there are no matching nodes from this tree, the legacy tree (originally from model revision 2016-04-09) is processed. Note, that the modules are loaded the same way as in case of <a class="el" href="#gab2a4fb33c996e06ce3dde4f578905c87" title="Try to find the model in the searchpaths of ctx and load it into it. If custom missing module callbac...">ly_ctx_load_module()</a>, so the schema paths in the yang-library data are ignored and the modules are loaded from the context's search locations. On the other hand, YANG features of the modules are set as specified in the yang-library data. To get yang library data from a libyang context, use <a class="el" href="#ga34a07a3afcc26cd0615e629924179945" title="Get data of the internal ietf-yang-library module with information about all the loaded modules....">ly_ctx_get_yanglib_data()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">search_dir</td><td>Directory where libyang will search for the imported or included modules and submodules. If no such directory is available, NULL is accepted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the file containing yang-library-data in the specified format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of the data in the provided file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Context options, see <a class="el" href="group__contextoptions.html">Context options</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>If *ctx is not NULL, the existing libyang context is modified. Otherwise, a pointer to a newly created context is returned here if LY_SUCCESS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value </dd></dl>

</div>
</div>
<a id="ga969426519ea501704daf6019ec934de5" name="ga969426519ea501704daf6019ec934de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga969426519ea501704daf6019ec934de5">&#9670;&#160;</a></span>ly_ctx_reset_latests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void ly_ctx_reset_latests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset cached latest revision information of the schemas in the context. </p>
<p>This function is deprecated and should not be used.</p>
<p>When a (sub)module is imported/included without revision, the latest revision is searched. libyang searches for the latest revision in searchdirs and/or via provided import callback <a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10" title="Callback for retrieving missing included or imported models in a custom way.">ly_module_imp_clb()</a> just once. Then it is expected that the content of searchdirs or data returned by the callback does not change. So when it changes, it is necessary to force searching for the latest revision in case of loading another module, which what this function does.</p>
<p>The latest revision information is also reset when the searchdirs set changes via <a class="el" href="#ga779252a9f7d23e09c2ceade107c3578f" title="Add the search path into libyang context.">ly_ctx_set_searchdir()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context where the latest revision information is going to be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14853fe1a338c94d9e81be9566438243" name="ga14853fe1a338c94d9e81be9566438243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14853fe1a338c94d9e81be9566438243">&#9670;&#160;</a></span>ly_ctx_set_ext_data_clb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="#ga5513a90fe7a64af7ec5217e6fd8af187">ly_ext_data_clb</a> ly_ctx_set_ext_data_clb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga5513a90fe7a64af7ec5217e6fd8af187">ly_ext_data_clb</a></td>          <td class="paramname"><span class="paramname"><em>clb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback providing run-time extension instance data. The expected data depend on the extension. Data expected by internal extensions: </p>
<ul>
<li><em>ietf-yang-schema-mount:mount-point</em> (struct <a class="el" href="tree__data_8h.html#structlyd__node" title="Generic structure for a data node.">lyd_node</a> **ext_data)<br  />
Operational data tree with at least <code>ietf-yang-library</code> data describing the mounted schema and <code>ietf-yang-schema-mount</code> <b>validated</b> data describing the specific mount point (<a href="https://datatracker.ietf.org/doc/html/rfc8528#section-3.3">ref</a>).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context that will use this callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clb</td><td>Callback responsible for returning the extension instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Arbitrary data that will always be passed to the callback <code>clb</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga704db60ea84aa35b1a54a77908949388" name="ga704db60ea84aa35b1a54a77908949388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga704db60ea84aa35b1a54a77908949388">&#9670;&#160;</a></span>ly_ctx_set_module_imp_clb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void ly_ctx_set_module_imp_clb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga2a077cfc7d38cc086c1f3b5e45e71e10">ly_module_imp_clb</a></td>          <td class="paramname"><span class="paramname"><em>clb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set missing include or import module callback. It is meant to be used when the models are not locally available (such as when downloading modules from a NETCONF server), it should not be required in other cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context that will use this callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clb</td><td>Callback responsible for returning the missing model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Arbitrary data that will always be passed to the callback <code>clb</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1891df928268ec799f11435d80a32e42" name="ga1891df928268ec799f11435d80a32e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1891df928268ec799f11435d80a32e42">&#9670;&#160;</a></span>ly_ctx_set_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_set_options </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set some of the context's options, see <a class="el" href="group__contextoptions.html">Context options</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Combination of the context's options to be set, see <a class="el" href="group__contextoptions.html">Context options</a>. If there is to be a change to <a class="el" href="group__contextoptions.html#ga7883206423631283065208634d57e056">LY_CTX_SET_PRIV_PARSED</a>, the context will be recompiled and all <a class="el" href="group__schematree.html#a83d1dfdd6dc1c916094f62ec96213998">lysc_node.priv</a> in the modules will be overwritten, see <a class="el" href="group__contextoptions.html#ga7883206423631283065208634d57e056">LY_CTX_SET_PRIV_PARSED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ga779252a9f7d23e09c2ceade107c3578f" name="ga779252a9f7d23e09c2ceade107c3578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga779252a9f7d23e09c2ceade107c3578f">&#9670;&#160;</a></span>ly_ctx_set_searchdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_set_searchdir </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search_dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the search path into libyang context. </p>
<p>To reset search paths set in the context, use <a class="el" href="#ga0fdeb55ccad44d3b4b78bb116959c9d4" title="Clean the search path(s) from the libyang context.">ly_ctx_unset_searchdir()</a> and then set search paths again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">search_dir</td><td>New search path to add to the current paths previously set in ctx. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value. </dd></dl>

</div>
</div>
<a id="ga542b84c9cdcf7f397259d7178ee38b7c" name="ga542b84c9cdcf7f397259d7178ee38b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542b84c9cdcf7f397259d7178ee38b7c">&#9670;&#160;</a></span>ly_ctx_unset_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_unset_options </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset some of the context's options, see <a class="el" href="group__contextoptions.html">Context options</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Combination of the context's options to be unset, see <a class="el" href="group__contextoptions.html">Context options</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ga0fdeb55ccad44d3b4b78bb116959c9d4" name="ga0fdeb55ccad44d3b4b78bb116959c9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fdeb55ccad44d3b4b78bb116959c9d4">&#9670;&#160;</a></span>ly_ctx_unset_searchdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_unset_searchdir </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean the search path(s) from the libyang context. </p>
<p>To remove the recently added search path(s), use <a class="el" href="#ga847a60f97cd514dd755d0b2e4e6d54c8" title="Remove the least recently added search path(s) from the libyang context.">ly_ctx_unset_searchdir_last()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Searchdir to be removed, use NULL to remove them all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value </dd></dl>

</div>
</div>
<a id="ga847a60f97cd514dd755d0b2e4e6d54c8" name="ga847a60f97cd514dd755d0b2e4e6d54c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847a60f97cd514dd755d0b2e4e6d54c8">&#9670;&#160;</a></span>ly_ctx_unset_searchdir_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_ctx_unset_searchdir_last </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the least recently added search path(s) from the libyang context. </p>
<p>To remove a specific search path by its value, use <a class="el" href="#ga0fdeb55ccad44d3b4b78bb116959c9d4" title="Clean the search path(s) from the libyang context.">ly_ctx_unset_searchdir()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of the searchdirs to be removed (starting by the least recently added). If the value is higher then the actual number of search paths, all paths are removed and no error is returned. Value 0 does not change the search path set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR return value </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 28 2025 10:44:39 for libyang by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
