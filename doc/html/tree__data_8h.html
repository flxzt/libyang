<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libyang: src/tree_data.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libyang<span id="projectnumber">&#160;2.1.148</span>
   </div>
   <div id="projectbrief">libyang is YANG data modelling language parser and toolkit written (and providing API) in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tree__data_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tree_data.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>libyang representation of YANG data trees.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_8h_source.html">tree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree__schema_8h_source.html">tree_schema.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for tree_data.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="tree__data_8h__incl.svg" width="100%" height="490"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="tree__data_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div>
<p><a href="tree__data_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structly__opaq__name" id="r_structly__opaq__name"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structly__opaq__name">ly_opaq_name</a></td></tr>
<tr class="memdesc:structly__opaq__name"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic prefix and namespace mapping, meaning depends on the format.  <a href="#structly__opaq__name">More...</a><br /></td></tr>
<tr class="separator:structly__opaq__name"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionly__opaq__name_8____unnamed5____" id="r_unionly__opaq__name_8____unnamed5____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionly__opaq__name_8____unnamed5____">ly_opaq_name.__unnamed5__</a></td></tr>
<tr class="separator:unionly__opaq__name_8____unnamed5____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__any__value" id="r_unionlyd__any__value"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__any__value">lyd_any_value</a></td></tr>
<tr class="memdesc:unionlyd__any__value"><td class="mdescLeft">&#160;</td><td class="mdescRight">union for anydata/anyxml value representation.  <a href="#unionlyd__any__value">More...</a><br /></td></tr>
<tr class="separator:unionlyd__any__value"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__attr" id="r_structlyd__attr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__attr">lyd_attr</a></td></tr>
<tr class="memdesc:structlyd__attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic attribute structure.  <a href="#structlyd__attr">More...</a><br /></td></tr>
<tr class="separator:structlyd__attr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node" id="r_structlyd__node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node">lyd_node</a></td></tr>
<tr class="memdesc:structlyd__node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic structure for a data node.  <a href="#structlyd__node">More...</a><br /></td></tr>
<tr class="separator:structlyd__node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__any" id="r_structlyd__node__any"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__any">lyd_node_any</a></td></tr>
<tr class="memdesc:structlyd__node__any"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data node structure for the anydata data tree nodes - anydata or anyxml.  <a href="#structlyd__node__any">More...</a><br /></td></tr>
<tr class="separator:structlyd__node__any"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__node__any_8____unnamed15____" id="r_unionlyd__node__any_8____unnamed15____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__node__any_8____unnamed15____">lyd_node_any.__unnamed15__</a></td></tr>
<tr class="separator:unionlyd__node__any_8____unnamed15____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__any_8____unnamed15_____8____unnamed17____" id="r_structlyd__node__any_8____unnamed15_____8____unnamed17____"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__any_8____unnamed15_____8____unnamed17____">lyd_node_any.__unnamed15__.__unnamed17__</a></td></tr>
<tr class="separator:structlyd__node__any_8____unnamed15_____8____unnamed17____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__inner" id="r_structlyd__node__inner"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__inner">lyd_node_inner</a></td></tr>
<tr class="memdesc:structlyd__node__inner"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data node structure for the inner data tree nodes - containers, lists, RPCs, actions and Notifications.  <a href="#structlyd__node__inner">More...</a><br /></td></tr>
<tr class="separator:structlyd__node__inner"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__node__inner_8____unnamed7____" id="r_unionlyd__node__inner_8____unnamed7____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__node__inner_8____unnamed7____">lyd_node_inner.__unnamed7__</a></td></tr>
<tr class="separator:unionlyd__node__inner_8____unnamed7____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__inner_8____unnamed7_____8____unnamed9____" id="r_structlyd__node__inner_8____unnamed7_____8____unnamed9____"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__inner_8____unnamed7_____8____unnamed9____">lyd_node_inner.__unnamed7__.__unnamed9__</a></td></tr>
<tr class="separator:structlyd__node__inner_8____unnamed7_____8____unnamed9____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__opaq" id="r_structlyd__node__opaq"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__opaq">lyd_node_opaq</a></td></tr>
<tr class="memdesc:structlyd__node__opaq"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data node structure for unparsed (opaque) nodes.  <a href="#structlyd__node__opaq">More...</a><br /></td></tr>
<tr class="separator:structlyd__node__opaq"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__node__opaq_8____unnamed19____" id="r_unionlyd__node__opaq_8____unnamed19____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__node__opaq_8____unnamed19____">lyd_node_opaq.__unnamed19__</a></td></tr>
<tr class="separator:unionlyd__node__opaq_8____unnamed19____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__opaq_8____unnamed19_____8____unnamed21____" id="r_structlyd__node__opaq_8____unnamed19_____8____unnamed21____"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__opaq_8____unnamed19_____8____unnamed21____">lyd_node_opaq.__unnamed19__.__unnamed21__</a></td></tr>
<tr class="separator:structlyd__node__opaq_8____unnamed19_____8____unnamed21____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__term" id="r_structlyd__node__term"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__term">lyd_node_term</a></td></tr>
<tr class="memdesc:structlyd__node__term"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data node structure for the terminal data tree nodes - leaves and leaf-lists.  <a href="#structlyd__node__term">More...</a><br /></td></tr>
<tr class="separator:structlyd__node__term"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__node__term_8____unnamed11____" id="r_unionlyd__node__term_8____unnamed11____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__node__term_8____unnamed11____">lyd_node_term.__unnamed11__</a></td></tr>
<tr class="separator:unionlyd__node__term_8____unnamed11____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__node__term_8____unnamed11_____8____unnamed13____" id="r_structlyd__node__term_8____unnamed11_____8____unnamed13____"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__node__term_8____unnamed11_____8____unnamed13____">lyd_node_term.__unnamed11__.__unnamed13__</a></td></tr>
<tr class="separator:structlyd__node__term_8____unnamed11_____8____unnamed13____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value" id="r_structlyd__value"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value">lyd_value</a></td></tr>
<tr class="memdesc:structlyd__value"><td class="mdescLeft">&#160;</td><td class="mdescRight">YANG data representation.  <a href="#structlyd__value">More...</a><br /></td></tr>
<tr class="separator:structlyd__value"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionlyd__value_8____unnamed3____" id="r_unionlyd__value_8____unnamed3____"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#unionlyd__value_8____unnamed3____">lyd_value.__unnamed3__</a></td></tr>
<tr class="separator:unionlyd__value_8____unnamed3____"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__binary" id="r_structlyd__value__binary"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__binary">lyd_value_binary</a></td></tr>
<tr class="memdesc:structlyd__value__binary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in binary values.  <a href="#structlyd__value__binary">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__binary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__bits" id="r_structlyd__value__bits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__bits">lyd_value_bits</a></td></tr>
<tr class="memdesc:structlyd__value__bits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in bits values.  <a href="#structlyd__value__bits">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__bits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__date__and__time" id="r_structlyd__value__date__and__time"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__date__and__time">lyd_value_date_and_time</a></td></tr>
<tr class="memdesc:structlyd__value__date__and__time"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-yang-types date-and-time values.  <a href="#structlyd__value__date__and__time">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__date__and__time"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv4__address" id="r_structlyd__value__ipv4__address"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv4__address">lyd_value_ipv4_address</a></td></tr>
<tr class="memdesc:structlyd__value__ipv4__address"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-address values.  <a href="#structlyd__value__ipv4__address">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv4__address"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv4__address__no__zone" id="r_structlyd__value__ipv4__address__no__zone"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv4__address__no__zone">lyd_value_ipv4_address_no_zone</a></td></tr>
<tr class="memdesc:structlyd__value__ipv4__address__no__zone"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-address-no-zone values.  <a href="#structlyd__value__ipv4__address__no__zone">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv4__address__no__zone"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv4__prefix" id="r_structlyd__value__ipv4__prefix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv4__prefix">lyd_value_ipv4_prefix</a></td></tr>
<tr class="memdesc:structlyd__value__ipv4__prefix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-prefix values.  <a href="#structlyd__value__ipv4__prefix">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv4__prefix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv6__address" id="r_structlyd__value__ipv6__address"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv6__address">lyd_value_ipv6_address</a></td></tr>
<tr class="memdesc:structlyd__value__ipv6__address"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-address values.  <a href="#structlyd__value__ipv6__address">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv6__address"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv6__address__no__zone" id="r_structlyd__value__ipv6__address__no__zone"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv6__address__no__zone">lyd_value_ipv6_address_no_zone</a></td></tr>
<tr class="memdesc:structlyd__value__ipv6__address__no__zone"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-address-no-zone values.  <a href="#structlyd__value__ipv6__address__no__zone">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv6__address__no__zone"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__ipv6__prefix" id="r_structlyd__value__ipv6__prefix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__ipv6__prefix">lyd_value_ipv6_prefix</a></td></tr>
<tr class="memdesc:structlyd__value__ipv6__prefix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-prefix values.  <a href="#structlyd__value__ipv6__prefix">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__ipv6__prefix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__union" id="r_structlyd__value__union"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__union">lyd_value_union</a></td></tr>
<tr class="memdesc:structlyd__value__union"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in union values.  <a href="#structlyd__value__union">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__union"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structlyd__value__xpath10" id="r_structlyd__value__xpath10"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structlyd__value__xpath10">lyd_value_xpath10</a></td></tr>
<tr class="memdesc:structlyd__value__xpath10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-yang-types xpath1.0 values.  <a href="#structlyd__value__xpath10">More...</a><br /></td></tr>
<tr class="separator:structlyd__value__xpath10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac45cf919417be4337983781a9e28c6d7" id="r_gac45cf919417be4337983781a9e28c6d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datacompareoptions.html#gac45cf919417be4337983781a9e28c6d7">LYD_COMPARE_DEFAULTS</a></td></tr>
<tr class="separator:gac45cf919417be4337983781a9e28c6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e826d7185a1b2287415539141df1e6c" id="r_ga4e826d7185a1b2287415539141df1e6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datacompareoptions.html#ga4e826d7185a1b2287415539141df1e6c">LYD_COMPARE_FULL_RECURSION</a></td></tr>
<tr class="separator:ga4e826d7185a1b2287415539141df1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12539b3a04d55520c7a30bd4c6eea4ee" id="r_ga12539b3a04d55520c7a30bd4c6eea4ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datacompareoptions.html#ga12539b3a04d55520c7a30bd4c6eea4ee">LYD_COMPARE_OPAQ</a></td></tr>
<tr class="separator:ga12539b3a04d55520c7a30bd4c6eea4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe537ecfc0d86f208f20e174218005d0" id="r_gabe537ecfc0d86f208f20e174218005d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#gabe537ecfc0d86f208f20e174218005d0">LYD_CTX</a>(node)</td></tr>
<tr class="memdesc:gabe537ecfc0d86f208f20e174218005d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get context from a data tree node.  <br /></td></tr>
<tr class="separator:gabe537ecfc0d86f208f20e174218005d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e88553c51cc3cf061635ddd8a2ea854" id="r_ga7e88553c51cc3cf061635ddd8a2ea854"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dnodeflags.html#ga7e88553c51cc3cf061635ddd8a2ea854">LYD_DEFAULT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga7e88553c51cc3cf061635ddd8a2ea854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12953afb61d1d12e0c288996a0f9f8ab" id="r_ga12953afb61d1d12e0c288996a0f9f8ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diffoptions.html#ga12953afb61d1d12e0c288996a0f9f8ab">LYD_DIFF_DEFAULTS</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga12953afb61d1d12e0c288996a0f9f8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1422e26abd770705eb6c8f1417e21f93" id="r_ga1422e26abd770705eb6c8f1417e21f93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diffmergeoptions.html#ga1422e26abd770705eb6c8f1417e21f93">LYD_DIFF_MERGE_DEFAULTS</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga1422e26abd770705eb6c8f1417e21f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9b62a856c112c63778d2ec2fe493cd" id="r_gaac9b62a856c112c63778d2ec2fe493cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#gaac9b62a856c112c63778d2ec2fe493cd">LYD_DUP_NO_EXT</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gaac9b62a856c112c63778d2ec2fe493cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a16ac6a000f07a811b56d9c73dcc37b" id="r_ga7a16ac6a000f07a811b56d9c73dcc37b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#ga7a16ac6a000f07a811b56d9c73dcc37b">LYD_DUP_NO_META</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga7a16ac6a000f07a811b56d9c73dcc37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3746f495e90aceb0d26830c836af6ea0" id="r_ga3746f495e90aceb0d26830c836af6ea0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#ga3746f495e90aceb0d26830c836af6ea0">LYD_DUP_RECURSIVE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga3746f495e90aceb0d26830c836af6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2692c61732a96135ab0e066a1628dfe6" id="r_ga2692c61732a96135ab0e066a1628dfe6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#ga2692c61732a96135ab0e066a1628dfe6">LYD_DUP_WITH_FLAGS</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga2692c61732a96135ab0e066a1628dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae511a2567f88b7c42be7a5d87631efc9" id="r_gae511a2567f88b7c42be7a5d87631efc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gae511a2567f88b7c42be7a5d87631efc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077fb17c48ba4590763291f06bf40975" id="r_ga077fb17c48ba4590763291f06bf40975"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dupoptions.html#ga077fb17c48ba4590763291f06bf40975">LYD_DUP_WITH_PRIV</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga077fb17c48ba4590763291f06bf40975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bdf30e8fbe3c39804b353764d11258" id="r_ga91bdf30e8fbe3c39804b353764d11258"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dnodeflags.html#ga91bdf30e8fbe3c39804b353764d11258">LYD_EXT</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga91bdf30e8fbe3c39804b353764d11258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2a64e38755dbf3735f22e8fb0aaa2a" id="r_ga8a2a64e38755dbf3735f22e8fb0aaa2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydhints.html#ga8a2a64e38755dbf3735f22e8fb0aaa2a">LYD_HINT_DATA</a>&#160;&#160;&#160;0x01F3</td></tr>
<tr class="separator:ga8a2a64e38755dbf3735f22e8fb0aaa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33547c11421a9a4279c8d6a86e3d8230" id="r_ga33547c11421a9a4279c8d6a86e3d8230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydhints.html#ga33547c11421a9a4279c8d6a86e3d8230">LYD_HINT_SCHEMA</a>&#160;&#160;&#160;0x01FF</td></tr>
<tr class="separator:ga33547c11421a9a4279c8d6a86e3d8230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070b9868e6e347825d45e73883f3b2b1" id="r_a070b9868e6e347825d45e73883f3b2b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070b9868e6e347825d45e73883f3b2b1">LYD_HT_MIN_ITEMS</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a070b9868e6e347825d45e73883f3b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185db2e190da3606f9bf1e2ae0c16ad0" id="r_ga185db2e190da3606f9bf1e2ae0c16ad0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__implicitoptions.html#ga185db2e190da3606f9bf1e2ae0c16ad0">LYD_IMPLICIT_NO_CONFIG</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga185db2e190da3606f9bf1e2ae0c16ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9800dd887e5fbdbc81190196bb42c050" id="r_ga9800dd887e5fbdbc81190196bb42c050"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__implicitoptions.html#ga9800dd887e5fbdbc81190196bb42c050">LYD_IMPLICIT_NO_DEFAULTS</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga9800dd887e5fbdbc81190196bb42c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44addc8567342eae1d7e604384beee6d" id="r_ga44addc8567342eae1d7e604384beee6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__implicitoptions.html#ga44addc8567342eae1d7e604384beee6d">LYD_IMPLICIT_NO_STATE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga44addc8567342eae1d7e604384beee6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff5bfae822b1568c59c938890c81a79" id="r_ga9ff5bfae822b1568c59c938890c81a79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__implicitoptions.html#ga9ff5bfae822b1568c59c938890c81a79">LYD_IMPLICIT_OUTPUT</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga9ff5bfae822b1568c59c938890c81a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c5dbacbba63e098be25c307ee7393da" id="r_ga0c5dbacbba63e098be25c307ee7393da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga0c5dbacbba63e098be25c307ee7393da">LYD_LIST_FOR_INST</a>(START,  SCHEMA,  ELEM)</td></tr>
<tr class="memdesc:ga0c5dbacbba63e098be25c307ee7393da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to iterate via all schema node data instances in data siblings.  <br /></td></tr>
<tr class="separator:ga0c5dbacbba63e098be25c307ee7393da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7142cb5c71b8d23f0d1f62e3b5193338" id="r_ga7142cb5c71b8d23f0d1f62e3b5193338"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga7142cb5c71b8d23f0d1f62e3b5193338">LYD_LIST_FOR_INST_SAFE</a>(START,  SCHEMA,  NEXT,  ELEM)</td></tr>
<tr class="memdesc:ga7142cb5c71b8d23f0d1f62e3b5193338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to iterate via all schema node data instances in data siblings allowing to modify the list itself.  <br /></td></tr>
<tr class="separator:ga7142cb5c71b8d23f0d1f62e3b5193338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9338f3a7434f3c37d368e047eeda064a" id="r_ga9338f3a7434f3c37d368e047eeda064a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mergeoptions.html#ga9338f3a7434f3c37d368e047eeda064a">LYD_MERGE_DEFAULTS</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga9338f3a7434f3c37d368e047eeda064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c06de7b13f5fbf866673d48702ade5" id="r_ga00c06de7b13f5fbf866673d48702ade5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mergeoptions.html#ga00c06de7b13f5fbf866673d48702ade5">LYD_MERGE_DESTRUCT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga00c06de7b13f5fbf866673d48702ade5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb13592555adaf59e42a1a6dfeacd55f" id="r_gafb13592555adaf59e42a1a6dfeacd55f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mergeoptions.html#gafb13592555adaf59e42a1a6dfeacd55f">LYD_MERGE_WITH_FLAGS</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gafb13592555adaf59e42a1a6dfeacd55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab155e70f45a64e20ca1270ee92cb5240" id="r_ab155e70f45a64e20ca1270ee92cb5240"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab155e70f45a64e20ca1270ee92cb5240">LYD_NAME</a>(node)</td></tr>
<tr class="memdesc:ab155e70f45a64e20ca1270ee92cb5240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name (associated with) of a data node. Works for opaque nodes as well.  <br /></td></tr>
<tr class="separator:ab155e70f45a64e20ca1270ee92cb5240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa781e93269efd5456e249e4132e7eab" id="r_gafa781e93269efd5456e249e4132e7eab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dnodeflags.html#gafa781e93269efd5456e249e4132e7eab">LYD_NEW</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gafa781e93269efd5456e249e4132e7eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0761bb5c77e4a7b9faa3063ec59a6a30" id="r_ga0761bb5c77e4a7b9faa3063ec59a6a30"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#ga0761bb5c77e4a7b9faa3063ec59a6a30">LYD_NEW_PATH_BIN_VALUE</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga0761bb5c77e4a7b9faa3063ec59a6a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697bb18326e902505279993aa90fb88e" id="r_ga697bb18326e902505279993aa90fb88e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#ga697bb18326e902505279993aa90fb88e">LYD_NEW_PATH_CANON_VALUE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:ga697bb18326e902505279993aa90fb88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34992242f70b3517145ffecb84418d9f" id="r_ga34992242f70b3517145ffecb84418d9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#ga34992242f70b3517145ffecb84418d9f">LYD_NEW_PATH_OPAQ</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga34992242f70b3517145ffecb84418d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb10930a36a31acd78f2ad25052ff8bd" id="r_gadb10930a36a31acd78f2ad25052ff8bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#gadb10930a36a31acd78f2ad25052ff8bd">LYD_NEW_PATH_OUTPUT</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gadb10930a36a31acd78f2ad25052ff8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf815de8dda9ad51591d6e4ae79f0606e" id="r_gaf815de8dda9ad51591d6e4ae79f0606e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#gaf815de8dda9ad51591d6e4ae79f0606e">LYD_NEW_PATH_UPDATE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gaf815de8dda9ad51591d6e4ae79f0606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd7ab4b9257a8e8680182c2ef8da4ea6" id="r_gadd7ab4b9257a8e8680182c2ef8da4ea6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pathoptions.html#gadd7ab4b9257a8e8680182c2ef8da4ea6">LYD_NEW_PATH_WITH_OPAQ</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:gadd7ab4b9257a8e8680182c2ef8da4ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cb5d2c5eba0e721c356d521126395b" id="r_ac5cb5d2c5eba0e721c356d521126395b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5cb5d2c5eba0e721c356d521126395b">LYD_NODE_ANY</a>&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga305ca15bb0627f6b0b0c411fd9979b61">LYS_ANYDATA</a>)</td></tr>
<tr class="separator:ac5cb5d2c5eba0e721c356d521126395b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab43155f05102a20b819651b543a59e" id="r_abab43155f05102a20b819651b543a59e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab43155f05102a20b819651b543a59e">LYD_NODE_INNER</a>&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga8af68db17d734a8fd08fe765eef5937a">LYS_CONTAINER</a>|<a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>|<a class="el" href="group__schemanodetypes.html#ga4e0d212f3fe9cb3cfb27ce8709d82048">LYS_RPC</a>|<a class="el" href="group__schemanodetypes.html#gac0aff1ca4e3a03895df2c2d0f9c22a1a">LYS_ACTION</a>|<a class="el" href="group__schemanodetypes.html#ga236b4e81a1488cc5943aa43c6faacd51">LYS_NOTIF</a>)</td></tr>
<tr class="separator:abab43155f05102a20b819651b543a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f41da26d9b46168dcf9ee0b8c04ff03" id="r_a8f41da26d9b46168dcf9ee0b8c04ff03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f41da26d9b46168dcf9ee0b8c04ff03">LYD_NODE_TERM</a>&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a>|<a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>)</td></tr>
<tr class="separator:a8f41da26d9b46168dcf9ee0b8c04ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf30eaa897575bc2d03459042d1eee57" id="r_gadf30eaa897575bc2d03459042d1eee57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydnodehints.html#gadf30eaa897575bc2d03459042d1eee57">LYD_NODEHINT_LEAFLIST</a>&#160;&#160;&#160;0x0100</td></tr>
<tr class="separator:gadf30eaa897575bc2d03459042d1eee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b57491153866771c7bda846ebb13aec" id="r_ga2b57491153866771c7bda846ebb13aec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydnodehints.html#ga2b57491153866771c7bda846ebb13aec">LYD_NODEHINT_LIST</a>&#160;&#160;&#160;0x0080</td></tr>
<tr class="separator:ga2b57491153866771c7bda846ebb13aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a918f950bd4de092fb4ef8d92fcdbfd" id="r_ga9a918f950bd4de092fb4ef8d92fcdbfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga9a918f950bd4de092fb4ef8d92fcdbfd">LYD_TREE_DFS_BEGIN</a>(START,  ELEM)</td></tr>
<tr class="memdesc:ga9a918f950bd4de092fb4ef8d92fcdbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to iterate via all elements in a data tree. This is the opening part to the <a class="el" href="group__datatree.html#ga903709cf7c9479ed051fada71d212cef" title="Macro to iterate via all elements in a tree. This is the closing part to the LYD_TREE_DFS_BEGIN - the...">LYD_TREE_DFS_END</a> - they always have to be used together.  <br /></td></tr>
<tr class="separator:ga9a918f950bd4de092fb4ef8d92fcdbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903709cf7c9479ed051fada71d212cef" id="r_ga903709cf7c9479ed051fada71d212cef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga903709cf7c9479ed051fada71d212cef">LYD_TREE_DFS_END</a>(START,  ELEM)</td></tr>
<tr class="memdesc:ga903709cf7c9479ed051fada71d212cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to iterate via all elements in a tree. This is the closing part to the <a class="el" href="group__datatree.html#ga9a918f950bd4de092fb4ef8d92fcdbfd" title="Macro to iterate via all elements in a data tree. This is the opening part to the LYD_TREE_DFS_END - ...">LYD_TREE_DFS_BEGIN</a> - they always have to be used together.  <br /></td></tr>
<tr class="separator:ga903709cf7c9479ed051fada71d212cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a92800a96e4f57a65bb2c17e0288ca" id="r_ga39a92800a96e4f57a65bb2c17e0288ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#ga39a92800a96e4f57a65bb2c17e0288ca">LYD_VALHINT_BOOLEAN</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="separator:ga39a92800a96e4f57a65bb2c17e0288ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5b0c409eb3090e91bd32cf18ee57ce" id="r_ga5f5b0c409eb3090e91bd32cf18ee57ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#ga5f5b0c409eb3090e91bd32cf18ee57ce">LYD_VALHINT_DECNUM</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:ga5f5b0c409eb3090e91bd32cf18ee57ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec75a9d5a438a51d7073cf326757677" id="r_gaaec75a9d5a438a51d7073cf326757677"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#gaaec75a9d5a438a51d7073cf326757677">LYD_VALHINT_EMPTY</a>&#160;&#160;&#160;0x0040</td></tr>
<tr class="separator:gaaec75a9d5a438a51d7073cf326757677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37f27af52b2efed3ff6e448d96461c58" id="r_ga37f27af52b2efed3ff6e448d96461c58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#ga37f27af52b2efed3ff6e448d96461c58">LYD_VALHINT_HEXNUM</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:ga37f27af52b2efed3ff6e448d96461c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9eb7b73e20888a0b1eb00e76664bb97" id="r_gae9eb7b73e20888a0b1eb00e76664bb97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#gae9eb7b73e20888a0b1eb00e76664bb97">LYD_VALHINT_NUM64</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:gae9eb7b73e20888a0b1eb00e76664bb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d665bff91ee8e952a767d3b303e173" id="r_gac9d665bff91ee8e952a767d3b303e173"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#gac9d665bff91ee8e952a767d3b303e173">LYD_VALHINT_OCTNUM</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:gac9d665bff91ee8e952a767d3b303e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0300e656b80fe4e23bf3e952e26e25f" id="r_gac0300e656b80fe4e23bf3e952e26e25f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lydvalhints.html#gac0300e656b80fe4e23bf3e952e26e25f">LYD_VALHINT_STRING</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:gac0300e656b80fe4e23bf3e952e26e25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0643c4040dd0b6187cac083990d3283" id="r_ae0643c4040dd0b6187cac083990d3283"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0643c4040dd0b6187cac083990d3283">LYD_VALUE_GET</a>(value,  type_val)</td></tr>
<tr class="memdesc:ae0643c4040dd0b6187cac083990d3283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value in format specific to the type.  <br /></td></tr>
<tr class="separator:ae0643c4040dd0b6187cac083990d3283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b991d9325f7b1b5dd58b7e00cc3cd2" id="r_ga04b991d9325f7b1b5dd58b7e00cc3cd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dnodeflags.html#ga04b991d9325f7b1b5dd58b7e00cc3cd2">LYD_WHEN_TRUE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga04b991d9325f7b1b5dd58b7e00cc3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3a5a21cdedd87df0ed0d5678b97b34b7" id="r_a3a5a21cdedd87df0ed0d5678b97b34b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a>) (const struct <a class="el" href="#structlyd__node">lyd_node</a> *diff_node, struct <a class="el" href="#structlyd__node">lyd_node</a> *data_node, void *cb_data)</td></tr>
<tr class="memdesc:a3a5a21cdedd87df0ed0d5678b97b34b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for diff nodes.  <br /></td></tr>
<tr class="separator:a3a5a21cdedd87df0ed0d5678b97b34b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5d806e21602f483f336fd929fe8aa6" id="r_a5e5d806e21602f483f336fd929fe8aa6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e5d806e21602f483f336fd929fe8aa6">lyd_merge_cb</a>) (struct <a class="el" href="#structlyd__node">lyd_node</a> *trg_node, const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_node, void *cb_data)</td></tr>
<tr class="memdesc:a5e5d806e21602f483f336fd929fe8aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for matching merge nodes.  <br /></td></tr>
<tr class="separator:a5e5d806e21602f483f336fd929fe8aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6c9118acdffb927abef758ed887a6334" id="r_a6c9118acdffb927abef758ed887a6334"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9118acdffb927abef758ed887a6334">LY_XPATH_TYPE</a> { <a class="el" href="#a6c9118acdffb927abef758ed887a6334a2aac9a57577eb7a8b61aed17247a81a7">LY_XPATH_NODE_SET</a>
, <a class="el" href="#a6c9118acdffb927abef758ed887a6334adf99bd991d4c70c0d387fe540bac7580">LY_XPATH_STRING</a>
, <a class="el" href="#a6c9118acdffb927abef758ed887a6334aa8906d6bb05792caf69f5d8ada1bf50a">LY_XPATH_NUMBER</a>
, <a class="el" href="#a6c9118acdffb927abef758ed887a6334ae2340c63b1c75a12df39f52e5bb31876">LY_XPATH_BOOLEAN</a>
 }</td></tr>
<tr class="memdesc:a6c9118acdffb927abef758ed887a6334"><td class="mdescLeft">&#160;</td><td class="mdescRight">XPath result type.  <a href="#a6c9118acdffb927abef758ed887a6334">More...</a><br /></td></tr>
<tr class="separator:a6c9118acdffb927abef758ed887a6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67df54d1294afeb498b20c35e6f6fccc" id="r_ga67df54d1294afeb498b20c35e6f6fccc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a> { <br />
&#160;&#160;<a class="el" href="group__datatree.html#gga67df54d1294afeb498b20c35e6f6fccca2241c6ec31c58f86a87b7a70a7b49723">LYD_ANYDATA_DATATREE</a>
, <a class="el" href="group__datatree.html#gga67df54d1294afeb498b20c35e6f6fcccaeee839000f74e429fd9a389229644987">LYD_ANYDATA_STRING</a>
, <a class="el" href="group__datatree.html#gga67df54d1294afeb498b20c35e6f6fccca65c5fd18e210dbaa4fd038e7da82a652">LYD_ANYDATA_XML</a>
, <a class="el" href="group__datatree.html#gga67df54d1294afeb498b20c35e6f6fccca55416fdab83b676d56dbf51954658d87">LYD_ANYDATA_JSON</a>
, <br />
&#160;&#160;<a class="el" href="group__datatree.html#gga67df54d1294afeb498b20c35e6f6fccca839b1aa2c5299aff915a09c04e0ec1e9">LYD_ANYDATA_LYB</a>
<br />
 }</td></tr>
<tr class="memdesc:ga67df54d1294afeb498b20c35e6f6fccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible value types stored in <a class="el" href="#structlyd__node__any" title="Data node structure for the anydata data tree nodes - anydata or anyxml.">lyd_node_any</a>.  <a href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">More...</a><br /></td></tr>
<tr class="separator:ga67df54d1294afeb498b20c35e6f6fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc615c3b9045dee5cf99c5e5482ff45" id="r_ga9cc615c3b9045dee5cf99c5e5482ff45"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">LYD_FORMAT</a> { <a class="el" href="group__datatree.html#gga9cc615c3b9045dee5cf99c5e5482ff45abf93d4212f2dd5a9e586bc7a7d6504bd">LYD_UNKNOWN</a> = 0
, <a class="el" href="group__datatree.html#gga9cc615c3b9045dee5cf99c5e5482ff45a496b2752b10f6cdd1b7d183c2f3af150">LYD_XML</a>
, <a class="el" href="group__datatree.html#gga9cc615c3b9045dee5cf99c5e5482ff45afd427f367b24d3c21033821cf127b728">LYD_JSON</a>
, <a class="el" href="group__datatree.html#gga9cc615c3b9045dee5cf99c5e5482ff45a08e5b973caa86cf6204d918bb8b53b6a">LYD_LYB</a>
 }</td></tr>
<tr class="memdesc:ga9cc615c3b9045dee5cf99c5e5482ff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data input/output formats supported by libyang <a class="el" href="howto_data_parsers.html">parser</a> and <a class="el" href="howto_data_printers.html">printer</a> functions.  <a href="group__datatree.html#ga9cc615c3b9045dee5cf99c5e5482ff45">More...</a><br /></td></tr>
<tr class="separator:ga9cc615c3b9045dee5cf99c5e5482ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6ee9ba8cea5395a5913b9a21ec24b0" id="r_a1b6ee9ba8cea5395a5913b9a21ec24b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">LYD_PATH_TYPE</a> { <a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0a767eb7a453fd8ee242b2b22f29a45ed7">LYD_PATH_STD</a>
, <a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0a44045afcee86a34cbf3a0b21f05950c3">LYD_PATH_STD_NO_LAST_PRED</a>
 }</td></tr>
<tr class="memdesc:a1b6ee9ba8cea5395a5913b9a21ec24b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of the different data paths.  <a href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">More...</a><br /></td></tr>
<tr class="separator:a1b6ee9ba8cea5395a5913b9a21ec24b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15eb844da46b876af3598bf074fe9b7a" id="r_a15eb844da46b876af3598bf074fe9b7a"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15eb844da46b876af3598bf074fe9b7a">ly_time_str2time</a> (const char *value, time_t *time, char **fractions_s)</td></tr>
<tr class="memdesc:a15eb844da46b876af3598bf074fe9b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert date-and-time from string to UNIX timestamp and fractions of a second.  <br /></td></tr>
<tr class="separator:a15eb844da46b876af3598bf074fe9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2895db28f5cc659b3c35a0292080dc2b" id="r_a2895db28f5cc659b3c35a0292080dc2b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2895db28f5cc659b3c35a0292080dc2b">ly_time_str2ts</a> (const char *value, struct timespec *ts)</td></tr>
<tr class="memdesc:a2895db28f5cc659b3c35a0292080dc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert date-and-time from string to timespec.  <br /></td></tr>
<tr class="separator:a2895db28f5cc659b3c35a0292080dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ce71c13fd2ada8d187364103893c86" id="r_a88ce71c13fd2ada8d187364103893c86"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ce71c13fd2ada8d187364103893c86">ly_time_time2str</a> (time_t time, const char *fractions_s, char **str)</td></tr>
<tr class="memdesc:a88ce71c13fd2ada8d187364103893c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UNIX timestamp and fractions of a second into canonical date-and-time string value.  <br /></td></tr>
<tr class="separator:a88ce71c13fd2ada8d187364103893c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153c607ecdbfc29e130d09e122c4bf4e" id="r_a153c607ecdbfc29e130d09e122c4bf4e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a153c607ecdbfc29e130d09e122c4bf4e">ly_time_ts2str</a> (const struct timespec *ts, char **str)</td></tr>
<tr class="memdesc:a153c607ecdbfc29e130d09e122c4bf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert timespec into date-and-time string value.  <br /></td></tr>
<tr class="separator:a153c607ecdbfc29e130d09e122c4bf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21102fec787065530840b0725c0c8c60" id="r_a21102fec787065530840b0725c0c8c60"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21102fec787065530840b0725c0c8c60">ly_time_tz_offset</a> (void)</td></tr>
<tr class="memdesc:a21102fec787065530840b0725c0c8c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current timezone (including DST setting) UTC (GMT) time offset in seconds.  <br /></td></tr>
<tr class="separator:a21102fec787065530840b0725c0c8c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f92021b58144375bf8848f6b0d0005" id="r_a83f92021b58144375bf8848f6b0d0005"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f92021b58144375bf8848f6b0d0005">ly_time_tz_offset_at</a> (time_t time)</td></tr>
<tr class="memdesc:a83f92021b58144375bf8848f6b0d0005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UTC (GMT) timezone offset in seconds at a specific timestamp (including DST setting).  <br /></td></tr>
<tr class="separator:a83f92021b58144375bf8848f6b0d0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e9d4064e9668bea11ccd46bad8bd2e" id="r_a99e9d4064e9668bea11ccd46bad8bd2e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e9d4064e9668bea11ccd46bad8bd2e">lyd_any_copy_value</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *trg, const union <a class="el" href="#unionlyd__any__value">lyd_any_value</a> *value, <a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a> value_type)</td></tr>
<tr class="memdesc:a99e9d4064e9668bea11ccd46bad8bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy anydata value from one node to another. Target value is freed first.  <br /></td></tr>
<tr class="separator:a99e9d4064e9668bea11ccd46bad8bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe45ac68fae798a21f56de7ae3438205" id="r_afe45ac68fae798a21f56de7ae3438205"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe45ac68fae798a21f56de7ae3438205">lyd_any_value_str</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *any, char **value_str)</td></tr>
<tr class="memdesc:afe45ac68fae798a21f56de7ae3438205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get anydata string value.  <br /></td></tr>
<tr class="separator:afe45ac68fae798a21f56de7ae3438205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223ce5290db18c8449a70383ab591c5" id="r_a2223ce5290db18c8449a70383ab591c5"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2223ce5290db18c8449a70383ab591c5">lyd_change_meta</a> (struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta, const char *val_str)</td></tr>
<tr class="memdesc:a2223ce5290db18c8449a70383ab591c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a metadata instance.  <br /></td></tr>
<tr class="separator:a2223ce5290db18c8449a70383ab591c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a996de8ea707118845efb469599be" id="r_a2a3a996de8ea707118845efb469599be"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a3a996de8ea707118845efb469599be">lyd_change_term</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *term, const char *val_str)</td></tr>
<tr class="memdesc:a2a3a996de8ea707118845efb469599be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a term (leaf or leaf-list) node to a string value.  <br /></td></tr>
<tr class="separator:a2a3a996de8ea707118845efb469599be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0411e44c7639e8117f3d4b606809f2d" id="r_ab0411e44c7639e8117f3d4b606809f2d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0411e44c7639e8117f3d4b606809f2d">lyd_change_term_bin</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *term, const void *value, size_t value_len)</td></tr>
<tr class="memdesc:ab0411e44c7639e8117f3d4b606809f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a term (leaf or leaf-list) node to a binary value.  <br /></td></tr>
<tr class="separator:ab0411e44c7639e8117f3d4b606809f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e4e3160e37170ce6908d8bd85f7feb" id="r_af8e4e3160e37170ce6908d8bd85f7feb"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8e4e3160e37170ce6908d8bd85f7feb">lyd_change_term_canon</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *term, const char *val_str)</td></tr>
<tr class="memdesc:af8e4e3160e37170ce6908d8bd85f7feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value of a term (leaf or leaf-list) node to a canonical string value.  <br /></td></tr>
<tr class="separator:af8e4e3160e37170ce6908d8bd85f7feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1dca771b11b89fe1123f4a52fe1db1" id="r_afe1dca771b11b89fe1123f4a52fe1db1"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe1dca771b11b89fe1123f4a52fe1db1">lyd_child</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:afe1dca771b11b89fe1123f4a52fe1db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child pointer of a generic data node.  <br /></td></tr>
<tr class="separator:afe1dca771b11b89fe1123f4a52fe1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78978bdaafb3f364662b12e54ac29455" id="r_a78978bdaafb3f364662b12e54ac29455"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78978bdaafb3f364662b12e54ac29455">lyd_child_no_keys</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a78978bdaafb3f364662b12e54ac29455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child pointer of a generic data node but skip its keys in case it is <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>.  <br /></td></tr>
<tr class="separator:a78978bdaafb3f364662b12e54ac29455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eccd0fdbe9ae8a07ea8c9231eaf1478" id="r_a3eccd0fdbe9ae8a07ea8c9231eaf1478"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eccd0fdbe9ae8a07ea8c9231eaf1478">lyd_compare_meta</a> (const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta1, const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta2)</td></tr>
<tr class="memdesc:a3eccd0fdbe9ae8a07ea8c9231eaf1478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 metadata.  <br /></td></tr>
<tr class="separator:a3eccd0fdbe9ae8a07ea8c9231eaf1478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a6283faa6c4e4a6ad6beb13a697cfa" id="r_a85a6283faa6c4e4a6ad6beb13a697cfa"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a6283faa6c4e4a6ad6beb13a697cfa">lyd_compare_siblings</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node1, const struct <a class="el" href="#structlyd__node">lyd_node</a> *node2, uint32_t options)</td></tr>
<tr class="memdesc:a85a6283faa6c4e4a6ad6beb13a697cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 lists of siblings if they are equivalent.  <br /></td></tr>
<tr class="separator:a85a6283faa6c4e4a6ad6beb13a697cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b09abc2714f03fc9301a72015e6f91" id="r_aa1b09abc2714f03fc9301a72015e6f91"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b09abc2714f03fc9301a72015e6f91">lyd_compare_single</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node1, const struct <a class="el" href="#structlyd__node">lyd_node</a> *node2, uint32_t options)</td></tr>
<tr class="memdesc:aa1b09abc2714f03fc9301a72015e6f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 data nodes if they are equivalent.  <br /></td></tr>
<tr class="separator:aa1b09abc2714f03fc9301a72015e6f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb182bb2f409970b96bf84bb47e2facf" id="r_adb182bb2f409970b96bf84bb47e2facf"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb182bb2f409970b96bf84bb47e2facf">lyd_diff_apply_all</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **data, const struct <a class="el" href="#structlyd__node">lyd_node</a> *diff)</td></tr>
<tr class="memdesc:adb182bb2f409970b96bf84bb47e2facf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the whole diff tree on a data tree.  <br /></td></tr>
<tr class="separator:adb182bb2f409970b96bf84bb47e2facf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26adfbeb4fbf0c6230b43f2ca42f734" id="r_ad26adfbeb4fbf0c6230b43f2ca42f734"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad26adfbeb4fbf0c6230b43f2ca42f734">lyd_diff_apply_module</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **data, const struct <a class="el" href="#structlyd__node">lyd_node</a> *diff, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *mod, <a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a> diff_cb, void *cb_data)</td></tr>
<tr class="memdesc:ad26adfbeb4fbf0c6230b43f2ca42f734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the whole diff on a data tree but restrict the operation to one module.  <br /></td></tr>
<tr class="separator:ad26adfbeb4fbf0c6230b43f2ca42f734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76137f507cbab61fc6598d517f18e704" id="r_a76137f507cbab61fc6598d517f18e704"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76137f507cbab61fc6598d517f18e704">lyd_diff_merge_all</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **diff, const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_diff, uint16_t options)</td></tr>
<tr class="memdesc:a76137f507cbab61fc6598d517f18e704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge 2 diffs into each other.  <br /></td></tr>
<tr class="separator:a76137f507cbab61fc6598d517f18e704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ce171c3612778614cb88849ab413b4" id="r_a61ce171c3612778614cb88849ab413b4"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61ce171c3612778614cb88849ab413b4">lyd_diff_merge_module</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **diff, const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_diff, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *mod, <a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a> diff_cb, void *cb_data, uint16_t options)</td></tr>
<tr class="memdesc:a61ce171c3612778614cb88849ab413b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge 2 diffs into each other but restrict the operation to one module.  <br /></td></tr>
<tr class="separator:a61ce171c3612778614cb88849ab413b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfae39d6833c6ae0fed54f94ac1d79b0" id="r_abfae39d6833c6ae0fed54f94ac1d79b0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfae39d6833c6ae0fed54f94ac1d79b0">lyd_diff_merge_tree</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **diff_first, struct <a class="el" href="#structlyd__node">lyd_node</a> *diff_parent, const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_sibling, <a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a> diff_cb, void *cb_data, uint16_t options)</td></tr>
<tr class="memdesc:abfae39d6833c6ae0fed54f94ac1d79b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge 2 diff trees into each other.  <br /></td></tr>
<tr class="separator:abfae39d6833c6ae0fed54f94ac1d79b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf6b8a2016c2c98efb96c4ae9d45a3f" id="r_a9bf6b8a2016c2c98efb96c4ae9d45a3f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf6b8a2016c2c98efb96c4ae9d45a3f">lyd_diff_reverse_all</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_diff, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a9bf6b8a2016c2c98efb96c4ae9d45a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a diff and make the opposite changes. Meaning change create to delete, delete to create, or move from place A to B to move from B to A and so on.  <br /></td></tr>
<tr class="separator:a9bf6b8a2016c2c98efb96c4ae9d45a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fba1149adafb0193fe220b67d9df553" id="r_a7fba1149adafb0193fe220b67d9df553"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fba1149adafb0193fe220b67d9df553">lyd_diff_siblings</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *first, const struct <a class="el" href="#structlyd__node">lyd_node</a> *second, uint16_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a7fba1149adafb0193fe220b67d9df553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn the differences between 2 data trees including all the following siblings.  <br /></td></tr>
<tr class="separator:a7fba1149adafb0193fe220b67d9df553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425dc8ab821d6d4d37bd9ad33d47256a" id="r_a425dc8ab821d6d4d37bd9ad33d47256a"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425dc8ab821d6d4d37bd9ad33d47256a">lyd_diff_tree</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *first, const struct <a class="el" href="#structlyd__node">lyd_node</a> *second, uint16_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a425dc8ab821d6d4d37bd9ad33d47256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn the differences between 2 data trees.  <br /></td></tr>
<tr class="separator:a425dc8ab821d6d4d37bd9ad33d47256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b2524a75058c92b1e591101a68c1d7" id="r_ad3b2524a75058c92b1e591101a68c1d7"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b2524a75058c92b1e591101a68c1d7">lyd_dup_meta_single</a> (const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta, struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **dup)</td></tr>
<tr class="memdesc:ad3b2524a75058c92b1e591101a68c1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the metadata.  <br /></td></tr>
<tr class="separator:ad3b2524a75058c92b1e591101a68c1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a5772d4093bd6657dd754732de3029" id="r_a50a5772d4093bd6657dd754732de3029"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a5772d4093bd6657dd754732de3029">lyd_dup_siblings</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node, struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *parent, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **dup)</td></tr>
<tr class="memdesc:a50a5772d4093bd6657dd754732de3029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the specified data tree <code>node</code> with any following siblings. Schema references are kept the same.  <br /></td></tr>
<tr class="separator:a50a5772d4093bd6657dd754732de3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b0325116808c47fb3b1f1c73c0bf4" id="r_a3d0b0325116808c47fb3b1f1c73c0bf4"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d0b0325116808c47fb3b1f1c73c0bf4">lyd_dup_siblings_to_ctx</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *trg_ctx, struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *parent, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **dup)</td></tr>
<tr class="memdesc:a3d0b0325116808c47fb3b1f1c73c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the specified data tree <code>node</code> with any following siblings. Schema references are assigned from <code>trg_ctx</code>.  <br /></td></tr>
<tr class="separator:a3d0b0325116808c47fb3b1f1c73c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b420e7711b9ed330e938190cca9bd3" id="r_aa7b420e7711b9ed330e938190cca9bd3"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7b420e7711b9ed330e938190cca9bd3">lyd_dup_single</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node, struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *parent, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **dup)</td></tr>
<tr class="memdesc:aa7b420e7711b9ed330e938190cca9bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the specified data tree <code>node</code>. Schema references are kept the same.  <br /></td></tr>
<tr class="separator:aa7b420e7711b9ed330e938190cca9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aa6af796933e317203720181673ddf" id="r_a46aa6af796933e317203720181673ddf"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46aa6af796933e317203720181673ddf">lyd_dup_single_to_ctx</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *trg_ctx, struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *parent, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **dup)</td></tr>
<tr class="memdesc:a46aa6af796933e317203720181673ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the specified data tree <code>node</code>. Schema references are assigned from <code>trg_ctx</code>.  <br /></td></tr>
<tr class="separator:a46aa6af796933e317203720181673ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5479c5688dee021e025d680964a11137" id="r_a5479c5688dee021e025d680964a11137"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5479c5688dee021e025d680964a11137">lyd_eval_xpath</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const char *xpath, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *result)</td></tr>
<tr class="memdesc:a5479c5688dee021e025d680964a11137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath on data and return the result converted to boolean.  <br /></td></tr>
<tr class="separator:a5479c5688dee021e025d680964a11137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18d26abd17c432d863120e121df2ecd" id="r_ae18d26abd17c432d863120e121df2ecd"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18d26abd17c432d863120e121df2ecd">lyd_eval_xpath2</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const char *xpath, const struct lyxp_var *vars, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *result)</td></tr>
<tr class="memdesc:ae18d26abd17c432d863120e121df2ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath on data and return the result converted to boolean.  <br /></td></tr>
<tr class="separator:ae18d26abd17c432d863120e121df2ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8ddd379b2ef76ff5b17a823d3b2ff8" id="r_afa8ddd379b2ef76ff5b17a823d3b2ff8"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8ddd379b2ef76ff5b17a823d3b2ff8">lyd_eval_xpath3</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *cur_mod, const char *xpath, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, const struct lyxp_var *vars, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *result)</td></tr>
<tr class="memdesc:afa8ddd379b2ef76ff5b17a823d3b2ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath on data and return the result converted to boolean.  <br /></td></tr>
<tr class="separator:afa8ddd379b2ef76ff5b17a823d3b2ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b3bc504338a12802c72c17730d9ed0" id="r_a43b3bc504338a12802c72c17730d9ed0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b3bc504338a12802c72c17730d9ed0">lyd_eval_xpath4</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="#structlyd__node">lyd_node</a> *tree, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *cur_mod, const char *xpath, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, const struct lyxp_var *vars, <a class="el" href="#a6c9118acdffb927abef758ed887a6334">LY_XPATH_TYPE</a> *ret_type, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **node_set, char **string, long double *number, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *boolean)</td></tr>
<tr class="memdesc:a43b3bc504338a12802c72c17730d9ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath on data and return the result or convert it first to an expected result type.  <br /></td></tr>
<tr class="separator:a43b3bc504338a12802c72c17730d9ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53edb144ccb0cb1934548d532d69cdc" id="r_aa53edb144ccb0cb1934548d532d69cdc"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa53edb144ccb0cb1934548d532d69cdc">lyd_find_meta</a> (const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *first, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name)</td></tr>
<tr class="memdesc:aa53edb144ccb0cb1934548d532d69cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific metadata.  <br /></td></tr>
<tr class="separator:aa53edb144ccb0cb1934548d532d69cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21136839d28e3be50f59c71acb47f9a5" id="r_a21136839d28e3be50f59c71acb47f9a5"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21136839d28e3be50f59c71acb47f9a5">lyd_find_path</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const char *path, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **match)</td></tr>
<tr class="memdesc:a21136839d28e3be50f59c71acb47f9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in given data for a node uniquely identified by a path.  <br /></td></tr>
<tr class="separator:a21136839d28e3be50f59c71acb47f9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536dbec9e92ebf61ac6a34477e997143" id="r_a536dbec9e92ebf61ac6a34477e997143"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a536dbec9e92ebf61ac6a34477e997143">lyd_find_sibling_dup_inst_set</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *siblings, const struct <a class="el" href="#structlyd__node">lyd_node</a> *target, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **set)</td></tr>
<tr class="memdesc:a536dbec9e92ebf61ac6a34477e997143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given siblings for all the exact same instances of a specific node instance. Uses hashes to whatever extent possible.  <br /></td></tr>
<tr class="separator:a536dbec9e92ebf61ac6a34477e997143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a45977540ff618d4c129e8a4fb36dd" id="r_a42a45977540ff618d4c129e8a4fb36dd"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a45977540ff618d4c129e8a4fb36dd">lyd_find_sibling_first</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *siblings, const struct <a class="el" href="#structlyd__node">lyd_node</a> *target, struct <a class="el" href="#structlyd__node">lyd_node</a> **match)</td></tr>
<tr class="memdesc:a42a45977540ff618d4c129e8a4fb36dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given siblings (NOT recursively) for the first target instance with the same value. Uses hashes - should be used whenever possible for best performance.  <br /></td></tr>
<tr class="separator:a42a45977540ff618d4c129e8a4fb36dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f635fdef0eaea66d2977a1f3f01fbb" id="r_a08f635fdef0eaea66d2977a1f3f01fbb"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08f635fdef0eaea66d2977a1f3f01fbb">lyd_find_sibling_opaq_next</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *first, const char *name, struct <a class="el" href="#structlyd__node">lyd_node</a> **match)</td></tr>
<tr class="memdesc:a08f635fdef0eaea66d2977a1f3f01fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given siblings for an opaque node with a specific name.  <br /></td></tr>
<tr class="separator:a08f635fdef0eaea66d2977a1f3f01fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f65c822293a6c813fae62c343f1ba54" id="r_a8f65c822293a6c813fae62c343f1ba54"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f65c822293a6c813fae62c343f1ba54">lyd_find_sibling_val</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *siblings, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *schema, const char *key_or_value, size_t val_len, struct <a class="el" href="#structlyd__node">lyd_node</a> **match)</td></tr>
<tr class="memdesc:a8f65c822293a6c813fae62c343f1ba54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given siblings for the first schema instance. Uses hashes - should be used whenever possible for best performance.  <br /></td></tr>
<tr class="separator:a8f65c822293a6c813fae62c343f1ba54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b699a792ef534e0326e09c4ac457e90" id="r_a1b699a792ef534e0326e09c4ac457e90"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b699a792ef534e0326e09c4ac457e90">lyd_find_target</a> (const struct ly_path *path, const struct <a class="el" href="#structlyd__node">lyd_node</a> *tree, struct <a class="el" href="#structlyd__node">lyd_node</a> **match)</td></tr>
<tr class="memdesc:a1b699a792ef534e0326e09c4ac457e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the target node of a compiled path (<a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> instance-identifier).  <br /></td></tr>
<tr class="separator:a1b699a792ef534e0326e09c4ac457e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7048eaa5c9477cf0373790fa6a0f7f" id="r_a0e7048eaa5c9477cf0373790fa6a0f7f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e7048eaa5c9477cf0373790fa6a0f7f">lyd_find_xpath</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const char *xpath, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **set)</td></tr>
<tr class="memdesc:a0e7048eaa5c9477cf0373790fa6a0f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given data for instances of nodes matching the provided XPath.  <br /></td></tr>
<tr class="separator:a0e7048eaa5c9477cf0373790fa6a0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4222d1539442779d935b793b45e1705" id="r_ab4222d1539442779d935b793b45e1705"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4222d1539442779d935b793b45e1705">lyd_find_xpath2</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const char *xpath, const struct lyxp_var *vars, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **set)</td></tr>
<tr class="memdesc:ab4222d1539442779d935b793b45e1705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given data for instances of nodes matching the provided XPath.  <br /></td></tr>
<tr class="separator:ab4222d1539442779d935b793b45e1705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c1d7cde0ba664c3ad3ce75ec6432f5" id="r_ae6c1d7cde0ba664c3ad3ce75ec6432f5"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6c1d7cde0ba664c3ad3ce75ec6432f5">lyd_find_xpath3</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="#structlyd__node">lyd_node</a> *tree, const char *xpath, const struct lyxp_var *vars, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **set)</td></tr>
<tr class="memdesc:ae6c1d7cde0ba664c3ad3ce75ec6432f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given data for instances of nodes matching the provided XPath.  <br /></td></tr>
<tr class="separator:ae6c1d7cde0ba664c3ad3ce75ec6432f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214f5c392871a86920eb665356c2c85" id="r_a8214f5c392871a86920eb665356c2c85"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8214f5c392871a86920eb665356c2c85">lyd_find_xpath4</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="#structlyd__node">lyd_node</a> *tree, const char *xpath, <a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a> format, void *prefix_data, const struct lyxp_var *vars, struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **set)</td></tr>
<tr class="memdesc:a8214f5c392871a86920eb665356c2c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search in the given data for instances of nodes matching the provided XPath.  <br /></td></tr>
<tr class="separator:a8214f5c392871a86920eb665356c2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd2f5806ae9628be1091a66245ef956" id="r_a2dd2f5806ae9628be1091a66245ef956"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dd2f5806ae9628be1091a66245ef956">lyd_first_sibling</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a2dd2f5806ae9628be1091a66245ef956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first sibling of the given node.  <br /></td></tr>
<tr class="separator:a2dd2f5806ae9628be1091a66245ef956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0678ec989c6861afc9d14b77630b4719" id="r_a0678ec989c6861afc9d14b77630b4719"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0678ec989c6861afc9d14b77630b4719">lyd_free_all</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a0678ec989c6861afc9d14b77630b4719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the nodes (even parents of the node) in the data tree.  <br /></td></tr>
<tr class="separator:a0678ec989c6861afc9d14b77630b4719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd528ccf51d9f2fb366116453d1ccffb" id="r_abd528ccf51d9f2fb366116453d1ccffb"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd528ccf51d9f2fb366116453d1ccffb">lyd_free_attr_siblings</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="#structlyd__attr">lyd_attr</a> *attr)</td></tr>
<tr class="memdesc:abd528ccf51d9f2fb366116453d1ccffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the attribute with any following attributes.  <br /></td></tr>
<tr class="separator:abd528ccf51d9f2fb366116453d1ccffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea574f4dbd92833dee7a0ee439817ed" id="r_acea574f4dbd92833dee7a0ee439817ed"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea574f4dbd92833dee7a0ee439817ed">lyd_free_attr_single</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="#structlyd__attr">lyd_attr</a> *attr)</td></tr>
<tr class="memdesc:acea574f4dbd92833dee7a0ee439817ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a single attribute.  <br /></td></tr>
<tr class="separator:acea574f4dbd92833dee7a0ee439817ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddedd7a41e22fe4a39e2c2067db3e1e" id="r_a0ddedd7a41e22fe4a39e2c2067db3e1e"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ddedd7a41e22fe4a39e2c2067db3e1e">lyd_free_meta_siblings</a> (struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta)</td></tr>
<tr class="memdesc:a0ddedd7a41e22fe4a39e2c2067db3e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the metadata instance with any following instances.  <br /></td></tr>
<tr class="separator:a0ddedd7a41e22fe4a39e2c2067db3e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e80898290ebde33f2d760a5d98e0a" id="r_af71e80898290ebde33f2d760a5d98e0a"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af71e80898290ebde33f2d760a5d98e0a">lyd_free_meta_single</a> (struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *meta)</td></tr>
<tr class="memdesc:af71e80898290ebde33f2d760a5d98e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a single metadata instance.  <br /></td></tr>
<tr class="separator:af71e80898290ebde33f2d760a5d98e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754d99a44cfa7f8b2ba9c0e2b9270825" id="r_a754d99a44cfa7f8b2ba9c0e2b9270825"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a754d99a44cfa7f8b2ba9c0e2b9270825">lyd_free_siblings</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a754d99a44cfa7f8b2ba9c0e2b9270825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the sibling nodes (preceding as well as succeeding).  <br /></td></tr>
<tr class="separator:a754d99a44cfa7f8b2ba9c0e2b9270825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409465a6286af6f7c68f7f96484967f1" id="r_a409465a6286af6f7c68f7f96484967f1"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a409465a6286af6f7c68f7f96484967f1">lyd_free_tree</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a409465a6286af6f7c68f7f96484967f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free (and unlink) the specified data (sub)tree.  <br /></td></tr>
<tr class="separator:a409465a6286af6f7c68f7f96484967f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2eeb0a95272274c72702899e864ba" id="r_abae2eeb0a95272274c72702899e864ba"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae2eeb0a95272274c72702899e864ba">lyd_get_value</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:abae2eeb0a95272274c72702899e864ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (canonical) value of a data node.  <br /></td></tr>
<tr class="separator:abae2eeb0a95272274c72702899e864ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf377c2ef890f0ecb05c9d8c4500250" id="r_a9bf377c2ef890f0ecb05c9d8c4500250"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf377c2ef890f0ecb05c9d8c4500250">lyd_insert_after</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *sibling, struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a9bf377c2ef890f0ecb05c9d8c4500250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node after another node, can be used only for user-ordered nodes. If inserting several siblings, each of them must be inserted individually.  <br /></td></tr>
<tr class="separator:a9bf377c2ef890f0ecb05c9d8c4500250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd0eb0426da05bc4b65c3cdf79efba6" id="r_a7bd0eb0426da05bc4b65c3cdf79efba6"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bd0eb0426da05bc4b65c3cdf79efba6">lyd_insert_before</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *sibling, struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a7bd0eb0426da05bc4b65c3cdf79efba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node before another node, can be used only for user-ordered nodes. If inserting several siblings, each of them must be inserted individually.  <br /></td></tr>
<tr class="separator:a7bd0eb0426da05bc4b65c3cdf79efba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c974e2b6993714fc5ee70ace4c5a654" id="r_a2c974e2b6993714fc5ee70ace4c5a654"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c974e2b6993714fc5ee70ace4c5a654">lyd_insert_child</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a2c974e2b6993714fc5ee70ace4c5a654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a child into a parent.  <br /></td></tr>
<tr class="separator:a2c974e2b6993714fc5ee70ace4c5a654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc790b985c813c804f5a345b8483e7e0" id="r_afc790b985c813c804f5a345b8483e7e0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc790b985c813c804f5a345b8483e7e0">lyd_insert_sibling</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *sibling, struct <a class="el" href="#structlyd__node">lyd_node</a> *node, struct <a class="el" href="#structlyd__node">lyd_node</a> **first)</td></tr>
<tr class="memdesc:afc790b985c813c804f5a345b8483e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into siblings.  <br /></td></tr>
<tr class="separator:afc790b985c813c804f5a345b8483e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf94dd13c544c7be9a49c6d30c1de473" id="r_abf94dd13c544c7be9a49c6d30c1de473"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf94dd13c544c7be9a49c6d30c1de473">lyd_is_default</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:abf94dd13c544c7be9a49c6d30c1de473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a node value equals to its default one.  <br /></td></tr>
<tr class="separator:abf94dd13c544c7be9a49c6d30c1de473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a37bce0e3b79294c66b0af09ddbfc59" id="r_a9a37bce0e3b79294c66b0af09ddbfc59"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a37bce0e3b79294c66b0af09ddbfc59">lyd_list_pos</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *instance)</td></tr>
<tr class="memdesc:a9a37bce0e3b79294c66b0af09ddbfc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn the relative position of a list or leaf-list instance within other instances of the same schema node.  <br /></td></tr>
<tr class="separator:a9a37bce0e3b79294c66b0af09ddbfc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d05cffbc8606fd03798ce4ede72eb1" id="r_a67d05cffbc8606fd03798ce4ede72eb1"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d05cffbc8606fd03798ce4ede72eb1">lyd_lyb_data_length</a> (const char *data)</td></tr>
<tr class="memdesc:a67d05cffbc8606fd03798ce4ede72eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn the length of LYB data.  <br /></td></tr>
<tr class="separator:a67d05cffbc8606fd03798ce4ede72eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee582e0be9fee58f1c5ed69e17795ca2" id="r_aee582e0be9fee58f1c5ed69e17795ca2"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee582e0be9fee58f1c5ed69e17795ca2">lyd_merge_module</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **target, const struct <a class="el" href="#structlyd__node">lyd_node</a> *source, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *mod, <a class="el" href="#a5e5d806e21602f483f336fd929fe8aa6">lyd_merge_cb</a> merge_cb, void *cb_data, uint16_t options)</td></tr>
<tr class="memdesc:aee582e0be9fee58f1c5ed69e17795ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all the nodes of a module from source data tree into the target data tree. Merge may not be complete until validation called on the resulting data tree (data from more cases may be present, default and non-default values).  <br /></td></tr>
<tr class="separator:aee582e0be9fee58f1c5ed69e17795ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c306749d40e1334367b14db7f4bfab7" id="r_a0c306749d40e1334367b14db7f4bfab7"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c306749d40e1334367b14db7f4bfab7">lyd_merge_siblings</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **target, const struct <a class="el" href="#structlyd__node">lyd_node</a> *source, uint16_t options)</td></tr>
<tr class="memdesc:a0c306749d40e1334367b14db7f4bfab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the source data tree with any following siblings into the target data tree. Merge may not be complete until validation called on the resulting data tree (data from more cases may be present, default and non-default values).  <br /></td></tr>
<tr class="separator:a0c306749d40e1334367b14db7f4bfab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71f20040dd280c7ab8049068202fb25" id="r_aa71f20040dd280c7ab8049068202fb25"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71f20040dd280c7ab8049068202fb25">lyd_merge_tree</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **target, const struct <a class="el" href="#structlyd__node">lyd_node</a> *source, uint16_t options)</td></tr>
<tr class="memdesc:aa71f20040dd280c7ab8049068202fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the source data subtree into the target data tree. Merge may not be complete until validation is called on the resulting data tree (data from more cases may be present, default and non-default values).  <br /></td></tr>
<tr class="separator:aa71f20040dd280c7ab8049068202fb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7104d2de2f2cb3097a2a7dfb1a9956" id="r_aaf7104d2de2f2cb3097a2a7dfb1a9956"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf7104d2de2f2cb3097a2a7dfb1a9956">lyd_new_any</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const void *value, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> use_value, <a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a> value_type, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:aaf7104d2de2f2cb3097a2a7dfb1a9956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new any node in the data tree.  <br /></td></tr>
<tr class="separator:aaf7104d2de2f2cb3097a2a7dfb1a9956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84d9cca4c6f68a8eaa7b184bce2045" id="r_a2c84d9cca4c6f68a8eaa7b184bce2045"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c84d9cca4c6f68a8eaa7b184bce2045">lyd_new_attr</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const char *module_name, const char *name, const char *value, struct <a class="el" href="#structlyd__attr">lyd_attr</a> **attr)</td></tr>
<tr class="memdesc:a2c84d9cca4c6f68a8eaa7b184bce2045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new JSON attribute for an opaque data node. To create an XML attribute, use <a class="el" href="#aa7cc4e94963cee8ec1c04813218e266c" title="Create new XML attribute for an opaque data node. To create a JSON attribute, use lyd_new_attr().">lyd_new_attr2()</a>.  <br /></td></tr>
<tr class="separator:a2c84d9cca4c6f68a8eaa7b184bce2045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cc4e94963cee8ec1c04813218e266c" id="r_aa7cc4e94963cee8ec1c04813218e266c"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7cc4e94963cee8ec1c04813218e266c">lyd_new_attr2</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const char *module_ns, const char *name, const char *value, struct <a class="el" href="#structlyd__attr">lyd_attr</a> **attr)</td></tr>
<tr class="memdesc:aa7cc4e94963cee8ec1c04813218e266c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new XML attribute for an opaque data node. To create a JSON attribute, use <a class="el" href="#a2c84d9cca4c6f68a8eaa7b184bce2045" title="Create new JSON attribute for an opaque data node. To create an XML attribute, use lyd_new_attr2().">lyd_new_attr()</a>.  <br /></td></tr>
<tr class="separator:aa7cc4e94963cee8ec1c04813218e266c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fed36624b42c6123c935ab496f7165" id="r_a47fed36624b42c6123c935ab496f7165"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47fed36624b42c6123c935ab496f7165">lyd_new_ext_any</a> (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, const char *name, const void *value, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> use_value, <a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a> value_type, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a47fed36624b42c6123c935ab496f7165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level any node defined in the given extension instance.  <br /></td></tr>
<tr class="separator:a47fed36624b42c6123c935ab496f7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744293d284c7a9b4b41f6290e1640af3" id="r_a744293d284c7a9b4b41f6290e1640af3"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a744293d284c7a9b4b41f6290e1640af3">lyd_new_ext_inner</a> (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, const char *name, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a744293d284c7a9b4b41f6290e1640af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level inner node defined in the given extension instance.  <br /></td></tr>
<tr class="separator:a744293d284c7a9b4b41f6290e1640af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e2a95c8187488988055b7d947ef24" id="r_a787e2a95c8187488988055b7d947ef24"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a787e2a95c8187488988055b7d947ef24">lyd_new_ext_list</a> (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, const char *name, struct <a class="el" href="#structlyd__node">lyd_node</a> **node,...)</td></tr>
<tr class="memdesc:a787e2a95c8187488988055b7d947ef24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level list node defined in the given extension instance.  <br /></td></tr>
<tr class="separator:a787e2a95c8187488988055b7d947ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319dac303b26b9a29d7ba9f31890eb0" id="r_a9319dac303b26b9a29d7ba9f31890eb0"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9319dac303b26b9a29d7ba9f31890eb0">lyd_new_ext_path</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, const char *path, const void *value, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a9319dac303b26b9a29d7ba9f31890eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node defined in the given extension instance. In case of anyxml/anydata nodes, this function expects the <code>value</code> as string.  <br /></td></tr>
<tr class="separator:a9319dac303b26b9a29d7ba9f31890eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f464b732a909c9da359299ff67e9db" id="r_ac0f464b732a909c9da359299ff67e9db"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0f464b732a909c9da359299ff67e9db">lyd_new_ext_term</a> (const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *ext, const char *name, const char *val_str, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:ac0f464b732a909c9da359299ff67e9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level term node defined in the given extension instance.  <br /></td></tr>
<tr class="separator:ac0f464b732a909c9da359299ff67e9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33298dd1881db5a07003e8e85734865f" id="r_a33298dd1881db5a07003e8e85734865f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33298dd1881db5a07003e8e85734865f">lyd_new_implicit_all</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **tree, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, uint32_t implicit_options, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a33298dd1881db5a07003e8e85734865f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add any missing implicit nodes. Default nodes with a false "when" are not added.  <br /></td></tr>
<tr class="separator:a33298dd1881db5a07003e8e85734865f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ea402ee911b4e5e5ac9ee1a0d2f84" id="r_a1f7ea402ee911b4e5e5ac9ee1a0d2f84"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7ea402ee911b4e5e5ac9ee1a0d2f84">lyd_new_implicit_module</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **tree, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, uint32_t implicit_options, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a1f7ea402ee911b4e5e5ac9ee1a0d2f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add any missing implicit nodes of one module. Default nodes with a false "when" are not added.  <br /></td></tr>
<tr class="separator:a1f7ea402ee911b4e5e5ac9ee1a0d2f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277bb5a915017f19523fe30e9528f92" id="r_a4277bb5a915017f19523fe30e9528f92"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4277bb5a915017f19523fe30e9528f92">lyd_new_implicit_tree</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *tree, uint32_t implicit_options, struct <a class="el" href="#structlyd__node">lyd_node</a> **diff)</td></tr>
<tr class="memdesc:a4277bb5a915017f19523fe30e9528f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add any missing implicit nodes into a data subtree. Default nodes with a false "when" are not added.  <br /></td></tr>
<tr class="separator:a4277bb5a915017f19523fe30e9528f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681e05d82a50293c6cc9cbfad1050de" id="r_ac681e05d82a50293c6cc9cbfad1050de"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac681e05d82a50293c6cc9cbfad1050de">lyd_new_inner</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:ac681e05d82a50293c6cc9cbfad1050de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new inner node in the data tree.  <br /></td></tr>
<tr class="separator:ac681e05d82a50293c6cc9cbfad1050de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e61eda8700065c3630e908bd8f82508" id="r_a7e61eda8700065c3630e908bd8f82508"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e61eda8700065c3630e908bd8f82508">lyd_new_list</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node,...)</td></tr>
<tr class="memdesc:a7e61eda8700065c3630e908bd8f82508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a7e61eda8700065c3630e908bd8f82508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4953b9d68eb4e533f93aeb11d634eeb7" id="r_a4953b9d68eb4e533f93aeb11d634eeb7"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4953b9d68eb4e533f93aeb11d634eeb7">lyd_new_list2</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char *keys, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a4953b9d68eb4e533f93aeb11d634eeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a4953b9d68eb4e533f93aeb11d634eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3a3bc154721cac2df98013dde917e9" id="r_a2c3a3bc154721cac2df98013dde917e9"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3a3bc154721cac2df98013dde917e9">lyd_new_list3</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char **key_values, uint32_t *value_lengths, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a2c3a3bc154721cac2df98013dde917e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a2c3a3bc154721cac2df98013dde917e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e27fcb3b97c6e7788ebab12bcb6e4f4" id="r_a9e27fcb3b97c6e7788ebab12bcb6e4f4"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e27fcb3b97c6e7788ebab12bcb6e4f4">lyd_new_list3_bin</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const void **key_values, uint32_t *value_lengths, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a9e27fcb3b97c6e7788ebab12bcb6e4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a9e27fcb3b97c6e7788ebab12bcb6e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3f2cf7c5bc2b624e7a9551155b6f9d" id="r_a5e3f2cf7c5bc2b624e7a9551155b6f9d"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e3f2cf7c5bc2b624e7a9551155b6f9d">lyd_new_list3_canon</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char **key_values, uint32_t *value_lengths, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a5e3f2cf7c5bc2b624e7a9551155b6f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a5e3f2cf7c5bc2b624e7a9551155b6f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75cd7606ace6e51faf3f879c2fda986" id="r_ab75cd7606ace6e51faf3f879c2fda986"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab75cd7606ace6e51faf3f879c2fda986">lyd_new_list_bin</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node,...)</td></tr>
<tr class="memdesc:ab75cd7606ace6e51faf3f879c2fda986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:ab75cd7606ace6e51faf3f879c2fda986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e055470773fcbf90f6faa4633172d3" id="r_a21e055470773fcbf90f6faa4633172d3"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21e055470773fcbf90f6faa4633172d3">lyd_new_list_canon</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node,...)</td></tr>
<tr class="memdesc:a21e055470773fcbf90f6faa4633172d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list node in the data tree.  <br /></td></tr>
<tr class="separator:a21e055470773fcbf90f6faa4633172d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e88f2d851b561f0eb1c966ba181be55" id="r_a2e88f2d851b561f0eb1c966ba181be55"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e88f2d851b561f0eb1c966ba181be55">lyd_new_meta</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char *val_str, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> clear_dflt, struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **meta)</td></tr>
<tr class="memdesc:a2e88f2d851b561f0eb1c966ba181be55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new metadata.  <br /></td></tr>
<tr class="separator:a2e88f2d851b561f0eb1c966ba181be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc392eb64f2b67f0db656daa12047da" id="r_adbc392eb64f2b67f0db656daa12047da"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc392eb64f2b67f0db656daa12047da">lyd_new_meta2</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> clear_dflt, const struct <a class="el" href="#structlyd__attr">lyd_attr</a> *attr, struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **meta)</td></tr>
<tr class="memdesc:adbc392eb64f2b67f0db656daa12047da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new metadata from an opaque node attribute if possible.  <br /></td></tr>
<tr class="separator:adbc392eb64f2b67f0db656daa12047da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298fe45ddae4447e25ce179c5ed14e47" id="r_a298fe45ddae4447e25ce179c5ed14e47"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a298fe45ddae4447e25ce179c5ed14e47">lyd_new_opaq</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const char *name, const char *value, const char *prefix, const char *module_name, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a298fe45ddae4447e25ce179c5ed14e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new JSON opaque node in the data tree. To create an XML opaque node, use <a class="el" href="#afefaab2ce7b396d269bd956ba193fb85" title="Create a new XML opaque node in the data tree. To create a JSON opaque node, use lyd_new_opaq().">lyd_new_opaq2()</a>.  <br /></td></tr>
<tr class="separator:a298fe45ddae4447e25ce179c5ed14e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefaab2ce7b396d269bd956ba193fb85" id="r_afefaab2ce7b396d269bd956ba193fb85"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afefaab2ce7b396d269bd956ba193fb85">lyd_new_opaq2</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const char *name, const char *value, const char *prefix, const char *module_ns, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:afefaab2ce7b396d269bd956ba193fb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new XML opaque node in the data tree. To create a JSON opaque node, use <a class="el" href="#a298fe45ddae4447e25ce179c5ed14e47" title="Create a new JSON opaque node in the data tree. To create an XML opaque node, use lyd_new_opaq2().">lyd_new_opaq()</a>.  <br /></td></tr>
<tr class="separator:afefaab2ce7b396d269bd956ba193fb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164faee35d90e24371b237a0969cf73b" id="r_a164faee35d90e24371b237a0969cf73b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164faee35d90e24371b237a0969cf73b">lyd_new_path</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const char *path, const char *value, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a164faee35d90e24371b237a0969cf73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node in the data tree based on a path. If creating anyxml/anydata nodes, <a class="el" href="#a1f8d709533cfc82522da20a882dd086b" title="Create a new node in the data tree based on a path. All node types can be created.">lyd_new_path2</a> should be used instead, this function expects the value as string.  <br /></td></tr>
<tr class="separator:a164faee35d90e24371b237a0969cf73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d709533cfc82522da20a882dd086b" id="r_a1f8d709533cfc82522da20a882dd086b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f8d709533cfc82522da20a882dd086b">lyd_new_path2</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const char *path, const void *value, size_t value_len, <a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a> value_type, uint32_t options, struct <a class="el" href="#structlyd__node">lyd_node</a> **new_parent, struct <a class="el" href="#structlyd__node">lyd_node</a> **new_node)</td></tr>
<tr class="memdesc:a1f8d709533cfc82522da20a882dd086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node in the data tree based on a path. All node types can be created.  <br /></td></tr>
<tr class="separator:a1f8d709533cfc82522da20a882dd086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a289ea68ed2160af65314c245e689a" id="r_aa0a289ea68ed2160af65314c245e689a"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a289ea68ed2160af65314c245e689a">lyd_new_term</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char *val_str, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:aa0a289ea68ed2160af65314c245e689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new term node in the data tree.  <br /></td></tr>
<tr class="separator:aa0a289ea68ed2160af65314c245e689a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fc666afb9745d840990759f8eab917" id="r_ac1fc666afb9745d840990759f8eab917"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fc666afb9745d840990759f8eab917">lyd_new_term_bin</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const void *value, size_t value_len, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:ac1fc666afb9745d840990759f8eab917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new term node in the data tree.  <br /></td></tr>
<tr class="separator:ac1fc666afb9745d840990759f8eab917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba9aff9f205c2b1b987c7f8dee89b38" id="r_a4ba9aff9f205c2b1b987c7f8dee89b38"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ba9aff9f205c2b1b987c7f8dee89b38">lyd_new_term_canon</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *parent, const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *module, const char *name, const char *val_str, <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> output, struct <a class="el" href="#structlyd__node">lyd_node</a> **node)</td></tr>
<tr class="memdesc:a4ba9aff9f205c2b1b987c7f8dee89b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new term node in the data tree.  <br /></td></tr>
<tr class="separator:a4ba9aff9f205c2b1b987c7f8dee89b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6559a67f87c974fe977d95ccfb9875" id="r_a3a6559a67f87c974fe977d95ccfb9875"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6559a67f87c974fe977d95ccfb9875">lyd_node_module</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a3a6559a67f87c974fe977d95ccfb9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module of a node. Useful mainly for opaque nodes.  <br /></td></tr>
<tr class="separator:a3a6559a67f87c974fe977d95ccfb9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c06a492c6e8af966cc3fac24fdc35a8" id="r_a5c06a492c6e8af966cc3fac24fdc35a8"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c06a492c6e8af966cc3fac24fdc35a8">lyd_node_schema</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a5c06a492c6e8af966cc3fac24fdc35a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get schema node of a data node. Useful especially for opaque nodes.  <br /></td></tr>
<tr class="separator:a5c06a492c6e8af966cc3fac24fdc35a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8741b9abcc8770f30eeba991b4e5f18" id="r_ab8741b9abcc8770f30eeba991b4e5f18"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8741b9abcc8770f30eeba991b4e5f18">lyd_owner_module</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:ab8741b9abcc8770f30eeba991b4e5f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owner module of the data node. It is the module of the top-level schema node. Generally, in case of augments it is the target module, recursively, otherwise it is the module where the data node is defined.  <br /></td></tr>
<tr class="separator:ab8741b9abcc8770f30eeba991b4e5f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dda28aa5d60cf74f1527543535ca21" id="r_ae1dda28aa5d60cf74f1527543535ca21"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1dda28aa5d60cf74f1527543535ca21">lyd_parent</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:ae1dda28aa5d60cf74f1527543535ca21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the generic parent pointer of a data node.  <br /></td></tr>
<tr class="separator:ae1dda28aa5d60cf74f1527543535ca21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6149bd9380ad24c6b5591f196eb73c" id="r_abd6149bd9380ad24c6b5591f196eb73c"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6149bd9380ad24c6b5591f196eb73c">lyd_parse_opaq_error</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:abd6149bd9380ad24c6b5591f196eb73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check node parsed into an opaque node for the reason (error) why it could not be parsed as data node.  <br /></td></tr>
<tr class="separator:abd6149bd9380ad24c6b5591f196eb73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acafa02872b3c35cf8a8df2aba48935" id="r_a1acafa02872b3c35cf8a8df2aba48935"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1acafa02872b3c35cf8a8df2aba48935">lyd_path</a> (const struct <a class="el" href="#structlyd__node">lyd_node</a> *node, <a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">LYD_PATH_TYPE</a> pathtype, char *buffer, size_t buflen)</td></tr>
<tr class="memdesc:a1acafa02872b3c35cf8a8df2aba48935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate path of the given node in the requested format.  <br /></td></tr>
<tr class="separator:a1acafa02872b3c35cf8a8df2aba48935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa0f950b696146e44da0d4f3259e749" id="r_a0fa0f950b696146e44da0d4f3259e749"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const struct <a class="el" href="#structlyd__node__term">lyd_node_term</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa0f950b696146e44da0d4f3259e749">lyd_target</a> (const struct ly_path *path, const struct <a class="el" href="#structlyd__node">lyd_node</a> *tree)</td></tr>
<tr class="memdesc:a0fa0f950b696146e44da0d4f3259e749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, use <a class="el" href="#a1b699a792ef534e0326e09c4ac457e90" title="Find the target node of a compiled path (lyd_value instance-identifier).">lyd_find_target()</a> instead.  <br /></td></tr>
<tr class="separator:a0fa0f950b696146e44da0d4f3259e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0738724db5205b7922291740910f6" id="r_a89c0738724db5205b7922291740910f6"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DEF <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89c0738724db5205b7922291740910f6">lyd_trim_xpath</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> **tree, const char *xpath, const struct lyxp_var *vars)</td></tr>
<tr class="memdesc:a89c0738724db5205b7922291740910f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath on data and free all the nodes except the subtrees selected by the expression.  <br /></td></tr>
<tr class="separator:a89c0738724db5205b7922291740910f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1496e90d6566e4f5c8ac42820b7da06f" id="r_a1496e90d6566e4f5c8ac42820b7da06f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1496e90d6566e4f5c8ac42820b7da06f">lyd_unlink_siblings</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:a1496e90d6566e4f5c8ac42820b7da06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the specified node with all the following siblings.  <br /></td></tr>
<tr class="separator:a1496e90d6566e4f5c8ac42820b7da06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324d1f04fa5eba220e14706c6a81c67" id="r_af324d1f04fa5eba220e14706c6a81c67"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af324d1f04fa5eba220e14706c6a81c67">lyd_unlink_tree</a> (struct <a class="el" href="#structlyd__node">lyd_node</a> *node)</td></tr>
<tr class="memdesc:af324d1f04fa5eba220e14706c6a81c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the specified data subtree.  <br /></td></tr>
<tr class="separator:af324d1f04fa5eba220e14706c6a81c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea976bf69714042da3271c56c9e0690" id="r_a8ea976bf69714042da3271c56c9e0690"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ea976bf69714042da3271c56c9e0690">lyd_value_compare</a> (const struct <a class="el" href="#structlyd__node__term">lyd_node_term</a> *node, const char *value, size_t value_len)</td></tr>
<tr class="memdesc:a8ea976bf69714042da3271c56c9e0690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the node's value with the given string value. The string value is first validated according to the (current) node's type.  <br /></td></tr>
<tr class="separator:a8ea976bf69714042da3271c56c9e0690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7f170bc5a223d8b9c9404bad35c4b" id="r_a19d7f170bc5a223d8b9c9404bad35c4b"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d7f170bc5a223d8b9c9404bad35c4b">lyd_value_get_canonical</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="#structlyd__value">lyd_value</a> *value)</td></tr>
<tr class="memdesc:a19d7f170bc5a223d8b9c9404bad35c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (canonical) value of a <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a>.  <br /></td></tr>
<tr class="separator:a19d7f170bc5a223d8b9c9404bad35c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e5554a07ea3477126ad802619315f" id="r_ac05e5554a07ea3477126ad802619315f"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac05e5554a07ea3477126ad802619315f">lyd_value_validate</a> (const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *ctx, const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *schema, const char *value, size_t value_len, const struct <a class="el" href="#structlyd__node">lyd_node</a> *ctx_node, const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> **realtype, const char **canonical)</td></tr>
<tr class="memdesc:ac05e5554a07ea3477126ad802619315f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check type restrictions applicable to the particular leaf/leaf-list with the given string <code>value</code>.  <br /></td></tr>
<tr class="separator:ac05e5554a07ea3477126ad802619315f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3dd55db8de52aeb441cd2d62dff37" id="r_a00c3dd55db8de52aeb441cd2d62dff37"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c3dd55db8de52aeb441cd2d62dff37">lyxp_vars_free</a> (struct lyxp_var *vars)</td></tr>
<tr class="memdesc:a00c3dd55db8de52aeb441cd2d62dff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the XPath variables.  <br /></td></tr>
<tr class="separator:a00c3dd55db8de52aeb441cd2d62dff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7823f5e06f3a2ab833a0206ea2ab5427" id="r_a7823f5e06f3a2ab833a0206ea2ab5427"><td class="memItemLeft" align="right" valign="top">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7823f5e06f3a2ab833a0206ea2ab5427">lyxp_vars_set</a> (struct lyxp_var **vars, const char *name, const char *value)</td></tr>
<tr class="memdesc:a7823f5e06f3a2ab833a0206ea2ab5427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new XPath variable to <code>vars</code>.  <br /></td></tr>
<tr class="separator:a7823f5e06f3a2ab833a0206ea2ab5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>libyang representation of YANG data trees. </p>
<dl class="section author"><dt>Author</dt><dd>Radek Krejci <a href="#" onclick="location.href='mai'+'lto:'+'rkr'+'ej'+'ci@'+'ce'+'sne'+'t.'+'cz'; return false;">rkrej<span class="obfuscator">.nosp@m.</span>ci@c<span class="obfuscator">.nosp@m.</span>esnet<span class="obfuscator">.nosp@m.</span>.cz</a> </dd>
<dd>
Michal Vasko <a href="#" onclick="location.href='mai'+'lto:'+'mva'+'sk'+'o@c'+'es'+'net'+'.c'+'z'; return false;">mvask<span class="obfuscator">.nosp@m.</span>o@ce<span class="obfuscator">.nosp@m.</span>snet.<span class="obfuscator">.nosp@m.</span>cz</a> </dd></dl>
<p>Copyright (c) 2015 - 2022 CESNET, z.s.p.o.</p>
<p>This source code is licensed under BSD 3-Clause License (the "License"). You may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">https://opensource.org/licenses/BSD-3-Clause
</pre> 
<p class="definition">Definition in file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structly__opaq__name" id="structly__opaq__name"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structly__opaq__name">&#9670;&#160;</a></span>ly_opaq_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ly_opaq_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Generic prefix and namespace mapping, meaning depends on the format. </p>
<p>The union is used as a reference to the data's module and according to the format, it can be used as a key for <a class="el" href="group__context.html#gac51dc9a3127acfd4a551f21c30bec49b" title="Get the (only) implemented YANG module specified by its namespace.">ly_ctx_get_module_implemented_ns()</a> or <a class="el" href="group__context.html#ga3103754834298177ec380a555cea70f0" title="Get the (only) implemented YANG module specified by its name.">ly_ctx_get_module_implemented()</a>. While the module reference is always present, the prefix member can be omitted in case it is not present in the source data as a reference to the default module/namespace. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00719">719</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a17e5e4e3df836425e9651c4fc1fbd29a" name="a17e5e4e3df836425e9651c4fc1fbd29a"></a>union <a class="el" href="#unionly__opaq__name_8____unnamed5____">ly_opaq_name.__unnamed5__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a83d2662133051b4cdbe1c772aa3f7a59" name="a83d2662133051b4cdbe1c772aa3f7a59"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>node name, without prefix if any was defined </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0fdc454c0e73ca517eaaf4e99480e0f7" name="a0fdc454c0e73ca517eaaf4e99480e0f7"></a>const char *</td>
<td class="fieldname">
prefix</td>
<td class="fielddoc">
<p>identifier used in the qualified name as the prefix, can be NULL </p>
</td></tr>
</table>

</div>
</div>
<a name="unionly__opaq__name_8____unnamed5____" id="unionly__opaq__name_8____unnamed5____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionly__opaq__name_8____unnamed5____">&#9670;&#160;</a></span>ly_opaq_name.__unnamed5__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union ly_opaq_name.__unnamed5__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00723">723</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a854203cccade0bbe21be239a208aea49" name="a854203cccade0bbe21be239a208aea49"></a>const char *</td>
<td class="fieldname">
module_name</td>
<td class="fielddoc">
<p>format <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> - (inherited) name of the module of the element </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a12bdc3f093b06764f653593d5e7106d2" name="a12bdc3f093b06764f653593d5e7106d2"></a>const char *</td>
<td class="fieldname">
module_ns</td>
<td class="fielddoc">
<p>format <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a774449778766552963604a347c739e38">LY_VALUE_XML</a> - XML namespace of the node element </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__any__value" id="unionlyd__any__value"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__any__value">&#9670;&#160;</a></span>lyd_any_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_any_value</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>union for anydata/anyxml value representation. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00862">862</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3f8e98ab0fd20b7ffc19d8f5fc80291e" name="a3f8e98ab0fd20b7ffc19d8f5fc80291e"></a>const char *</td>
<td class="fieldname">
json</td>
<td class="fielddoc">
<p>I-JSON encoded string </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a244da205cc80ac1ba8df45d513ec61d5" name="a244da205cc80ac1ba8df45d513ec61d5"></a>char *</td>
<td class="fieldname">
mem</td>
<td class="fielddoc">
<p>LYD_ANYDATA_LYB memory chunk </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1b383f115379c0f888bdb9c64bbf7b64" name="a1b383f115379c0f888bdb9c64bbf7b64"></a>const char *</td>
<td class="fieldname">
str</td>
<td class="fielddoc">
<p>Generic string data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a257f5dd1a3958957f9fcac1290b99243" name="a257f5dd1a3958957f9fcac1290b99243"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
tree</td>
<td class="fielddoc">
<p>data tree </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abd39894c5927a7e184d69b945e421e84" name="abd39894c5927a7e184d69b945e421e84"></a>const char *</td>
<td class="fieldname">
xml</td>
<td class="fielddoc">
<p>Serialized XML data </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__attr" id="structlyd__attr"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__attr">&#9670;&#160;</a></span>lyd_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_attr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Generic attribute structure. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00732">732</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a013d09af1fb1257dc89a17af2feed968" name="a013d09af1fb1257dc89a17af2feed968"></a><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>
<td class="fieldname">
format</td>
<td class="fielddoc">
<p>format of the attribute and any prefixes, <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a774449778766552963604a347c739e38">LY_VALUE_XML</a> or <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a29083ced1303da2d7b4000492b53e345" name="a29083ced1303da2d7b4000492b53e345"></a>uint32_t</td>
<td class="fieldname">
hints</td>
<td class="fielddoc">
<p>additional information about from the data source, see the <a class="el" href="group__lydhints.html">hints list</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9f8aa2dca02e77e68d837d3f99596e6f" name="a9f8aa2dca02e77e68d837d3f99596e6f"></a>struct <a class="el" href="#structly__opaq__name">ly_opaq_name</a></td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>attribute name with module information </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adae1bc76b188c4f0b3b289c234ef0b80" name="adae1bc76b188c4f0b3b289c234ef0b80"></a>struct <a class="el" href="#structlyd__attr">lyd_attr</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next attribute </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeb50625e2776058a0d6428da0925d653" name="aeb50625e2776058a0d6428da0925d653"></a>struct <a class="el" href="#structlyd__node__opaq">lyd_node_opaq</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>data node where the attribute is placed </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa99828f9420ea50d64ed05daf0fa7cd1" name="aa99828f9420ea50d64ed05daf0fa7cd1"></a>void *</td>
<td class="fieldname">
val_prefix_data</td>
<td class="fielddoc">
<p>format-specific prefix data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad283133f5edeef9d79e59d066b35f313" name="ad283133f5edeef9d79e59d066b35f313"></a>const char *</td>
<td class="fieldname">
value</td>
<td class="fielddoc">
<p>attribute value </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node" id="structlyd__node"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node">&#9670;&#160;</a></span>lyd_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Generic structure for a data node. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00781">781</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a645978149e28429e69e25870edf44668" name="a645978149e28429e69e25870edf44668"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p><a class="el" href="group__dnodeflags.html">data node flags</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa955e0591de77c5656b09a89ea6541e9" name="aa955e0591de77c5656b09a89ea6541e9"></a>uint32_t</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>hash of this particular node (module name + schema name + key string values if list or hashes of all nodes of subtree in case of keyless list). Note that while hash can be used to get know that nodes are not equal, it cannot be used to decide that the nodes are equal due to possible collisions. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5f9a2d3ff1dd90715decfe685be79b08" name="a5f9a2d3ff1dd90715decfe685be79b08"></a>struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>
<td class="fieldname">
meta</td>
<td class="fielddoc">
<p>pointer to the list of metadata of this node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a03f06495fb93b1c02fca2ed276eb2151" name="a03f06495fb93b1c02fca2ed276eb2151"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next sibling node (NULL if there is no one) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af250a68c404635c991d49a9d33f9d0d3" name="af250a68c404635c991d49a9d33f9d0d3"></a>struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>pointer to the parent node, NULL in case of root node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab0ce94f85cd251dae2cef1b546c2fc70" name="ab0ce94f85cd251dae2cef1b546c2fc70"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>pointer to the previous sibling node </p><dl class="section note"><dt>Note</dt><dd>Note that this pointer is never NULL. If there is no sibling node, pointer points to the node itself. In case of the first node, this pointer points to the last node in the list. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="abe486aa9f1efe0770792089de0604879" name="abe486aa9f1efe0770792089de0604879"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
<p>private user data, not used by libyang </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6f471e7e4556c269ef15b018a045d371" name="a6f471e7e4556c269ef15b018a045d371"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
schema</td>
<td class="fielddoc">
<p>pointer to the schema definition of this node </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__any" id="structlyd__node__any"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__any">&#9670;&#160;</a></span>lyd_node_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_any</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data node structure for the anydata data tree nodes - anydata or anyxml. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00874">874</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="afb964a3c992c59823c6b728ed4a4cb1c" name="afb964a3c992c59823c6b728ed4a4cb1c"></a>union <a class="el" href="#unionlyd__node__any_8____unnamed15____">lyd_node_any.__unnamed15__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
<p>common part corresponding to <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad943e779d70f3282104dc97eb1ac0837" name="ad943e779d70f3282104dc97eb1ac0837"></a>union <a class="el" href="#unionlyd__any__value">lyd_any_value</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
<p>pointer to the stored value representation of the anydata/anyxml node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2ba82ba3b691a95bd3f05f0e295561dd" name="a2ba82ba3b691a95bd3f05f0e295561dd"></a><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a></td>
<td class="fieldname">
value_type</td>
<td class="fielddoc">
<p>type of the data stored as <a class="el" href="#ad943e779d70f3282104dc97eb1ac0837">lyd_node_any.value</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__node__any_8____unnamed15____" id="unionlyd__node__any_8____unnamed15____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__node__any_8____unnamed15____">&#9670;&#160;</a></span>lyd_node_any.__unnamed15__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_node_any.__unnamed15__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00875">875</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a522dbf5f367e0a96a94135f388be7754" name="a522dbf5f367e0a96a94135f388be7754"></a>struct <a class="el" href="#structlyd__node__any_8____unnamed15_____8____unnamed17____">lyd_node_any.__unnamed15__.__unnamed17__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a36c4536996ca5615dcf9911f068786dc" name="a36c4536996ca5615dcf9911f068786dc"></a>struct <a class="el" href="#structlyd__node">lyd_node</a></td>
<td class="fieldname">
node</td>
<td class="fielddoc">
<p>implicit cast for the members compatible with <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__any_8____unnamed15_____8____unnamed17____" id="structlyd__node__any_8____unnamed15_____8____unnamed17____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__any_8____unnamed15_____8____unnamed17____">&#9670;&#160;</a></span>lyd_node_any.__unnamed15__.__unnamed17__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_any.__unnamed15__.__unnamed17__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00878">878</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4e5868d676cb634aa75b125a0f741abf" name="a4e5868d676cb634aa75b125a0f741abf"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p><a class="el" href="group__dnodeflags.html">data node flags</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0800fc577294c34e0b28ad2839435945" name="a0800fc577294c34e0b28ad2839435945"></a>uint32_t</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>hash of this particular node (module name + schema name + key string values if list or hashes of all nodes of subtree in case of keyless list). Note that while hash can be used to get know that nodes are not equal, it cannot be used to decide that the nodes are equal due to possible collisions. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9a23cbc455158951716b440c3d165e0" name="ae9a23cbc455158951716b440c3d165e0"></a>struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>
<td class="fieldname">
meta</td>
<td class="fielddoc">
<p>pointer to the list of metadata of this node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0cab90d8d20d57e2f2b9be52f7dd25d" name="ad0cab90d8d20d57e2f2b9be52f7dd25d"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next sibling node (NULL if there is no one) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0e45878043844ffc41aac437e86b602" name="ad0e45878043844ffc41aac437e86b602"></a>struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>pointer to the parent node, NULL in case of root node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afcb08b164ac83e09964deb24f2d2e80b" name="afcb08b164ac83e09964deb24f2d2e80b"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>pointer to the previous sibling node </p><dl class="section note"><dt>Note</dt><dd>Note that this pointer is never NULL. If there is no sibling node, pointer points to the node itself. In case of the first node, this pointer points to the last node in the list. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a908b453051b556e053731714a5193921" name="a908b453051b556e053731714a5193921"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
<p>private user data, not used by libyang </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9550d5fad73447fc24ba47f95d1c6b7" name="ac9550d5fad73447fc24ba47f95d1c6b7"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
schema</td>
<td class="fielddoc">
<p>pointer to the schema definition of this node </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__inner" id="structlyd__node__inner"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__inner">&#9670;&#160;</a></span>lyd_node_inner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_inner</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data node structure for the inner data tree nodes - containers, lists, RPCs, actions and Notifications. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00801">801</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a693f1d44bb4943d9d39535629184ff37" name="a693f1d44bb4943d9d39535629184ff37"></a>union <a class="el" href="#unionlyd__node__inner_8____unnamed7____">lyd_node_inner.__unnamed7__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
<p>common part corresponding to <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aba92c070380065af76c2df6f8b6736e4" name="aba92c070380065af76c2df6f8b6736e4"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
child</td>
<td class="fielddoc">
<p>pointer to the first child node. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="accfbb665901cd0c44396e0ef212ce446" name="accfbb665901cd0c44396e0ef212ce446"></a>struct <a class="el" href="namespace_3global_scope_4.html#structly__ht">ly_ht</a> *</td>
<td class="fieldname">
children_ht</td>
<td class="fielddoc">
<p>hash table with all the direct children (except keys for a list, lists without keys) </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__node__inner_8____unnamed7____" id="unionlyd__node__inner_8____unnamed7____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__node__inner_8____unnamed7____">&#9670;&#160;</a></span>lyd_node_inner.__unnamed7__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_node_inner.__unnamed7__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00802">802</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abdca477a0c8312f3fd1c917c21d567cb" name="abdca477a0c8312f3fd1c917c21d567cb"></a>struct <a class="el" href="#structlyd__node__inner_8____unnamed7_____8____unnamed9____">lyd_node_inner.__unnamed7__.__unnamed9__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a36c4536996ca5615dcf9911f068786dc" name="a36c4536996ca5615dcf9911f068786dc"></a>struct <a class="el" href="#structlyd__node">lyd_node</a></td>
<td class="fieldname">
node</td>
<td class="fielddoc">
<p>implicit cast for the members compatible with <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__inner_8____unnamed7_____8____unnamed9____" id="structlyd__node__inner_8____unnamed7_____8____unnamed9____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__inner_8____unnamed7_____8____unnamed9____">&#9670;&#160;</a></span>lyd_node_inner.__unnamed7__.__unnamed9__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_inner.__unnamed7__.__unnamed9__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00805">805</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4e5868d676cb634aa75b125a0f741abf" name="a4e5868d676cb634aa75b125a0f741abf"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p><a class="el" href="group__dnodeflags.html">data node flags</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0800fc577294c34e0b28ad2839435945" name="a0800fc577294c34e0b28ad2839435945"></a>uint32_t</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>hash of this particular node (module name + schema name + key string values if list or hashes of all nodes of subtree in case of keyless list). Note that while hash can be used to get know that nodes are not equal, it cannot be used to decide that the nodes are equal due to possible collisions. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9a23cbc455158951716b440c3d165e0" name="ae9a23cbc455158951716b440c3d165e0"></a>struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>
<td class="fieldname">
meta</td>
<td class="fielddoc">
<p>pointer to the list of metadata of this node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0cab90d8d20d57e2f2b9be52f7dd25d" name="ad0cab90d8d20d57e2f2b9be52f7dd25d"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next sibling node (NULL if there is no one) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0e45878043844ffc41aac437e86b602" name="ad0e45878043844ffc41aac437e86b602"></a>struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>pointer to the parent node, NULL in case of root node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afcb08b164ac83e09964deb24f2d2e80b" name="afcb08b164ac83e09964deb24f2d2e80b"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>pointer to the previous sibling node </p><dl class="section note"><dt>Note</dt><dd>Note that this pointer is never NULL. If there is no sibling node, pointer points to the node itself. In case of the first node, this pointer points to the last node in the list. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a908b453051b556e053731714a5193921" name="a908b453051b556e053731714a5193921"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
<p>private user data, not used by libyang </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9550d5fad73447fc24ba47f95d1c6b7" name="ac9550d5fad73447fc24ba47f95d1c6b7"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
schema</td>
<td class="fielddoc">
<p>pointer to the schema definition of this node </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__opaq" id="structlyd__node__opaq"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__opaq">&#9670;&#160;</a></span>lyd_node_opaq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_opaq</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data node structure for unparsed (opaque) nodes. </p>
<p>lydhints </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00969">969</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1279a1ef4638e4d14d5a1959e63f6706" name="a1279a1ef4638e4d14d5a1959e63f6706"></a>union <a class="el" href="#unionlyd__node__opaq_8____unnamed19____">lyd_node_opaq.__unnamed19__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
<p>common part corresponding to <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2fbcbabb9fc47a59b37829347252e15d" name="a2fbcbabb9fc47a59b37829347252e15d"></a>struct <a class="el" href="#structlyd__attr">lyd_attr</a> *</td>
<td class="fieldname">
attr</td>
<td class="fielddoc">
<p>pointer to the list of generic attributes of this node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3db7c6f344074107b92ee2cab8ca1eba" name="a3db7c6f344074107b92ee2cab8ca1eba"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
child</td>
<td class="fielddoc">
<p>pointer to the child node (compatible with <a class="el" href="#structlyd__node__inner" title="Data node structure for the inner data tree nodes - containers, lists, RPCs, actions and Notification...">lyd_node_inner</a>) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a49faa8550932f58d179c8ac6667e98e6" name="a49faa8550932f58d179c8ac6667e98e6"></a>const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>
<td class="fieldname">
ctx</td>
<td class="fielddoc">
<p>libyang context </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acd81e67a1fca3bf2970ab8865ff376b1" name="acd81e67a1fca3bf2970ab8865ff376b1"></a><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>
<td class="fieldname">
format</td>
<td class="fielddoc">
<p>format of the node and any prefixes, <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a774449778766552963604a347c739e38">LY_VALUE_XML</a> or <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a925bc4252f13cdb5bf4931b2bb2686ea" name="a925bc4252f13cdb5bf4931b2bb2686ea"></a>uint32_t</td>
<td class="fieldname">
hints</td>
<td class="fielddoc">
<p>additional information about from the data source, see the <a class="el" href="group__lydhints.html">hints list</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af29c2f6b24ea8df3a3908bf1097a187b" name="af29c2f6b24ea8df3a3908bf1097a187b"></a>struct <a class="el" href="#structly__opaq__name">ly_opaq_name</a></td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>node name with module information </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a09fc3ebdd29da4b48ae921740dec133b" name="a09fc3ebdd29da4b48ae921740dec133b"></a>void *</td>
<td class="fieldname">
val_prefix_data</td>
<td class="fielddoc">
<p>format-specific prefix data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a767a5ec8d8dc1efa8b355000f2bc5579" name="a767a5ec8d8dc1efa8b355000f2bc5579"></a>const char *</td>
<td class="fieldname">
value</td>
<td class="fielddoc">
<p>original value </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__node__opaq_8____unnamed19____" id="unionlyd__node__opaq_8____unnamed19____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__node__opaq_8____unnamed19____">&#9670;&#160;</a></span>lyd_node_opaq.__unnamed19__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_node_opaq.__unnamed19__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00970">970</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae8c598c9d0f2e3a9d2fb6a01ccfb4276" name="ae8c598c9d0f2e3a9d2fb6a01ccfb4276"></a>struct <a class="el" href="#structlyd__node__opaq_8____unnamed19_____8____unnamed21____">lyd_node_opaq.__unnamed19__.__unnamed21__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a36c4536996ca5615dcf9911f068786dc" name="a36c4536996ca5615dcf9911f068786dc"></a>struct <a class="el" href="#structlyd__node">lyd_node</a></td>
<td class="fieldname">
node</td>
<td class="fielddoc">
<p>implicit cast for the members compatible with <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__opaq_8____unnamed19_____8____unnamed21____" id="structlyd__node__opaq_8____unnamed19_____8____unnamed21____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__opaq_8____unnamed19_____8____unnamed21____">&#9670;&#160;</a></span>lyd_node_opaq.__unnamed19__.__unnamed21__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_opaq.__unnamed19__.__unnamed21__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00973">973</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4e5868d676cb634aa75b125a0f741abf" name="a4e5868d676cb634aa75b125a0f741abf"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p>always 0 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0800fc577294c34e0b28ad2839435945" name="a0800fc577294c34e0b28ad2839435945"></a>uint32_t</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>always 0 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9a23cbc455158951716b440c3d165e0" name="ae9a23cbc455158951716b440c3d165e0"></a>struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>
<td class="fieldname">
meta</td>
<td class="fielddoc">
<p>always NULL </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0cab90d8d20d57e2f2b9be52f7dd25d" name="ad0cab90d8d20d57e2f2b9be52f7dd25d"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next sibling node (NULL if there is no one) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0e45878043844ffc41aac437e86b602" name="ad0e45878043844ffc41aac437e86b602"></a>struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>pointer to the parent node, NULL in case of root node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afcb08b164ac83e09964deb24f2d2e80b" name="afcb08b164ac83e09964deb24f2d2e80b"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>pointer to the previous sibling node </p><dl class="section note"><dt>Note</dt><dd>Note that this pointer is never NULL. If there is no sibling node, pointer points to the node itself. In case of the first node, this pointer points to the last node in the list. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a908b453051b556e053731714a5193921" name="a908b453051b556e053731714a5193921"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
<p>private user data, not used by libyang </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9550d5fad73447fc24ba47f95d1c6b7" name="ac9550d5fad73447fc24ba47f95d1c6b7"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
schema</td>
<td class="fielddoc">
<p>always NULL </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__term" id="structlyd__node__term"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__term">&#9670;&#160;</a></span>lyd_node_term</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_term</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data node structure for the terminal data tree nodes - leaves and leaf-lists. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00833">833</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a565806d928cc0a2a682ad722daa444e1" name="a565806d928cc0a2a682ad722daa444e1"></a>union <a class="el" href="#unionlyd__node__term_8____unnamed11____">lyd_node_term.__unnamed11__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
<p>common part corresponding to <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1fa70fba454ff72146eee98bc83751af" name="a1fa70fba454ff72146eee98bc83751af"></a>struct <a class="el" href="#structlyd__value">lyd_value</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
<p>node's value representation </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__node__term_8____unnamed11____" id="unionlyd__node__term_8____unnamed11____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__node__term_8____unnamed11____">&#9670;&#160;</a></span>lyd_node_term.__unnamed11__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_node_term.__unnamed11__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00834">834</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abdf416144f79b0adea50b8078e2b2c7f" name="abdf416144f79b0adea50b8078e2b2c7f"></a>struct <a class="el" href="#structlyd__node__term_8____unnamed11_____8____unnamed13____">lyd_node_term.__unnamed11__.__unnamed13__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a36c4536996ca5615dcf9911f068786dc" name="a36c4536996ca5615dcf9911f068786dc"></a>struct <a class="el" href="#structlyd__node">lyd_node</a></td>
<td class="fieldname">
node</td>
<td class="fielddoc">
<p>implicit cast for the members compatible with <a class="el" href="#structlyd__node" title="Generic structure for a data node.">lyd_node</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__node__term_8____unnamed11_____8____unnamed13____" id="structlyd__node__term_8____unnamed11_____8____unnamed13____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__node__term_8____unnamed11_____8____unnamed13____">&#9670;&#160;</a></span>lyd_node_term.__unnamed11__.__unnamed13__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_node_term.__unnamed11__.__unnamed13__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00837">837</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4e5868d676cb634aa75b125a0f741abf" name="a4e5868d676cb634aa75b125a0f741abf"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p><a class="el" href="group__dnodeflags.html">data node flags</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0800fc577294c34e0b28ad2839435945" name="a0800fc577294c34e0b28ad2839435945"></a>uint32_t</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>hash of this particular node (module name + schema name + key string values if list or hashes of all nodes of subtree in case of keyless list). Note that while hash can be used to get know that nodes are not equal, it cannot be used to decide that the nodes are equal due to possible collisions. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9a23cbc455158951716b440c3d165e0" name="ae9a23cbc455158951716b440c3d165e0"></a>struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>
<td class="fieldname">
meta</td>
<td class="fielddoc">
<p>pointer to the list of metadata of this node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0cab90d8d20d57e2f2b9be52f7dd25d" name="ad0cab90d8d20d57e2f2b9be52f7dd25d"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>pointer to the next sibling node (NULL if there is no one) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0e45878043844ffc41aac437e86b602" name="ad0e45878043844ffc41aac437e86b602"></a>struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>
<td class="fieldname">
parent</td>
<td class="fielddoc">
<p>pointer to the parent node, NULL in case of root node </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afcb08b164ac83e09964deb24f2d2e80b" name="afcb08b164ac83e09964deb24f2d2e80b"></a>struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>pointer to the previous sibling node </p><dl class="section note"><dt>Note</dt><dd>Note that this pointer is never NULL. If there is no sibling node, pointer points to the node itself. In case of the first node, this pointer points to the last node in the list. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a908b453051b556e053731714a5193921" name="a908b453051b556e053731714a5193921"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
<p>private user data, not used by libyang </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9550d5fad73447fc24ba47f95d1c6b7" name="ac9550d5fad73447fc24ba47f95d1c6b7"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
schema</td>
<td class="fielddoc">
<p>pointer to the schema definition of this node </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value" id="structlyd__value"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value">&#9670;&#160;</a></span>lyd_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>YANG data representation. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00560">560</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a50d27afc882f2b01233814aba367d0f8" name="a50d27afc882f2b01233814aba367d0f8"></a>union <a class="el" href="#unionlyd__value_8____unnamed3____">lyd_value.__unnamed3__</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
<p>The union is just a list of shorthands to possible values stored by a type's plugin. libyang itself uses the <a class="el" href="#a222333222e4d0f8b53e99c00e46cb3f4">lyd_value.realtype</a> plugin's callbacks to work with the data. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeb325cb6a5ece5afc90b51d78e622d55" name="aeb325cb6a5ece5afc90b51d78e622d55"></a>const char *</td>
<td class="fieldname">
_canonical</td>
<td class="fielddoc">
<p>Should never be accessed directly, instead <a class="el" href="#abae2eeb0a95272274c72702899e864ba" title="Get the (canonical) value of a data node.">lyd_get_value()</a> and lyd_get_meta_value() should be used. Serves as a cache for the canonical value or the JSON representation if no canonical value is defined. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a222333222e4d0f8b53e99c00e46cb3f4" name="a222333222e4d0f8b53e99c00e46cb3f4"></a>const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> *</td>
<td class="fieldname">
realtype</td>
<td class="fielddoc">
<p>pointer to the real type of the data stored in the value structure. This type can differ from the type in the schema node of the data node since the type's store plugin can use other types/plugins for storing data. Speaking about built-in types, this is the case of leafref which stores data as its target type. In contrast, union type also uses its subtype's callbacks, but inside an internal data stored in subvalue member of <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure, so here is the pointer to the union type. In general, this type is used to get free callback for this <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure, so it must reflect the type used to store data directly in the same <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> instance. </p>
</td></tr>
</table>

</div>
</div>
<a name="unionlyd__value_8____unnamed3____" id="unionlyd__value_8____unnamed3____"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionlyd__value_8____unnamed3____">&#9670;&#160;</a></span>lyd_value.__unnamed3__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union lyd_value.__unnamed3__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00572">572</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a84e2c64f38f78ba3ea5c905ab5a2da27" name="a84e2c64f38f78ba3ea5c905ab5a2da27"></a>int8_t</td>
<td class="fieldname">
boolean</td>
<td class="fielddoc">
<p>0 as false, 1 as true </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab5fbc82e6cdcd3d7a3d4be37e412a200" name="ab5fbc82e6cdcd3d7a3d4be37e412a200"></a>int64_t</td>
<td class="fieldname">
dec64</td>
<td class="fielddoc">
<p>decimal64: value = dec64 / 10^fraction-digits <br  />
 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0f1d5fd1a77ba40ea158b88d3033c489" name="a0f1d5fd1a77ba40ea158b88d3033c489"></a>void *</td>
<td class="fieldname">
dyn_mem</td>
<td class="fielddoc">
<p>Union value with some metadata. pointer to generic data type value stored in dynamic memory </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad1ef70398d8c651cf274a8bdeb370104" name="ad1ef70398d8c651cf274a8bdeb370104"></a>struct <a class="el" href="group__schematree.html#structlysc__type__bitenum__item">lysc_type_bitenum_item</a> *</td>
<td class="fieldname">
enum_item</td>
<td class="fielddoc">
<p>pointer to the definition of the enumeration value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5b08fa0eb9bc028b46da7a7240d7a3e6" name="a5b08fa0eb9bc028b46da7a7240d7a3e6"></a>uint8_t</td>
<td class="fieldname">
fixed_mem[LYD_VALUE_FIXED_MEM_SIZE]</td>
<td class="fielddoc">
<p>fixed-size buffer for a generic data type value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a67217d8b401cf5e72bbf5103d60f3e97" name="a67217d8b401cf5e72bbf5103d60f3e97"></a>struct <a class="el" href="group__schematree.html#structlysc__ident">lysc_ident</a> *</td>
<td class="fieldname">
ident</td>
<td class="fielddoc">
<p>pointer to the schema definition of the identityref value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ace80d5ec65b1d2a2f1049eadc100db23" name="ace80d5ec65b1d2a2f1049eadc100db23"></a>int16_t</td>
<td class="fieldname">
int16</td>
<td class="fielddoc">
<p>16-bit signed integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0241adbbd83925f051b694d40f02747f" name="a0241adbbd83925f051b694d40f02747f"></a>int32_t</td>
<td class="fieldname">
int32</td>
<td class="fielddoc">
<p>32-bit signed integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aff9b3f96d37353c528517bc3656a00a8" name="aff9b3f96d37353c528517bc3656a00a8"></a>int64_t</td>
<td class="fieldname">
int64</td>
<td class="fielddoc">
<p>64-bit signed integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a27c006cc56b1ba88f960cf8b5144fcac" name="a27c006cc56b1ba88f960cf8b5144fcac"></a>int8_t</td>
<td class="fieldname">
int8</td>
<td class="fielddoc">
<p>8-bit signed integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acb613097832956695054609d19b4578c" name="acb613097832956695054609d19b4578c"></a>struct <a class="el" href="#structlyd__value__union">lyd_value_union</a> *</td>
<td class="fieldname">
subvalue</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a42aefbae01d2dfd981f7da7d823d689e" name="a42aefbae01d2dfd981f7da7d823d689e"></a>struct ly_path *</td>
<td class="fieldname">
target</td>
<td class="fielddoc">
<p>Instance-identifier target path, use <a class="el" href="#a1b699a792ef534e0326e09c4ac457e90" title="Find the target node of a compiled path (lyd_value instance-identifier).">lyd_find_target()</a> to evaluate it on data. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa00ef2ef85ff67b7b39339886f19044f" name="aa00ef2ef85ff67b7b39339886f19044f"></a>uint16_t</td>
<td class="fieldname">
uint16</td>
<td class="fielddoc">
<p>16-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3de84ad0700f2a1571f633d399e1900e" name="a3de84ad0700f2a1571f633d399e1900e"></a>uint32_t</td>
<td class="fieldname">
uint32</td>
<td class="fielddoc">
<p>32-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2e8d31865e5d4b9d8611e1b991baed07" name="a2e8d31865e5d4b9d8611e1b991baed07"></a>uint64_t</td>
<td class="fieldname">
uint64</td>
<td class="fielddoc">
<p>64-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5f423e669d0a8f4ab7c4c3e6da27161a" name="a5f423e669d0a8f4ab7c4c3e6da27161a"></a>uint8_t</td>
<td class="fieldname">
uint8</td>
<td class="fielddoc">
<p>8-bit unsigned integer </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__binary" id="structlyd__value__binary"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__binary">&#9670;&#160;</a></span>lyd_value_binary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_binary</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in binary values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00642">642</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3ef0322cb86dbdd53dd3b9fa62deffe7" name="a3ef0322cb86dbdd53dd3b9fa62deffe7"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>pointer to the binary value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6cd1cc41bcacd7570201aec5d3b7f737" name="a6cd1cc41bcacd7570201aec5d3b7f737"></a>size_t</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
<p>size of <code>data</code> value in bytes </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__bits" id="structlyd__value__bits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__bits">&#9670;&#160;</a></span>lyd_value_bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_bits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in bits values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00631">631</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aca3124cf3402038254179272f66db220" name="aca3124cf3402038254179272f66db220"></a>char *</td>
<td class="fieldname">
bitmap</td>
<td class="fielddoc">
<p>bitmap of size <a class="el" href="group__plugins_types.html#gacf5894e4cc96952d84d75cf11b4e2870" title="Get the bitmap size of a bits value bitmap.">lyplg_type_bits_bitmap_size()</a>, if its value is cast to an integer type of the corresponding size, can be used directly as a bitmap </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4710637655de52204c133b8f1c006ab5" name="a4710637655de52204c133b8f1c006ab5"></a>struct <a class="el" href="group__schematree.html#structlysc__type__bitenum__item">lysc_type_bitenum_item</a> **</td>
<td class="fieldname">
items</td>
<td class="fielddoc">
<p>list of set pointers to the specification of the set bits (<a class="el" href="howto_structures.html#sizedarrays">sized array</a>) </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__date__and__time" id="structlyd__value__date__and__time"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__date__and__time">&#9670;&#160;</a></span>lyd_value_date_and_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_date_and_time</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-yang-types date-and-time values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00696">696</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae138d98516274f450b1c162ae7dd1a1a" name="ae138d98516274f450b1c162ae7dd1a1a"></a>char *</td>
<td class="fieldname">
fractions_s</td>
<td class="fielddoc">
<p>Optional fractions of a second </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a88171be3d1949ba03b4a4290db7a1479" name="a88171be3d1949ba03b4a4290db7a1479"></a>time_t</td>
<td class="fieldname">
time</td>
<td class="fielddoc">
<p>UNIX timestamp </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6d1e13be8c5b6b9299a859814a078439" name="a6d1e13be8c5b6b9299a859814a078439"></a><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>
<td class="fieldname">
unknown_tz</td>
<td class="fielddoc">
<p>Whether the value is in the special -00:00 timezone. </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv4__address" id="structlyd__value__ipv4__address"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv4__address">&#9670;&#160;</a></span>lyd_value_ipv4_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv4_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-address values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00657">657</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a15e1c1ef8f30b1eb3f6136e661b0bd92" name="a15e1c1ef8f30b1eb3f6136e661b0bd92"></a>struct in_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv4 address in binary </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa0eab26928ca03e8f4cd915ae8e8738a" name="aa0eab26928ca03e8f4cd915ae8e8738a"></a>const char *</td>
<td class="fieldname">
zone</td>
<td class="fielddoc">
<p>Optional address zone </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv4__address__no__zone" id="structlyd__value__ipv4__address__no__zone"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv4__address__no__zone">&#9670;&#160;</a></span>lyd_value_ipv4_address_no_zone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv4_address_no_zone</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-address-no-zone values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00650">650</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a28a13a16835618a98709cd0304a8419e" name="a28a13a16835618a98709cd0304a8419e"></a>struct in_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv4 address in binary </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv4__prefix" id="structlyd__value__ipv4__prefix"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv4__prefix">&#9670;&#160;</a></span>lyd_value_ipv4_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv4_prefix</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv4-prefix values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00665">665</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aaf245df6bc1e27f31e9ff9be678a5c90" name="aaf245df6bc1e27f31e9ff9be678a5c90"></a>struct in_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv4 host address in binary </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aacbe6650ec5f60419e362aa1975cede7" name="aacbe6650ec5f60419e362aa1975cede7"></a>uint8_t</td>
<td class="fieldname">
prefix</td>
<td class="fielddoc">
<p>prefix length (0 - 32) </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv6__address" id="structlyd__value__ipv6__address"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv6__address">&#9670;&#160;</a></span>lyd_value_ipv6_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv6_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-address values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00680">680</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7193611fb562701e8812c22b8a229acc" name="a7193611fb562701e8812c22b8a229acc"></a>struct in6_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv6 address in binary </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a87919547efef675a12b65aa2a2c5ddd8" name="a87919547efef675a12b65aa2a2c5ddd8"></a>const char *</td>
<td class="fieldname">
zone</td>
<td class="fielddoc">
<p>Optional address zone </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv6__address__no__zone" id="structlyd__value__ipv6__address__no__zone"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv6__address__no__zone">&#9670;&#160;</a></span>lyd_value_ipv6_address_no_zone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv6_address_no_zone</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-address-no-zone values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00673">673</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a79dd8b85e2c9e15500ef81862bc90af0" name="a79dd8b85e2c9e15500ef81862bc90af0"></a>struct in6_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv6 address in binary </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__ipv6__prefix" id="structlyd__value__ipv6__prefix"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__ipv6__prefix">&#9670;&#160;</a></span>lyd_value_ipv6_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_ipv6_prefix</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-inet-types ipv6-prefix values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00688">688</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae45153120263239de0202d825bef20ff" name="ae45153120263239de0202d825bef20ff"></a>struct in6_addr</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
<p>IPv6 host address in binary </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aba71a370d56ac72e3145a12d80515d81" name="aba71a370d56ac72e3145a12d80515d81"></a>uint8_t</td>
<td class="fieldname">
prefix</td>
<td class="fielddoc">
<p>prefix length (0 - 128) </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__union" id="structlyd__value__union"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__union">&#9670;&#160;</a></span>lyd_value_union</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_union</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for built-in union values. </p>
<p>Represents data with multiple types (union). The <a class="el" href="#ae8320c7516fd27db7cacc36c71ec9913">lyd_value_union.value</a> contains representation according to one of the union's types. The <a class="el" href="#a85407549a35c31263e4049368d9ec82c">lyd_value_union.prefix_data</a> provides (possible) mappings from prefixes in the original value to YANG modules. These prefixes are necessary to parse original value to the union's subtypes. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00615">615</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="afdd4b2a51812553d192b64891bbf9d7d" name="afdd4b2a51812553d192b64891bbf9d7d"></a>const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>
<td class="fieldname">
ctx_node</td>
<td class="fielddoc">
<p>Context schema node. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aee26fdd8af4a32d9db877cd5da68c934" name="aee26fdd8af4a32d9db877cd5da68c934"></a><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>
<td class="fieldname">
format</td>
<td class="fielddoc">
<p>Prefix format of the value. However, this information is also used to decide whether a value is valid for the specific format or not on later validations (instance-identifier in XML looks different than in JSON). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adddc88924f4120b98ab76f53e648e44a" name="adddc88924f4120b98ab76f53e648e44a"></a>uint32_t</td>
<td class="fieldname">
hints</td>
<td class="fielddoc">
<p><a class="el" href="group__lydvalhints.html">Value hints</a> from the parser </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae5dcf7079633d438e3b5f7995f4dd75f" name="ae5dcf7079633d438e3b5f7995f4dd75f"></a>size_t</td>
<td class="fieldname">
orig_len</td>
<td class="fielddoc">
<p>Original value length. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a54206ea3a31bf52b4edba267efaaa821" name="a54206ea3a31bf52b4edba267efaaa821"></a>void *</td>
<td class="fieldname">
original</td>
<td class="fielddoc">
<p>Original value. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a85407549a35c31263e4049368d9ec82c" name="a85407549a35c31263e4049368d9ec82c"></a>void *</td>
<td class="fieldname">
prefix_data</td>
<td class="fielddoc">
<p>Format-specific data for prefix resolution (see ly_resolve_prefix()) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae8320c7516fd27db7cacc36c71ec9913" name="ae8320c7516fd27db7cacc36c71ec9913"></a>struct <a class="el" href="#structlyd__value">lyd_value</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
<p>representation of the value according to the selected union's subtype (stored as <a class="el" href="#a222333222e4d0f8b53e99c00e46cb3f4">lyd_value.realtype</a> here) </p>
</td></tr>
</table>

</div>
</div>
<a name="structlyd__value__xpath10" id="structlyd__value__xpath10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlyd__value__xpath10">&#9670;&#160;</a></span>lyd_value_xpath10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lyd_value_xpath10</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Special <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> structure for ietf-yang-types xpath1.0 values. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00705">705</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad4d5008bde82fe29d718cb717f73e0d7" name="ad4d5008bde82fe29d718cb717f73e0d7"></a>const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>
<td class="fieldname">
ctx</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a760637570e690fcc594a9d22be3aa30b" name="a760637570e690fcc594a9d22be3aa30b"></a>struct lyxp_expr *</td>
<td class="fieldname">
exp</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="abdc6db8c292b08b6392cc5189b24fe30" name="abdc6db8c292b08b6392cc5189b24fe30"></a><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>
<td class="fieldname">
format</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aed4e17fdef67a74a9a498ecd6e6320bf" name="aed4e17fdef67a74a9a498ecd6e6320bf"></a>void *</td>
<td class="fieldname">
prefix_data</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a070b9868e6e347825d45e73883f3b2b1" name="a070b9868e6e347825d45e73883f3b2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070b9868e6e347825d45e73883f3b2b1">&#9670;&#160;</a></span>LYD_HT_MIN_ITEMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_HT_MIN_ITEMS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimal number of children to create <a class="el" href="#accfbb665901cd0c44396e0ef212ce446">lyd_node_inner.children_ht</a> hash table. </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00827">827</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="ab155e70f45a64e20ca1270ee92cb5240" name="ab155e70f45a64e20ca1270ee92cb5240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab155e70f45a64e20ca1270ee92cb5240">&#9670;&#160;</a></span>LYD_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_NAME</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((node)-&gt;schema ? (node)-&gt;schema-&gt;name : ((<span class="keyword">struct </span><a class="code hl_struct" href="#structlyd__node__opaq">lyd_node_opaq</a> *)node)-&gt;name.name)</div>
<div class="ttc" id="atree__data_8h_html_structlyd__node__opaq"><div class="ttname"><a href="#structlyd__node__opaq">lyd_node_opaq</a></div><div class="ttdoc">Data node structure for unparsed (opaque) nodes.</div><div class="ttdef"><b>Definition</b> <a href="tree__data_8h_source.html#l00969">tree_data.h:969</a></div></div>
</div><!-- fragment -->
<p>Get the name (associated with) of a data node. Works for opaque nodes as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data node name. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00907">907</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="ac5cb5d2c5eba0e721c356d521126395b" name="ac5cb5d2c5eba0e721c356d521126395b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cb5d2c5eba0e721c356d521126395b">&#9670;&#160;</a></span>LYD_NODE_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_NODE_ANY&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga305ca15bb0627f6b0b0c411fd9979b61">LYS_ANYDATA</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schema nodetype mask for <a class="el" href="#structlyd__node__any" title="Data node structure for the anydata data tree nodes - anydata or anyxml.">lyd_node_any</a> </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00744">744</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="abab43155f05102a20b819651b543a59e" name="abab43155f05102a20b819651b543a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab43155f05102a20b819651b543a59e">&#9670;&#160;</a></span>LYD_NODE_INNER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_NODE_INNER&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga8af68db17d734a8fd08fe765eef5937a">LYS_CONTAINER</a>|<a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>|<a class="el" href="group__schemanodetypes.html#ga4e0d212f3fe9cb3cfb27ce8709d82048">LYS_RPC</a>|<a class="el" href="group__schemanodetypes.html#gac0aff1ca4e3a03895df2c2d0f9c22a1a">LYS_ACTION</a>|<a class="el" href="group__schemanodetypes.html#ga236b4e81a1488cc5943aa43c6faacd51">LYS_NOTIF</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schema nodetype mask for <a class="el" href="#structlyd__node__inner" title="Data node structure for the inner data tree nodes - containers, lists, RPCs, actions and Notification...">lyd_node_inner</a> </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00742">742</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="a8f41da26d9b46168dcf9ee0b8c04ff03" name="a8f41da26d9b46168dcf9ee0b8c04ff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f41da26d9b46168dcf9ee0b8c04ff03">&#9670;&#160;</a></span>LYD_NODE_TERM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_NODE_TERM&#160;&#160;&#160;(<a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a>|<a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schema nodetype mask for <a class="el" href="#structlyd__node__term" title="Data node structure for the terminal data tree nodes - leaves and leaf-lists.">lyd_node_term</a> </p>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00743">743</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="ae0643c4040dd0b6187cac083990d3283" name="ae0643c4040dd0b6187cac083990d3283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0643c4040dd0b6187cac083990d3283">&#9670;&#160;</a></span>LYD_VALUE_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LYD_VALUE_GET</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type_val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<span class="keyword">sizeof</span> *(type_val) &gt; LYD_VALUE_FIXED_MEM_SIZE) \</div>
<div class="line">     ? ((type_val) = (((value)-&gt;dyn_mem))) \</div>
<div class="line">     : ((type_val) = ((<span class="keywordtype">void</span> *)((value)-&gt;fixed_mem))))</div>
</div><!-- fragment -->
<p>Get the value in format specific to the type. </p>
<p>Should be used for any types that do not have their specific representation in the <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> union.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Pointer to the value structure to read from (struct <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> *). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type_val</td><td>Pointer to the type-specific value structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l00603">603</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3a5a21cdedd87df0ed0d5678b97b34b7" name="a3a5a21cdedd87df0ed0d5678b97b34b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5a21cdedd87df0ed0d5678b97b34b7">&#9670;&#160;</a></span>lyd_diff_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyd_diff_cb) (const struct <a class="el" href="#structlyd__node">lyd_node</a> *diff_node, struct <a class="el" href="#structlyd__node">lyd_node</a> *data_node, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for diff nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diff_node</td><td>Diff node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_node</td><td>Matching node in data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l02194">2194</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="a5e5d806e21602f483f336fd929fe8aa6" name="a5e5d806e21602f483f336fd929fe8aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5d806e21602f483f336fd929fe8aa6">&#9670;&#160;</a></span>lyd_merge_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a>(* lyd_merge_cb) (struct <a class="el" href="#structlyd__node">lyd_node</a> *trg_node, const struct <a class="el" href="#structlyd__node">lyd_node</a> *src_node, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for matching merge nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trg_node</td><td>Target data node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_node</td><td>Source data node, is NULL if it was actually duplicated (no target node found) and its copy is <code>trg_node</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l02106">2106</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6c9118acdffb927abef758ed887a6334" name="a6c9118acdffb927abef758ed887a6334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9118acdffb927abef758ed887a6334">&#9670;&#160;</a></span>LY_XPATH_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6c9118acdffb927abef758ed887a6334">LY_XPATH_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XPath result type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c9118acdffb927abef758ed887a6334a2aac9a57577eb7a8b61aed17247a81a7" name="a6c9118acdffb927abef758ed887a6334a2aac9a57577eb7a8b61aed17247a81a7"></a>LY_XPATH_NODE_SET&#160;</td><td class="fielddoc"><p>XPath node set </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9118acdffb927abef758ed887a6334adf99bd991d4c70c0d387fe540bac7580" name="a6c9118acdffb927abef758ed887a6334adf99bd991d4c70c0d387fe540bac7580"></a>LY_XPATH_STRING&#160;</td><td class="fielddoc"><p>XPath string </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9118acdffb927abef758ed887a6334aa8906d6bb05792caf69f5d8ada1bf50a" name="a6c9118acdffb927abef758ed887a6334aa8906d6bb05792caf69f5d8ada1bf50a"></a>LY_XPATH_NUMBER&#160;</td><td class="fielddoc"><p>XPath number </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c9118acdffb927abef758ed887a6334ae2340c63b1c75a12df39f52e5bb31876" name="a6c9118acdffb927abef758ed887a6334ae2340c63b1c75a12df39f52e5bb31876"></a>LY_XPATH_BOOLEAN&#160;</td><td class="fielddoc"><p>XPath boolean </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l02568">2568</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<a id="a1b6ee9ba8cea5395a5913b9a21ec24b0" name="a1b6ee9ba8cea5395a5913b9a21ec24b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">&#9670;&#160;</a></span>LYD_PATH_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">LYD_PATH_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of the different data paths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b6ee9ba8cea5395a5913b9a21ec24b0a767eb7a453fd8ee242b2b22f29a45ed7" name="a1b6ee9ba8cea5395a5913b9a21ec24b0a767eb7a453fd8ee242b2b22f29a45ed7"></a>LYD_PATH_STD&#160;</td><td class="fielddoc"><p>Generic data path used for logging, node searching (<a class="el" href="#a0e7048eaa5c9477cf0373790fa6a0f7f" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath()</a>, <a class="el" href="group__schematree.html#gaba138f6c664abf0be94653f32c89fbff" title="Get a schema node based on the given data path (JSON format, see XPath Addressing).">lys_find_path()</a>) as well as creating new nodes (<a class="el" href="#a164faee35d90e24371b237a0969cf73b" title="Create a new node in the data tree based on a path. If creating anyxml/anydata nodes,...">lyd_new_path()</a>, <a class="el" href="#a1f8d709533cfc82522da20a882dd086b" title="Create a new node in the data tree based on a path. All node types can be created.">lyd_new_path2()</a>, <a class="el" href="#a9319dac303b26b9a29d7ba9f31890eb0" title="Create a new node defined in the given extension instance. In case of anyxml/anydata nodes,...">lyd_new_ext_path()</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b6ee9ba8cea5395a5913b9a21ec24b0a44045afcee86a34cbf3a0b21f05950c3" name="a1b6ee9ba8cea5395a5913b9a21ec24b0a44045afcee86a34cbf3a0b21f05950c3"></a>LYD_PATH_STD_NO_LAST_PRED&#160;</td><td class="fielddoc"><p>Similar to <a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0a767eb7a453fd8ee242b2b22f29a45ed7">LYD_PATH_STD</a> except there is never a predicate on the last node. While it can be used to search for nodes, do not use it to create new data nodes (lists). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="tree__data_8h_source.html#l02325">2325</a> of file <a class="el" href="tree__data_8h_source.html">tree_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a15eb844da46b876af3598bf074fe9b7a" name="a15eb844da46b876af3598bf074fe9b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb844da46b876af3598bf074fe9b7a">&#9670;&#160;</a></span>ly_time_str2time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_time_str2time </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>fractions_s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert date-and-time from string to UNIX timestamp and fractions of a second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Valid string date-and-time value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">time</td><td>UNIX timestamp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fractions_s</td><td>Optional fractions of a second, set to NULL if none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a2895db28f5cc659b3c35a0292080dc2b" name="a2895db28f5cc659b3c35a0292080dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2895db28f5cc659b3c35a0292080dc2b">&#9670;&#160;</a></span>ly_time_str2ts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_time_str2ts </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *</td>          <td class="paramname"><span class="paramname"><em>ts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert date-and-time from string to timespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Valid string date-and-time value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ts</td><td>Timespec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a88ce71c13fd2ada8d187364103893c86" name="a88ce71c13fd2ada8d187364103893c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ce71c13fd2ada8d187364103893c86">&#9670;&#160;</a></span>ly_time_time2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_time_time2str </td>
          <td>(</td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fractions_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert UNIX timestamp and fractions of a second into canonical date-and-time string value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>UNIX timestamp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fractions_s</td><td>Fractions of a second, if any. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>String date-and-time value in the local timezone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a153c607ecdbfc29e130d09e122c4bf4e" name="a153c607ecdbfc29e130d09e122c4bf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153c607ecdbfc29e130d09e122c4bf4e">&#9670;&#160;</a></span>ly_time_ts2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> ly_time_ts2str </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *</td>          <td class="paramname"><span class="paramname"><em>ts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert timespec into date-and-time string value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Timespec. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>String date-and-time value in the local timezone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a21102fec787065530840b0725c0c8c60" name="a21102fec787065530840b0725c0c8c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21102fec787065530840b0725c0c8c60">&#9670;&#160;</a></span>ly_time_tz_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL int ly_time_tz_offset </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current timezone (including DST setting) UTC (GMT) time offset in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>Timezone shift in seconds. </dd></dl>

</div>
</div>
<a id="a83f92021b58144375bf8848f6b0d0005" name="a83f92021b58144375bf8848f6b0d0005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f92021b58144375bf8848f6b0d0005">&#9670;&#160;</a></span>ly_time_tz_offset_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL int ly_time_tz_offset_at </td>
          <td>(</td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UTC (GMT) timezone offset in seconds at a specific timestamp (including DST setting). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Timestamp to get the offset at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timezone shift in seconds. </dd></dl>

</div>
</div>
<a id="a99e9d4064e9668bea11ccd46bad8bd2e" name="a99e9d4064e9668bea11ccd46bad8bd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e9d4064e9668bea11ccd46bad8bd2e">&#9670;&#160;</a></span>lyd_any_copy_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_any_copy_value </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>trg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const union <a class="el" href="#unionlyd__any__value">lyd_any_value</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a></td>          <td class="paramname"><span class="paramname"><em>value_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy anydata value from one node to another. Target value is freed first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trg</td><td>Target node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source value, may be NULL when the target value is only freed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Source value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="afe45ac68fae798a21f56de7ae3438205" name="afe45ac68fae798a21f56de7ae3438205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe45ac68fae798a21f56de7ae3438205">&#9670;&#160;</a></span>lyd_any_value_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_any_value_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>any</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>value_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get anydata string value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">any</td><td>Anyxml/anydata node to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value_str</td><td>String representation of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a2223ce5290db18c8449a70383ab591c5" name="a2223ce5290db18c8449a70383ab591c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2223ce5290db18c8449a70383ab591c5">&#9670;&#160;</a></span>lyd_change_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_change_meta </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a metadata instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meta</td><td>Metadata to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>New value to set, any prefixes are expected in JSON format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if value was changed, </dd>
<dd>
LY_ENOT if the values were equal and no change occurred, </dd>
<dd>
LY_ERR value on other errors. </dd></dl>

</div>
</div>
<a id="a2a3a996de8ea707118845efb469599be" name="a2a3a996de8ea707118845efb469599be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a996de8ea707118845efb469599be">&#9670;&#160;</a></span>lyd_change_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_change_term </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a term (leaf or leaf-list) node to a string value. </p>
<p>Node changed this way is always considered explicitly set, meaning its default flag is always cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>Term node to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>New value to set, any prefixes are expected in JSON format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if value was changed, </dd>
<dd>
LY_EEXIST if value was the same and only the default flag was cleared, </dd>
<dd>
LY_ENOT if the values were equal and no change occurred, </dd>
<dd>
LY_ERR value on other errors. </dd></dl>

</div>
</div>
<a id="ab0411e44c7639e8117f3d4b606809f2d" name="ab0411e44c7639e8117f3d4b606809f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0411e44c7639e8117f3d4b606809f2d">&#9670;&#160;</a></span>lyd_change_term_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_change_term_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a term (leaf or leaf-list) node to a binary value. </p>
<p>Node changed this way is always considered explicitly set, meaning its default flag is always cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>Term node to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>New value to set in binary format (usually a pointer), see <a class="el" href="howto_data_l_y_b.html">LYB Binary Format</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of <code>value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if value was changed, </dd>
<dd>
LY_EEXIST if value was the same and only the default flag was cleared, </dd>
<dd>
LY_ENOT if the values were equal and no change occurred, </dd>
<dd>
LY_ERR value on other errors. </dd></dl>

</div>
</div>
<a id="af8e4e3160e37170ce6908d8bd85f7feb" name="af8e4e3160e37170ce6908d8bd85f7feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e4e3160e37170ce6908d8bd85f7feb">&#9670;&#160;</a></span>lyd_change_term_canon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_change_term_canon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the value of a term (leaf or leaf-list) node to a canonical string value. </p>
<p>Node changed this way is always considered explicitly set, meaning its default flag is always cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>Term node to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>New value to set in canonical (or JSON if no defined) format. If the value is not canonical, it may lead to unexpected behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if value was changed, </dd>
<dd>
LY_EEXIST if value was the same and only the default flag was cleared, </dd>
<dd>
LY_ENOT if the values were equal and no change occurred, </dd>
<dd>
LY_ERR value on other errors. </dd></dl>

</div>
</div>
<a id="afe1dca771b11b89fe1123f4a52fe1db1" name="afe1dca771b11b89fe1123f4a52fe1db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1dca771b11b89fe1123f4a52fe1db1">&#9670;&#160;</a></span>lyd_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> * lyd_child </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the child pointer of a generic data node. </p>
<p>Decides the node's type and in case it has a children list, returns it. Supports even the opaq nodes (<a class="el" href="#structlyd__node__opaq" title="Data node structure for unparsed (opaque) nodes.">lyd_node_opaq</a>).</p>
<p>If you need to skip key children, use <a class="el" href="#a78978bdaafb3f364662b12e54ac29455" title="Get the child pointer of a generic data node but skip its keys in case it is LYS_LIST.">lyd_child_no_keys()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child node (if any) of the <code>node</code>. </dd></dl>

</div>
</div>
<a id="a78978bdaafb3f364662b12e54ac29455" name="a78978bdaafb3f364662b12e54ac29455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78978bdaafb3f364662b12e54ac29455">&#9670;&#160;</a></span>lyd_child_no_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> * lyd_child_no_keys </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the child pointer of a generic data node but skip its keys in case it is <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </p>
<p>Decides the node's type and in case it has a children list, returns it. Supports even the opaq nodes (<a class="el" href="#structlyd__node__opaq" title="Data node structure for unparsed (opaque) nodes.">lyd_node_opaq</a>).</p>
<p>If you need to take key children into account, use <a class="el" href="#afe1dca771b11b89fe1123f4a52fe1db1" title="Get the child pointer of a generic data node.">lyd_child()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first child node (if any) of the <code>node</code>. </dd></dl>

</div>
</div>
<a id="a3eccd0fdbe9ae8a07ea8c9231eaf1478" name="a3eccd0fdbe9ae8a07ea8c9231eaf1478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eccd0fdbe9ae8a07ea8c9231eaf1478">&#9670;&#160;</a></span>lyd_compare_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_compare_meta </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 2 metadata. </p>
<p>If <code>meta1</code> and <code>meta2</code> have different contexts, they are never equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meta1</td><td>First metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meta2</td><td>Second metadata. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if the metadata are equivalent. </dd>
<dd>
LY_ENOT if not. </dd></dl>

</div>
</div>
<a id="a85a6283faa6c4e4a6ad6beb13a697cfa" name="a85a6283faa6c4e4a6ad6beb13a697cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a6283faa6c4e4a6ad6beb13a697cfa">&#9670;&#160;</a></span>lyd_compare_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_compare_siblings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 2 lists of siblings if they are equivalent. </p>
<p>Works correctly even if <code>node1</code> and <code>node2</code> have different contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node1</td><td>The first sibling list to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node2</td><td>The second sibling list to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Various <a class="el" href="group__datacompareoptions.html">Data compare options</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if all the siblings are equivalent. </dd>
<dd>
LY_ENOT if the siblings are not equivalent. </dd></dl>

</div>
</div>
<a id="aa1b09abc2714f03fc9301a72015e6f91" name="aa1b09abc2714f03fc9301a72015e6f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b09abc2714f03fc9301a72015e6f91">&#9670;&#160;</a></span>lyd_compare_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_compare_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 2 data nodes if they are equivalent. </p>
<p>Works correctly even if <code>node1</code> and <code>node2</code> have different contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node1</td><td>The first node to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node2</td><td>The second node to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Various <a class="el" href="group__datacompareoptions.html">Data compare options</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS if the nodes are equivalent. </dd>
<dd>
LY_ENOT if the nodes are not equivalent. </dd></dl>

</div>
</div>
<a id="adb182bb2f409970b96bf84bb47e2facf" name="adb182bb2f409970b96bf84bb47e2facf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb182bb2f409970b96bf84bb47e2facf">&#9670;&#160;</a></span>lyd_diff_apply_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_apply_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the whole diff tree on a data tree. </p>
<p>Details are mentioned in <a class="el" href="#ad26adfbeb4fbf0c6230b43f2ca42f734" title="Apply the whole diff on a data tree but restrict the operation to one module.">lyd_diff_apply_module()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to apply the diff on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff</td><td>Diff to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="ad26adfbeb4fbf0c6230b43f2ca42f734" name="ad26adfbeb4fbf0c6230b43f2ca42f734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26adfbeb4fbf0c6230b43f2ca42f734">&#9670;&#160;</a></span>lyd_diff_apply_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_apply_module </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a></td>          <td class="paramname"><span class="paramname"><em>diff_cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the whole diff on a data tree but restrict the operation to one module. </p>
<p><b>!! Caution !!</b> If applying a diff that was created <b>without</b> the <a class="el" href="group__diffoptions.html#ga12953afb61d1d12e0c288996a0f9f8ab">LYD_DIFF_DEFAULTS</a> flag, there may be some duplicate values created. Unless the resulting tree is validated (and default values thus consolidated), using it further (such as applying another diff) may cause unexpected results or errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to apply the diff on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff</td><td>Diff to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Module, whose diff/data only to consider, NULL for all modules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff_cb</td><td>Optional diff callback that will be called for every changed node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a76137f507cbab61fc6598d517f18e704" name="a76137f507cbab61fc6598d517f18e704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76137f507cbab61fc6598d517f18e704">&#9670;&#160;</a></span>lyd_diff_merge_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_merge_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>src_diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge 2 diffs into each other. </p>
<p>Details are mentioned in <a class="el" href="#a61ce171c3612778614cb88849ab413b4" title="Merge 2 diffs into each other but restrict the operation to one module.">lyd_diff_merge_module()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">diff</td><td>Target diff to merge into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_diff</td><td>Source diff. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__diffmergeoptions.html">Data diff merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a61ce171c3612778614cb88849ab413b4" name="a61ce171c3612778614cb88849ab413b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ce171c3612778614cb88849ab413b4">&#9670;&#160;</a></span>lyd_diff_merge_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_merge_module </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>src_diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a></td>          <td class="paramname"><span class="paramname"><em>diff_cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge 2 diffs into each other but restrict the operation to one module. </p>
<p>The diffs must be possible to be merged, which is guaranteed only if the source diff was created on data that had the target diff applied on them. In other words, this sequence is legal</p>
<p>1) get diff1 from data1 and data2 -&gt; get data11 from apply diff1 on data1 -&gt; get diff2 from data11 and data3 -&gt; -&gt; get data 33 from apply diff2 on data1</p>
<p>and reusing these diffs</p>
<p>2) get diff11 from merge diff1 and diff2 -&gt; get data33 from apply diff11 on data1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">diff</td><td>Target diff to merge into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_diff</td><td>Source diff. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Module, whose diff only to consider, NULL for all modules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff_cb</td><td>Optional diff callback that will be called for every merged node. Param <code>diff_node</code> is the source diff node while <code>data_node</code> is the updated target diff node. In case a whole subtree is added, the callback is called on the root with <code>diff_node</code> being NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__diffmergeoptions.html">Data diff merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="abfae39d6833c6ae0fed54f94ac1d79b0" name="abfae39d6833c6ae0fed54f94ac1d79b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfae39d6833c6ae0fed54f94ac1d79b0">&#9670;&#160;</a></span>lyd_diff_merge_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_merge_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff_first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>diff_parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>src_sibling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3a5a21cdedd87df0ed0d5678b97b34b7">lyd_diff_cb</a></td>          <td class="paramname"><span class="paramname"><em>diff_cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge 2 diff trees into each other. </p>
<p>Details are mentioned in <a class="el" href="#a61ce171c3612778614cb88849ab413b4" title="Merge 2 diffs into each other but restrict the operation to one module.">lyd_diff_merge_module()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">diff_first</td><td>Target diff first sibling to merge into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff_parent</td><td>Target diff parent to merge into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_sibling</td><td>Source diff sibling to merge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diff_cb</td><td>Optional diff callback that will be called for every merged node. Param <code>diff_node</code> is the source diff node while <code>data_node</code> is the updated target diff node. In case a whole subtree is added, the callback is called on the root with <code>diff_node</code> being NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__diffmergeoptions.html">Data diff merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a9bf6b8a2016c2c98efb96c4ae9d45a3f" name="a9bf6b8a2016c2c98efb96c4ae9d45a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf6b8a2016c2c98efb96c4ae9d45a3f">&#9670;&#160;</a></span>lyd_diff_reverse_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_reverse_all </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>src_diff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a diff and make the opposite changes. Meaning change create to delete, delete to create, or move from place A to B to move from B to A and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src_diff</td><td>Diff to reverse. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Reversed diff. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a7fba1149adafb0193fe220b67d9df553" name="a7fba1149adafb0193fe220b67d9df553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fba1149adafb0193fe220b67d9df553">&#9670;&#160;</a></span>lyd_diff_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_siblings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn the differences between 2 data trees including all the following siblings. </p>
<p>Details are mentioned in <a class="el" href="#a425dc8ab821d6d4d37bd9ad33d47256a" title="Learn the differences between 2 data trees.">lyd_diff_tree()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Second data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__diffoptions.html">Data diff options.</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Generated diff, NULL if there are no differences. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a425dc8ab821d6d4d37bd9ad33d47256a" name="a425dc8ab821d6d4d37bd9ad33d47256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425dc8ab821d6d4d37bd9ad33d47256a">&#9670;&#160;</a></span>lyd_diff_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_diff_tree </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn the differences between 2 data trees. </p>
<p>The resulting diff is represented as a data tree with specific metadata from the internal 'yang' module. Most importantly, every node has an effective 'operation' metadata. If there is none defined on the node, it inherits the operation from the nearest parent. Top-level nodes must always have the 'operation' metadata defined. Additional metadata ('orig-default', 'value', 'orig-value', 'key', 'orig-key') are used for storing more information about the value in the first or the second tree.</p>
<p>The diff tree is completely independent on the <code>first</code> and <code>second</code> trees, meaning all the information about the change is stored in the diff and the trees are not needed.</p>
<p><b>!! Caution !!</b> The diff tree should never be validated because it may easily not be valid! For example, when data from one case branch are deleted and data from another branch created - data from both branches are then stored in the diff tree simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Second data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__diffoptions.html">Data diff options.</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Generated diff, NULL if there are no differences. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="ad3b2524a75058c92b1e591101a68c1d7" name="ad3b2524a75058c92b1e591101a68c1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b2524a75058c92b1e591101a68c1d7">&#9670;&#160;</a></span>lyd_dup_meta_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_dup_meta_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meta</td><td>Metadata to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Node where to append the new metadata. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Optional created metadata copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a50a5772d4093bd6657dd754732de3029" name="a50a5772d4093bd6657dd754732de3029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a5772d4093bd6657dd754732de3029">&#9670;&#160;</a></span>lyd_dup_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_dup_siblings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the specified data tree <code>node</code> with any following siblings. Schema references are kept the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node where to connect the duplicated node(s). If set in combination with <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a>, the missing parents' chain is duplicated and connected with <code>parent</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__dupoptions.html">Data duplication options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Optional created copy of the node. Note that in case the parents chain is duplicated for the duplicated node(s) (when <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a> used), the first duplicated node is still returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a3d0b0325116808c47fb3b1f1c73c0bf4" name="a3d0b0325116808c47fb3b1f1c73c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0b0325116808c47fb3b1f1c73c0bf4">&#9670;&#160;</a></span>lyd_dup_siblings_to_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_dup_siblings_to_ctx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>trg_ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the specified data tree <code>node</code> with any following siblings. Schema references are assigned from <code>trg_ctx</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trg_ctx</td><td>Target context for duplicated nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node where to connect the duplicated node(s). If set in combination with <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a>, the missing parents' chain is duplicated and connected with <code>parent</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__dupoptions.html">Data duplication options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Optional created copy of the node. Note that in case the parents chain is duplicated for the duplicated node(s) (when <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a> used), the first duplicated node is still returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="aa7b420e7711b9ed330e938190cca9bd3" name="aa7b420e7711b9ed330e938190cca9bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b420e7711b9ed330e938190cca9bd3">&#9670;&#160;</a></span>lyd_dup_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_dup_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the specified data tree <code>node</code>. Schema references are kept the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node where to connect the duplicated node(s). If set in combination with <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a>, the missing parents' chain is duplicated and connected with <code>parent</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__dupoptions.html">Data duplication options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Optional created copy of the node. Note that in case the parents chain is duplicated for the duplicated node(s) (when <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a> used), the first duplicated node is still returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a46aa6af796933e317203720181673ddf" name="a46aa6af796933e317203720181673ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aa6af796933e317203720181673ddf">&#9670;&#160;</a></span>lyd_dup_single_to_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_dup_single_to_ctx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>trg_ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node__inner">lyd_node_inner</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>dup</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the specified data tree <code>node</code>. Schema references are assigned from <code>trg_ctx</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trg_ctx</td><td>Target context for duplicated nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node where to connect the duplicated node(s). If set in combination with <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a>, the missing parents' chain is duplicated and connected with <code>parent</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options flags, see <a class="el" href="group__dupoptions.html">Data duplication options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dup</td><td>Optional created copy of the node. Note that in case the parents chain is duplicated for the duplicated node(s) (when <a class="el" href="group__dupoptions.html#gae511a2567f88b7c42be7a5d87631efc9">LYD_DUP_WITH_PARENTS</a> used), the first duplicated node is still returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a5479c5688dee021e025d680964a11137" name="a5479c5688dee021e025d680964a11137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5479c5688dee021e025d680964a11137">&#9670;&#160;</a></span>lyd_eval_xpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_eval_xpath </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath on data and return the result converted to boolean. </p>
<p>Optimizations similar as in <a class="el" href="#a0e7048eaa5c9477cf0373790fa6a0f7f" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Expression result converted to boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>result</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="ae18d26abd17c432d863120e121df2ecd" name="ae18d26abd17c432d863120e121df2ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18d26abd17c432d863120e121df2ecd">&#9670;&#160;</a></span>lyd_eval_xpath2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_eval_xpath2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath on data and return the result converted to boolean. </p>
<p>It is <a class="el" href="#a5479c5688dee021e025d680964a11137" title="Evaluate an XPath on data and return the result converted to boolean.">lyd_eval_xpath()</a> with <code>vars</code> added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Expression result converted to boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>result</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="afa8ddd379b2ef76ff5b17a823d3b2ff8" name="afa8ddd379b2ef76ff5b17a823d3b2ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8ddd379b2ef76ff5b17a823d3b2ff8">&#9670;&#160;</a></span>lyd_eval_xpath3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_eval_xpath3 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>cur_mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath on data and return the result converted to boolean. </p>
<p>It is <a class="el" href="#ae18d26abd17c432d863120e121df2ecd" title="Evaluate an XPath on data and return the result converted to boolean.">lyd_eval_xpath2()</a> with <code>format</code> and <code>prefix_data</code> added for special use-cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cur_mod</td><td>Current module of <code>xpath</code>, needed for some kinds of <code>format</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of any prefixes in <code>xpath</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific prefix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Expression result converted to boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>result</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="a43b3bc504338a12802c72c17730d9ed0" name="a43b3bc504338a12802c72c17730d9ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b3bc504338a12802c72c17730d9ed0">&#9670;&#160;</a></span>lyd_eval_xpath4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_eval_xpath4 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>cur_mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6c9118acdffb927abef758ed887a6334">LY_XPATH_TYPE</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>node_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> *</td>          <td class="paramname"><span class="paramname"><em>boolean</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath on data and return the result or convert it first to an expected result type. </p>
<p>Either all return type parameters <code>node_set</code>, <code>string</code>, <code>number</code>, and <code>boolean</code> with <code>ret_type</code> are provided or exactly one of <code>node_set</code>, <code>string</code>, <code>number</code>, and <code>boolean</code> is provided with <code>ret_type</code> being obvious and hence optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node, NULL for the root node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree to evaluate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cur_mod</td><td>Current module of <code>xpath</code>, needed for some kinds of <code>format</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of any prefixes in <code>xpath</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific prefix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>Optional <a class="el" href="howto_structures.html#sizedarrays">sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret_type</td><td>XPath type of the result selecting which of <code>node_set</code>, <code>string</code>, <code>number</code>, and <code>boolean</code> to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node_set</td><td>XPath node set result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">string</td><td>XPath string result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>XPath number result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boolean</td><td>XPath boolean result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="aa53edb144ccb0cb1934548d532d69cdc" name="aa53edb144ccb0cb1934548d532d69cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53edb144ccb0cb1934548d532d69cdc">&#9670;&#160;</a></span>lyd_find_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> * lyd_find_meta </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a specific metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First metadata to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the metadata definition, may be NULL if <code>name</code> includes a prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the metadata to find, may not include a prefix (module name) if <code>module</code> is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found metadata, </dd>
<dd>
NULL if not found. </dd></dl>

</div>
</div>
<a id="a21136839d28e3be50f59c71acb47f9a5" name="a21136839d28e3be50f59c71acb47f9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21136839d28e3be50f59c71acb47f9a5">&#9670;&#160;</a></span>lyd_find_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_path </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in given data for a node uniquely identified by a path. </p>
<p>Always works in constant (<em>O(1)</em>) complexity. To be exact, it is <em>O(n)</em> where <em>n</em> is the depth of the path used.</p>
<p>Opaque nodes are NEVER found/traversed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Path context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><a class="el" href="howto_x_path.html">Path</a> to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Whether to search in RPC/action output nodes or in input nodes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Can be NULL, otherwise the found data node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>match</code> is set to the found node. </dd>
<dd>
LY_EINCOMPLETE if only a parent of the node was found, <code>match</code> is set to this parent node. </dd>
<dd>
LY_ENOTFOUND if no nodes in the path were found. </dd>
<dd>
LY_ERR on other errors. </dd></dl>

</div>
</div>
<a id="a536dbec9e92ebf61ac6a34477e997143" name="a536dbec9e92ebf61ac6a34477e997143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536dbec9e92ebf61ac6a34477e997143">&#9670;&#160;</a></span>lyd_find_sibling_dup_inst_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_sibling_dup_inst_set </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>siblings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given siblings for all the exact same instances of a specific node instance. Uses hashes to whatever extent possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">siblings</td><td>Siblings to search in including preceding and succeeding nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target node instance to find. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>Set with all the found instances. The first item is always the first instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>set</code> returned. </dd>
<dd>
LY_ENOTFOUND if not found, empty <code>set</code> returned. </dd>
<dd>
LY_ERR value if another error occurred. </dd></dl>

</div>
</div>
<a id="a42a45977540ff618d4c129e8a4fb36dd" name="a42a45977540ff618d4c129e8a4fb36dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a45977540ff618d4c129e8a4fb36dd">&#9670;&#160;</a></span>lyd_find_sibling_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_sibling_first </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>siblings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given siblings (NOT recursively) for the first target instance with the same value. Uses hashes - should be used whenever possible for best performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">siblings</td><td>Siblings to search in including preceding and succeeding nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target node to find. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Can be NULL, otherwise the found data node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>match</code> set. </dd>
<dd>
LY_ENOTFOUND if not found, <code>match</code> set to NULL. </dd>
<dd>
LY_ERR value if another error occurred. </dd></dl>

</div>
</div>
<a id="a08f635fdef0eaea66d2977a1f3f01fbb" name="a08f635fdef0eaea66d2977a1f3f01fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f635fdef0eaea66d2977a1f3f01fbb">&#9670;&#160;</a></span>lyd_find_sibling_opaq_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_sibling_opaq_next </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given siblings for an opaque node with a specific name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First sibling to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Opaque node name to find. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Can be NULL, otherwise the found data node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>match</code> set. </dd>
<dd>
LY_ENOTFOUND if not found, <code>match</code> set to NULL. </dd>
<dd>
LY_ERR value is an error occurred. </dd></dl>

</div>
</div>
<a id="a8f65c822293a6c813fae62c343f1ba54" name="a8f65c822293a6c813fae62c343f1ba54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f65c822293a6c813fae62c343f1ba54">&#9670;&#160;</a></span>lyd_find_sibling_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_sibling_val </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>siblings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>schema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key_or_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>val_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given siblings for the first schema instance. Uses hashes - should be used whenever possible for best performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">siblings</td><td>Siblings to search in including preceding and succeeding nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>Schema node of the data node to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_or_value</td><td>If it is NULL, the first schema node data instance is found. For nodes with many instances, it can be set based on the type of <code>schema:</code> LYS_LEAFLIST: Searched instance value. LYS_LIST: Searched instance key values in the form of "[key1='val1'][key2='val2']...". The keys do not have to be ordered but all of them must be set.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that any explicit values (leaf-list or list key values) will be canonized first before comparison. But values that do not have a canonical value are expected to be in the JSON format! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val_len</td><td>Optional length of <code>key_or_value</code> in case it is not 0-terminated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Can be NULL, otherwise the found data node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>match</code> set. </dd>
<dd>
LY_ENOTFOUND if not found, <code>match</code> set to NULL. </dd>
<dd>
LY_EINVAL if <code>schema</code> is a key-less list. </dd>
<dd>
LY_ERR value if another error occurred. </dd></dl>

</div>
</div>
<a id="a1b699a792ef534e0326e09c4ac457e90" name="a1b699a792ef534e0326e09c4ac457e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b699a792ef534e0326e09c4ac457e90">&#9670;&#160;</a></span>lyd_find_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_target </td>
          <td>(</td>
          <td class="paramtype">const struct ly_path *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the target node of a compiled path (<a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a> instance-identifier). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Compiled path structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree to be searched. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Can be NULL, otherwise the found data node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>match</code> is set to the found node. </dd>
<dd>
LY_ENOTFOUND if no match was found. </dd>
<dd>
LY_ERR on other errors. </dd></dl>

</div>
</div>
<a id="a0e7048eaa5c9477cf0373790fa6a0f7f" name="a0e7048eaa5c9477cf0373790fa6a0f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7048eaa5c9477cf0373790fa6a0f7f">&#9670;&#160;</a></span>lyd_find_xpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_xpath </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given data for instances of nodes matching the provided XPath. </p>
<p>If a list instance is being selected with all its key values specified and ordered in the form <code>list[key1=...][key2=...][key3=...]</code> or a leaf-list instance in the form <code>leaf-list[.=...]</code>, these instances are found using hashes with constant (<em>O(1)</em>) complexity (unless they are defined in top-level). Other predicates can still follow the aforementioned ones.</p>
<p>Opaque nodes are part of the evaluation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select in JSON format. It must evaluate into a node set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>Set of found data nodes. In case the result is a number, a string, or a boolean, the returned set is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>set</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="ab4222d1539442779d935b793b45e1705" name="ab4222d1539442779d935b793b45e1705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4222d1539442779d935b793b45e1705">&#9670;&#160;</a></span>lyd_find_xpath2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_xpath2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given data for instances of nodes matching the provided XPath. </p>
<p>It is <a class="el" href="#a0e7048eaa5c9477cf0373790fa6a0f7f" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath()</a> with <code>vars</code> added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select in JSON format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>Set of found data nodes. In case the result is a number, a string, or a boolean, the returned set is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>set</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="ae6c1d7cde0ba664c3ad3ce75ec6432f5" name="ae6c1d7cde0ba664c3ad3ce75ec6432f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c1d7cde0ba664c3ad3ce75ec6432f5">&#9670;&#160;</a></span>lyd_find_xpath3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_xpath3 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given data for instances of nodes matching the provided XPath. </p>
<p>It is <a class="el" href="#ab4222d1539442779d935b793b45e1705" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath2()</a> with <code>tree</code> added so that <code>ctx_node</code> may be the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node, NULL for the root node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree to evaluate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select in JSON format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>Set of found data nodes. In case the result is a number, a string, or a boolean, the returned set is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>set</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="a8214f5c392871a86920eb665356c2c85" name="a8214f5c392871a86920eb665356c2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214f5c392871a86920eb665356c2c85">&#9670;&#160;</a></span>lyd_find_xpath4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_find_xpath4 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__trees.html#ga6d2b8dbf3f39c2b16b9a9d7943dda953">LY_VALUE_FORMAT</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>prefix_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__lyset.html#structly__set">ly_set</a> **</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search in the given data for instances of nodes matching the provided XPath. </p>
<p>It is <a class="el" href="#ae6c1d7cde0ba664c3ad3ce75ec6432f5" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath3()</a> with <code>format</code> and <code>prefix_data</code> added for special use-cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>XPath context node, NULL for the root node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree to evaluate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select with prefix in <code>format</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of any prefixes in <code>xpath</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_data</td><td>Format-specific prefix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>Set of found data nodes. In case the result is a number, a string, or a boolean, the returned set is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, <code>set</code> is returned. </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="a2dd2f5806ae9628be1091a66245ef956" name="a2dd2f5806ae9628be1091a66245ef956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd2f5806ae9628be1091a66245ef956">&#9670;&#160;</a></span>lyd_first_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> * lyd_first_sibling </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first sibling of the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node which first sibling is going to be the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first sibling of the given node or the node itself if it is the first child of the parent. </dd></dl>

</div>
</div>
<a id="a0678ec989c6861afc9d14b77630b4719" name="a0678ec989c6861afc9d14b77630b4719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0678ec989c6861afc9d14b77630b4719">&#9670;&#160;</a></span>lyd_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all the nodes (even parents of the node) in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Any of the nodes inside the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd528ccf51d9f2fb366116453d1ccffb" name="abd528ccf51d9f2fb366116453d1ccffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd528ccf51d9f2fb366116453d1ccffb">&#9670;&#160;</a></span>lyd_free_attr_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_attr_siblings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__attr">lyd_attr</a> *</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the attribute with any following attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where the attributes were created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>First attribute to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acea574f4dbd92833dee7a0ee439817ed" name="acea574f4dbd92833dee7a0ee439817ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea574f4dbd92833dee7a0ee439817ed">&#9670;&#160;</a></span>lyd_free_attr_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_attr_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__attr">lyd_attr</a> *</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a single attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context where the attributes were created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Attribute to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddedd7a41e22fe4a39e2c2067db3e1e" name="a0ddedd7a41e22fe4a39e2c2067db3e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddedd7a41e22fe4a39e2c2067db3e1e">&#9670;&#160;</a></span>lyd_free_meta_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_meta_siblings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the metadata instance with any following instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meta</td><td>Metadata to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af71e80898290ebde33f2d760a5d98e0a" name="af71e80898290ebde33f2d760a5d98e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71e80898290ebde33f2d760a5d98e0a">&#9670;&#160;</a></span>lyd_free_meta_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_meta_single </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> *</td>          <td class="paramname"><span class="paramname"><em>meta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a single metadata instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meta</td><td>Metadata to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754d99a44cfa7f8b2ba9c0e2b9270825" name="a754d99a44cfa7f8b2ba9c0e2b9270825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754d99a44cfa7f8b2ba9c0e2b9270825">&#9670;&#160;</a></span>lyd_free_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_siblings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all the sibling nodes (preceding as well as succeeding). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Any of the sibling nodes to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409465a6286af6f7c68f7f96484967f1" name="a409465a6286af6f7c68f7f96484967f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409465a6286af6f7c68f7f96484967f1">&#9670;&#160;</a></span>lyd_free_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_free_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free (and unlink) the specified data (sub)tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Root of the (sub)tree to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abae2eeb0a95272274c72702899e864ba" name="abae2eeb0a95272274c72702899e864ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae2eeb0a95272274c72702899e864ba">&#9670;&#160;</a></span>lyd_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const char * lyd_get_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (canonical) value of a data node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data node to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonical value. </dd></dl>

</div>
</div>
<a id="a9bf377c2ef890f0ecb05c9d8c4500250" name="a9bf377c2ef890f0ecb05c9d8c4500250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf377c2ef890f0ecb05c9d8c4500250">&#9670;&#160;</a></span>lyd_insert_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_insert_after </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>sibling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node after another node, can be used only for user-ordered nodes. If inserting several siblings, each of them must be inserted individually. </p>
<ul>
<li>if the node is part of some other tree, it is automatically unlinked.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sibling</td><td>Sibling node to insert after. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR error on error. </dd></dl>

</div>
</div>
<a id="a7bd0eb0426da05bc4b65c3cdf79efba6" name="a7bd0eb0426da05bc4b65c3cdf79efba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd0eb0426da05bc4b65c3cdf79efba6">&#9670;&#160;</a></span>lyd_insert_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_insert_before </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>sibling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node before another node, can be used only for user-ordered nodes. If inserting several siblings, each of them must be inserted individually. </p>
<ul>
<li>if the node is part of some other tree, it is automatically unlinked.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sibling</td><td>Sibling node to insert before. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR error on error. </dd></dl>

</div>
</div>
<a id="a2c974e2b6993714fc5ee70ace4c5a654" name="a2c974e2b6993714fc5ee70ace4c5a654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c974e2b6993714fc5ee70ace4c5a654">&#9670;&#160;</a></span>lyd_insert_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_insert_child </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a child into a parent. </p>
<ul>
<li>if the node is part of some other tree, it is automatically unlinked.</li>
<li>if the node is the first node of a node list (with no parent), all the subsequent nodes are also inserted.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node to insert into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR error on error. </dd></dl>

</div>
</div>
<a id="afc790b985c813c804f5a345b8483e7e0" name="afc790b985c813c804f5a345b8483e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc790b985c813c804f5a345b8483e7e0">&#9670;&#160;</a></span>lyd_insert_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_insert_sibling </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>sibling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>first</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node into siblings. </p>
<ul>
<li>if the node is part of some other tree, it is automatically unlinked.</li>
<li>if the node is the first node of a node list (with no parent), all the subsequent nodes are also inserted.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sibling</td><td>Siblings to insert into, can even be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to insert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first</td><td>Optionally return the first sibling after insertion. Can be the address of <code>sibling</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR error on error. </dd></dl>

</div>
</div>
<a id="abf94dd13c544c7be9a49c6d30c1de473" name="abf94dd13c544c7be9a49c6d30c1de473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf94dd13c544c7be9a49c6d30c1de473">&#9670;&#160;</a></span>lyd_is_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a> lyd_is_default </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a node value equals to its default one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Term node to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false (no, it is not a default node) or true (yes, it is default) </dd></dl>

</div>
</div>
<a id="a9a37bce0e3b79294c66b0af09ddbfc59" name="a9a37bce0e3b79294c66b0af09ddbfc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a37bce0e3b79294c66b0af09ddbfc59">&#9670;&#160;</a></span>lyd_list_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL uint32_t lyd_list_pos </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn the relative position of a list or leaf-list instance within other instances of the same schema node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>List or leaf-list instance to get the position of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on error. </dd>
<dd>
Positive integer of the <code>instance</code> position. </dd></dl>

</div>
</div>
<a id="a67d05cffbc8606fd03798ce4ede72eb1" name="a67d05cffbc8606fd03798ce4ede72eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d05cffbc8606fd03798ce4ede72eb1">&#9670;&#160;</a></span>lyd_lyb_data_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL int lyd_lyb_data_length </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn the length of LYB data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>LYB data to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the LYB data chunk, </dd>
<dd>
-1 on error. </dd></dl>

</div>
</div>
<a id="aee582e0be9fee58f1c5ed69e17795ca2" name="aee582e0be9fee58f1c5ed69e17795ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee582e0be9fee58f1c5ed69e17795ca2">&#9670;&#160;</a></span>lyd_merge_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_merge_module </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5e5d806e21602f483f336fd929fe8aa6">lyd_merge_cb</a></td>          <td class="paramname"><span class="paramname"><em>merge_cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge all the nodes of a module from source data tree into the target data tree. Merge may not be complete until validation called on the resulting data tree (data from more cases may be present, default and non-default values). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target</td><td>Target data tree to merge into, must be a top-level tree. Always points to the first sibling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source data tree to merge, must be a top-level tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod</td><td>Module, whose source data only to consider, NULL for all modules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">merge_cb</td><td>Optional merge callback that will be called for every merged node, before merging its descendants. If a subtree is being added into target (no matching node found), callback is called only once with the subtree root. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Arbitrary callback data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of option flags, see <a class="el" href="group__mergeoptions.html">Data merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="a0c306749d40e1334367b14db7f4bfab7" name="a0c306749d40e1334367b14db7f4bfab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c306749d40e1334367b14db7f4bfab7">&#9670;&#160;</a></span>lyd_merge_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_merge_siblings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the source data tree with any following siblings into the target data tree. Merge may not be complete until validation called on the resulting data tree (data from more cases may be present, default and non-default values). </p>
<p>Example input:</p>
<p>source (A1) - A2 - A3 target (B1) - B2 - B3 /\ /\ /\ /\ /\ /\ .... .... .... .... .... ....</p>
<p>result target (A1) - A2 - A3 - B1 - B2 - B3 /\ /\ /\ /\ /\ /\ .... .... .... .... .... ....</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target</td><td>Target data tree to merge into, must be a top-level tree. Always points to the first sibling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source data tree to merge, must be a top-level tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of option flags, see <a class="el" href="group__mergeoptions.html">Data merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="aa71f20040dd280c7ab8049068202fb25" name="aa71f20040dd280c7ab8049068202fb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71f20040dd280c7ab8049068202fb25">&#9670;&#160;</a></span>lyd_merge_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_merge_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the source data subtree into the target data tree. Merge may not be complete until validation is called on the resulting data tree (data from more cases may be present, default and non-default values). </p>
<p>Example input:</p>
<p>source (A1) - A2 - A3 target (B1) - B2 - B3 /\ /\ /\ /\ /\ /\ .... .... .... .... .... ....</p>
<p>result target (A1) - B1 - B2 - B3 /\ /\ /\ /\ .... .... .... ....</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target</td><td>Target data tree to merge into, must be a top-level tree. Always points to the first sibling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source data tree to merge, must be a top-level tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of option flags, see <a class="el" href="group__mergeoptions.html">Data merge options.</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="aaf7104d2de2f2cb3097a2a7dfb1a9956" name="aaf7104d2de2f2cb3097a2a7dfb1a9956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7104d2de2f2cb3097a2a7dfb1a9956">&#9670;&#160;</a></span>lyd_new_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_any </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>use_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a></td>          <td class="paramname"><span class="paramname"><em>value_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new any node in the data tree. </p>
<p>To create a top-level any node defined in an extension instance, use <a class="el" href="#a47fed36624b42c6123c935ab496f7165" title="Create a new top-level any node defined in the given extension instance.">lyd_new_ext_any()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga305ca15bb0627f6b0b0c411fd9979b61">LYS_ANYDATA</a> or <a class="el" href="group__schemanodetypes.html#gae1af310296f552a6c672938e627361e5">LYS_ANYXML</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value for the node. Expected type is determined by <code>value_type</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_value</td><td>Whether to use dynamic <code>value</code> or make a copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Type of the provided value in <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a2c84d9cca4c6f68a8eaa7b184bce2045" name="a2c84d9cca4c6f68a8eaa7b184bce2045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c84d9cca4c6f68a8eaa7b184bce2045">&#9670;&#160;</a></span>lyd_new_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_attr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__attr">lyd_attr</a> **</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new JSON attribute for an opaque data node. To create an XML attribute, use <a class="el" href="#aa7cc4e94963cee8ec1c04813218e266c" title="Create new XML attribute for an opaque data node. To create a JSON attribute, use lyd_new_attr().">lyd_new_attr2()</a>. </p>
<p>Note that for an attribute to be later resolved as YANG metadata, it needs <code>module_nane</code> and a prefix in <code>name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent opaque node for the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_name</td><td>Optional name of the module of the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name with optional prefix, which is a module name. If the prefix is set, it is also stored as the explicit module name if <code>module_name</code> is not set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Optional attribute value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>Optional created attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="aa7cc4e94963cee8ec1c04813218e266c" name="aa7cc4e94963cee8ec1c04813218e266c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cc4e94963cee8ec1c04813218e266c">&#9670;&#160;</a></span>lyd_new_attr2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_attr2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>module_ns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__attr">lyd_attr</a> **</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new XML attribute for an opaque data node. To create a JSON attribute, use <a class="el" href="#a2c84d9cca4c6f68a8eaa7b184bce2045" title="Create new JSON attribute for an opaque data node. To create an XML attribute, use lyd_new_attr2().">lyd_new_attr()</a>. </p>
<p>Note that for an attribute to be later resolved as YANG metadata, it needs <code>module_ns</code> and a prefix in <code>name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent opaque node for the attribute being created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_ns</td><td>Optional namespace of the module of the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name with optional prefix, which is an XML prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Optional attribute value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>Optional created attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a47fed36624b42c6123c935ab496f7165" name="a47fed36624b42c6123c935ab496f7165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fed36624b42c6123c935ab496f7165">&#9670;&#160;</a></span>lyd_new_ext_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_ext_any </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>use_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a></td>          <td class="paramname"><span class="paramname"><em>value_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level any node defined in the given extension instance. </p>
<p>To create an any node with parent (no matter if defined inside extension instance or a standard tree) or a top-level any node of a standard module's tree, use <a class="el" href="#aaf7104d2de2f2cb3097a2a7dfb1a9956" title="Create a new any node in the data tree.">lyd_new_any()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Extension instance where the any node being created is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga305ca15bb0627f6b0b0c411fd9979b61">LYS_ANYDATA</a> or <a class="el" href="group__schemanodetypes.html#gae1af310296f552a6c672938e627361e5">LYS_ANYXML</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value for the node. Expected type is determined by <code>value_type</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_value</td><td>Whether to use dynamic <code>value</code> or make a copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Type of the provided value in <code>value</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>The created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a744293d284c7a9b4b41f6290e1640af3" name="a744293d284c7a9b4b41f6290e1640af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744293d284c7a9b4b41f6290e1640af3">&#9670;&#160;</a></span>lyd_new_ext_inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_ext_inner </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level inner node defined in the given extension instance. </p>
<p>To create list, use <a class="el" href="#a7e61eda8700065c3630e908bd8f82508" title="Create a new list node in the data tree.">lyd_new_list()</a> or <a class="el" href="#a4953b9d68eb4e533f93aeb11d634eeb7" title="Create a new list node in the data tree.">lyd_new_list2()</a>.</p>
<p>To create an inner node with parent (no matter if defined inside extension instance or a standard tree) or a top-level node of a standard module's tree, use <a class="el" href="#ac681e05d82a50293c6cc9cbfad1050de" title="Create a new inner node in the data tree.">lyd_new_inner()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Extension instance where the inner node being created is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga8af68db17d734a8fd08fe765eef5937a">LYS_CONTAINER</a>, <a class="el" href="group__schemanodetypes.html#ga236b4e81a1488cc5943aa43c6faacd51">LYS_NOTIF</a>, <a class="el" href="group__schemanodetypes.html#ga4e0d212f3fe9cb3cfb27ce8709d82048">LYS_RPC</a>, or <a class="el" href="group__schemanodetypes.html#gac0aff1ca4e3a03895df2c2d0f9c22a1a">LYS_ACTION</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>The created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a787e2a95c8187488988055b7d947ef24" name="a787e2a95c8187488988055b7d947ef24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787e2a95c8187488988055b7d947ef24">&#9670;&#160;</a></span>lyd_new_ext_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_ext_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level list node defined in the given extension instance. </p>
<p>To create a list node with parent (no matter if defined inside extension instance or a standard tree) or a top-level list node of a standard module's tree, use <a class="el" href="#a7e61eda8700065c3630e908bd8f82508" title="Create a new list node in the data tree.">lyd_new_list()</a> or <a class="el" href="#a4953b9d68eb4e533f93aeb11d634eeb7" title="Create a new list node in the data tree.">lyd_new_list2()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Extension instance where the list node being created is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>The created node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Ordered key values of the new list instance, all must be set. In case of an instance-identifier or identityref value, the JSON format is expected (module names instead of prefixes). No keys are expected for key-less lists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a9319dac303b26b9a29d7ba9f31890eb0" name="a9319dac303b26b9a29d7ba9f31890eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9319dac303b26b9a29d7ba9f31890eb0">&#9670;&#160;</a></span>lyd_new_ext_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_ext_path </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node defined in the given extension instance. In case of anyxml/anydata nodes, this function expects the <code>value</code> as string. </p>
<p>If creating data nodes defined in a module's standard tree, use <a class="el" href="#a164faee35d90e24371b237a0969cf73b" title="Create a new node in the data tree based on a path. If creating anyxml/anydata nodes,...">lyd_new_path()</a> or <a class="el" href="#a1f8d709533cfc82522da20a882dd086b" title="Create a new node in the data tree based on a path. All node types can be created.">lyd_new_path2()</a>.</p>
<p>Details are mentioned in <a class="el" href="#a164faee35d90e24371b237a0969cf73b" title="Create a new node in the data tree based on a path. If creating anyxml/anydata nodes,...">lyd_new_path()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Data parent to add to/modify, can be NULL. Note that in case a first top-level sibling is used, it may no longer be first if <code>path</code> is absolute and starts with a non-existing top-level node inserted before <code>parent</code>. Use <a class="el" href="#a2dd2f5806ae9628be1091a66245ef956" title="Get the first sibling of the given node.">lyd_first_sibling()</a> to adjust <code>parent</code> in these cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Extension instance where the node being created is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><a class="el" href="howto_x_path.html">Path</a> to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the new leaf/leaf-list. For other node types, it should be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options, see <a class="el" href="group__pathoptions.html">Data path creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional first created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_EEXIST if the final node to create exists (unless <a class="el" href="group__pathoptions.html#gaf815de8dda9ad51591d6e4ae79f0606e">LYD_NEW_PATH_UPDATE</a> is used). </dd>
<dd>
LY_EINVAL on invalid arguments including invalid <code>path</code>. </dd>
<dd>
LY_EVALID on invalid <code>value</code>. </dd>
<dd>
LY_ERR on other errors. </dd></dl>

</div>
</div>
<a id="ac0f464b732a909c9da359299ff67e9db" name="ac0f464b732a909c9da359299ff67e9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f464b732a909c9da359299ff67e9db">&#9670;&#160;</a></span>lyd_new_ext_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_ext_term </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__plugins_extensions.html#structlysc__ext__instance">lysc_ext_instance</a> *</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level term node defined in the given extension instance. </p>
<p>To create a term node with parent (no matter if defined inside extension instance or a standard tree) or a top-level node of a standard module's tree, use <a class="el" href="#aa0a289ea68ed2160af65314c245e689a" title="Create a new term node in the data tree.">lyd_new_term()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>Extension instance where the term node being created is defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a> or <a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>String form of the value of the node being created. In case of an instance-identifier or identityref value, the JSON format is expected (module names instead of prefixes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>The created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a33298dd1881db5a07003e8e85734865f" name="a33298dd1881db5a07003e8e85734865f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33298dd1881db5a07003e8e85734865f">&#9670;&#160;</a></span>lyd_new_implicit_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_implicit_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>implicit_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add any missing implicit nodes. Default nodes with a false "when" are not added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>Tree to add implicit nodes into. Note that in case a first top-level sibling is used, it may no longer be first if an implicit node was inserted before <code>tree</code>. Use <a class="el" href="#a2dd2f5806ae9628be1091a66245ef956" title="Get the first sibling of the given node.">lyd_first_sibling()</a> to adjust <code>tree</code> in these cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context, must be set only if <code>tree</code> is an empty tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">implicit_options</td><td>Options for implicit node creation, see <a class="el" href="group__implicitoptions.html">Implicit node creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Optional diff with any created nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a1f7ea402ee911b4e5e5ac9ee1a0d2f84" name="a1f7ea402ee911b4e5e5ac9ee1a0d2f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7ea402ee911b4e5e5ac9ee1a0d2f84">&#9670;&#160;</a></span>lyd_new_implicit_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_implicit_module </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>implicit_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add any missing implicit nodes of one module. Default nodes with a false "when" are not added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>Tree to add implicit nodes into. Note that in case a first top-level sibling is used, it may no longer be first if an implicit node was inserted before <code>tree</code>. Use <a class="el" href="#a2dd2f5806ae9628be1091a66245ef956" title="Get the first sibling of the given node.">lyd_first_sibling()</a> to adjust <code>tree</code> in these cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module whose implicit nodes to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">implicit_options</td><td>Options for implicit node creation, see <a class="el" href="group__implicitoptions.html">Implicit node creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Optional diff with any created nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a4277bb5a915017f19523fe30e9528f92" name="a4277bb5a915017f19523fe30e9528f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4277bb5a915017f19523fe30e9528f92">&#9670;&#160;</a></span>lyd_new_implicit_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_implicit_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>implicit_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>diff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add any missing implicit nodes into a data subtree. Default nodes with a false "when" are not added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Tree to add implicit nodes into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">implicit_options</td><td>Options for implicit node creation, see <a class="el" href="group__implicitoptions.html">Implicit node creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diff</td><td>Optional diff with any created nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ac681e05d82a50293c6cc9cbfad1050de" name="ac681e05d82a50293c6cc9cbfad1050de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac681e05d82a50293c6cc9cbfad1050de">&#9670;&#160;</a></span>lyd_new_inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_inner </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new inner node in the data tree. </p>
<p>To create list, use <a class="el" href="#a7e61eda8700065c3630e908bd8f82508" title="Create a new list node in the data tree.">lyd_new_list()</a> or <a class="el" href="#a4953b9d68eb4e533f93aeb11d634eeb7" title="Create a new list node in the data tree.">lyd_new_list2()</a>.</p>
<p>To create a top-level inner node defined in an extension instance, use <a class="el" href="#a744293d284c7a9b4b41f6290e1640af3" title="Create a new top-level inner node defined in the given extension instance.">lyd_new_ext_inner()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga8af68db17d734a8fd08fe765eef5937a">LYS_CONTAINER</a>, <a class="el" href="group__schemanodetypes.html#ga236b4e81a1488cc5943aa43c6faacd51">LYS_NOTIF</a>, <a class="el" href="group__schemanodetypes.html#ga4e0d212f3fe9cb3cfb27ce8709d82048">LYS_RPC</a>, or <a class="el" href="group__schemanodetypes.html#gac0aff1ca4e3a03895df2c2d0f9c22a1a">LYS_ACTION</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a7e61eda8700065c3630e908bd8f82508" name="a7e61eda8700065c3630e908bd8f82508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e61eda8700065c3630e908bd8f82508">&#9670;&#160;</a></span>lyd_new_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Ordered key values of the new list instance, all must be set. In case of an instance-identifier or identityref value, the JSON format is expected (module names instead of prefixes). No keys are expected for key-less lists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a4953b9d68eb4e533f93aeb11d634eeb7" name="a4953b9d68eb4e533f93aeb11d634eeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4953b9d68eb4e533f93aeb11d634eeb7">&#9670;&#160;</a></span>lyd_new_list2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>All key values predicate in the form of "[key1='val1'][key2='val2']...", they do not have to be ordered. In case of an instance-identifier or identityref value, the JSON format is expected (module names instead of prefixes). Use NULL or string of length 0 in case of key-less list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a2c3a3bc154721cac2df98013dde917e9" name="a2c3a3bc154721cac2df98013dde917e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3a3bc154721cac2df98013dde917e9">&#9670;&#160;</a></span>lyd_new_list3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>key_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>value_lengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of key values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_values</td><td>Ordered key string values of the new list instance, all must be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_lengths</td><td>Array of lengths of each <code>key_values</code>, may be NULL if <code>key_values</code> are 0-terminated strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a9e27fcb3b97c6e7788ebab12bcb6e4f4" name="a9e27fcb3b97c6e7788ebab12bcb6e4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e27fcb3b97c6e7788ebab12bcb6e4f4">&#9670;&#160;</a></span>lyd_new_list3_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list3_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **</td>          <td class="paramname"><span class="paramname"><em>key_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>value_lengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of key values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_values</td><td>Ordered key binary (LYB) values of the new list instance, all must be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_lengths</td><td>Array of lengths of each <code>key_values</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a5e3f2cf7c5bc2b624e7a9551155b6f9d" name="a5e3f2cf7c5bc2b624e7a9551155b6f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3f2cf7c5bc2b624e7a9551155b6f9d">&#9670;&#160;</a></span>lyd_new_list3_canon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list3_canon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>key_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>value_lengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format of key values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_values</td><td>Ordered key canonical values of the new list instance, all must be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_lengths</td><td>Array of lengths of each <code>key_values</code>, may be NULL if <code>key_values</code> are 0-terminated strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ab75cd7606ace6e51faf3f879c2fda986" name="ab75cd7606ace6e51faf3f879c2fda986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75cd7606ace6e51faf3f879c2fda986">&#9670;&#160;</a></span>lyd_new_list_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Ordered binary key values of the new list instance, all must be set. Every key value must be followed by its length. No keys are expected for key-less lists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a21e055470773fcbf90f6faa4633172d3" name="a21e055470773fcbf90f6faa4633172d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e055470773fcbf90f6faa4633172d3">&#9670;&#160;</a></span>lyd_new_list_canon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_list_canon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node must be <a class="el" href="group__schemanodetypes.html#gac404a566365d1b92c2a61a97e11077ea">LYS_LIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Ordered canonical key values of the new list instance, all must be set. No keys are expected for key-less lists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a2e88f2d851b561f0eb1c966ba181be55" name="a2e88f2d851b561f0eb1c966ba181be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e88f2d851b561f0eb1c966ba181be55">&#9670;&#160;</a></span>lyd_new_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_meta </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>clear_dflt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **</td>          <td class="paramname"><span class="paramname"><em>meta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node for the metadata being created. Must be set if <code>meta</code> is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the metadata being created. If NULL, <code>name</code> must include module name as the prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Annotation name of the new metadata. It can include the annotation module as the prefix. If the prefix is specified it is always used but if not specified, <code>module</code> must be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>String form of the value of the metadata. In case of an instance-identifier or identityref value, the JSON format is expected (module names instead of prefixes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_dflt</td><td>Whether to clear the default flag starting from <code>parent</code>, recursively all NP containers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meta</td><td>Optional created metadata. Must be set if <code>parent</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="adbc392eb64f2b67f0db656daa12047da" name="adbc392eb64f2b67f0db656daa12047da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc392eb64f2b67f0db656daa12047da">&#9670;&#160;</a></span>lyd_new_meta2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_meta2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>clear_dflt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__attr">lyd_attr</a> *</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="metadata_8h.html#structlyd__meta">lyd_meta</a> **</td>          <td class="paramname"><span class="paramname"><em>meta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new metadata from an opaque node attribute if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Optional parent node for the metadata being created. Must be set if <code>meta</code> is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_dflt</td><td>Whether to clear the default flag starting from <code>parent</code>, recursively all NP containers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Opaque node attribute to parse into metadata. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meta</td><td>Optional created metadata. Must be set if <code>parent</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ENOT if the attribute could not be parsed into any metadata. </dd>
<dd>
LY_ERR on error. </dd></dl>

</div>
</div>
<a id="a298fe45ddae4447e25ce179c5ed14e47" name="a298fe45ddae4447e25ce179c5ed14e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298fe45ddae4447e25ce179c5ed14e47">&#9670;&#160;</a></span>lyd_new_opaq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_opaq </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new JSON opaque node in the data tree. To create an XML opaque node, use <a class="el" href="#afefaab2ce7b396d269bd956ba193fb85" title="Create a new XML opaque node in the data tree. To create a JSON opaque node, use lyd_new_opaq().">lyd_new_opaq2()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. If NULL, <code>parent</code> context will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Node name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Optional node value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Optional node prefix, must be equal to <code>module_name</code> if set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_name</td><td>Node module name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="afefaab2ce7b396d269bd956ba193fb85" name="afefaab2ce7b396d269bd956ba193fb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefaab2ce7b396d269bd956ba193fb85">&#9670;&#160;</a></span>lyd_new_opaq2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_opaq2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>module_ns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new XML opaque node in the data tree. To create a JSON opaque node, use <a class="el" href="#a298fe45ddae4447e25ce179c5ed14e47" title="Create a new JSON opaque node in the data tree. To create an XML opaque node, use lyd_new_opaq2().">lyd_new_opaq()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context. If NULL, <code>parent</code> context will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Node name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Optional node value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>Optional node prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_ns</td><td>Node module namespace. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a164faee35d90e24371b237a0969cf73b" name="a164faee35d90e24371b237a0969cf73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164faee35d90e24371b237a0969cf73b">&#9670;&#160;</a></span>lyd_new_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_path </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node in the data tree based on a path. If creating anyxml/anydata nodes, <a class="el" href="#a1f8d709533cfc82522da20a882dd086b" title="Create a new node in the data tree based on a path. All node types can be created.">lyd_new_path2</a> should be used instead, this function expects the value as string. </p>
<p>If creating data nodes defined inside an extension instance, use <a class="el" href="#a9319dac303b26b9a29d7ba9f31890eb0" title="Create a new node defined in the given extension instance. In case of anyxml/anydata nodes,...">lyd_new_ext_path()</a>.</p>
<p>If <code>path</code> points to a list key, the key value from the predicate is used and <code>value</code> is ignored. Also, if a leaf-list is being created and both a predicate is defined in <code>path</code> and <code>value</code> is set, the predicate is preferred.</p>
<p>For key-less lists, positional predicates must be used (indices starting from 1). For non-configuration leaf-lists either positional predicate can be used or leaf-list predicate, when an instance is always created at the end. If no predicate is used for these nodes, they are always created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Data parent to add to/modify, can be NULL. Note that in case a first top-level sibling is used, it may no longer be first if <code>path</code> is absolute and starts with a non-existing top-level node inserted before <code>parent</code>. Use <a class="el" href="#a2dd2f5806ae9628be1091a66245ef956" title="Get the first sibling of the given node.">lyd_first_sibling()</a> to adjust <code>parent</code> in these cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context, must be set if <code>parent</code> is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><a class="el" href="howto_x_path.html">Path</a> to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>String value of the new leaf/leaf-list. If it varies based on the format, <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> is expected. For other node types, it should be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options, see <a class="el" href="group__pathoptions.html">Data path creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional first created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_EEXIST if the final node to create exists (unless <a class="el" href="group__pathoptions.html#gaf815de8dda9ad51591d6e4ae79f0606e">LYD_NEW_PATH_UPDATE</a> is used). </dd>
<dd>
LY_EINVAL on invalid arguments including invalid <code>path</code>. </dd>
<dd>
LY_EVALID on invalid <code>value</code>. </dd>
<dd>
LY_ERR on other errors. </dd></dl>

</div>
</div>
<a id="a1f8d709533cfc82522da20a882dd086b" name="a1f8d709533cfc82522da20a882dd086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8d709533cfc82522da20a882dd086b">&#9670;&#160;</a></span>lyd_new_path2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_path2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatree.html#ga67df54d1294afeb498b20c35e6f6fccc">LYD_ANYDATA_VALUETYPE</a></td>          <td class="paramname"><span class="paramname"><em>value_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>new_parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>new_node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node in the data tree based on a path. All node types can be created. </p>
<p>Details are mentioned in <a class="el" href="#a164faee35d90e24371b237a0969cf73b" title="Create a new node in the data tree based on a path. If creating anyxml/anydata nodes,...">lyd_new_path()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Data parent to add to/modify, can be NULL. Note that in case a first top-level sibling is used, it may no longer be first if <code>path</code> is absolute and starts with a non-existing top-level node inserted before <code>parent</code>. Use <a class="el" href="#a2dd2f5806ae9628be1091a66245ef956" title="Get the first sibling of the given node.">lyd_first_sibling()</a> to adjust <code>parent</code> in these cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context, must be set if <code>parent</code> is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><a class="el" href="howto_x_path.html">Path</a> to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the new leaf/leaf-list (const char *) in <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> format. If creating an anyxml/anydata node, the expected type depends on <code>value_type</code>. For other node types, it should be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of <code>value</code> in bytes. May be 0 if <code>value</code> is a zero-terminated string. Ignored when creating anyxml/anydata nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Anyxml/anydata node <code>value</code> type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Bitmask of options, see <a class="el" href="group__pathoptions.html">Data path creation options</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_parent</td><td>Optional first parent node created. If only one node was created, equals to <code>new_node</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_node</td><td>Optional last node created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_EEXIST if the final node to create exists (unless <a class="el" href="group__pathoptions.html#gaf815de8dda9ad51591d6e4ae79f0606e">LYD_NEW_PATH_UPDATE</a> is used). </dd>
<dd>
LY_EINVAL on invalid arguments including invalid <code>path</code>. </dd>
<dd>
LY_EVALID on invalid <code>value</code>. </dd>
<dd>
LY_ERR on other errors. </dd></dl>

</div>
</div>
<a id="aa0a289ea68ed2160af65314c245e689a" name="aa0a289ea68ed2160af65314c245e689a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a289ea68ed2160af65314c245e689a">&#9670;&#160;</a></span>lyd_new_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_term </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new term node in the data tree. </p>
<p>To create a top-level term node defined in an extension instance, use <a class="el" href="#ac0f464b732a909c9da359299ff67e9db" title="Create a new top-level term node defined in the given extension instance.">lyd_new_ext_term()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a> or <a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>String value of the node. If it varies based on the format, <a class="el" href="group__trees.html#gga6d2b8dbf3f39c2b16b9a9d7943dda953a0c99561fb3bf8154fc25370e2523b51d">LY_VALUE_JSON</a> is expected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="ac1fc666afb9745d840990759f8eab917" name="ac1fc666afb9745d840990759f8eab917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fc666afb9745d840990759f8eab917">&#9670;&#160;</a></span>lyd_new_term_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_term_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new term node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a> or <a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Binary value of the node. To learn what exactly is expected see <a class="el" href="howto_data_l_y_b.html">LYB Binary Format</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a4ba9aff9f205c2b1b987c7f8dee89b38" name="a4ba9aff9f205c2b1b987c7f8dee89b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba9aff9f205c2b1b987c7f8dee89b38">&#9670;&#160;</a></span>lyd_new_term_canon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_new_term_canon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log_8h.html#aeb4c206082008e3d976fb9d5fdc23a26">ly_bool</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new term node in the data tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent node for the node being created. NULL in case of creating a top level element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Module of the node being created. If NULL, <code>parent</code> module will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Schema node name of the new data node. The node can be <a class="el" href="group__schemanodetypes.html#ga5bd0665d8ed690b40a0dd8dbbbeb8f49">LYS_LEAF</a> or <a class="el" href="group__schemanodetypes.html#ga2746de063375b305eede6ec199e633c3">LYS_LEAFLIST</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_str</td><td>Canonical string value of the node. If it is not, it may lead to unexpected behavior. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Flag in case the <code>parent</code> is RPC/Action. If value is 0, the input's data nodes of the RPC/Action are taken into consideration. Otherwise, the output's data node is going to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Optional created node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
<a id="a3a6559a67f87c974fe977d95ccfb9875" name="a3a6559a67f87c974fe977d95ccfb9875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6559a67f87c974fe977d95ccfb9875">&#9670;&#160;</a></span>lyd_node_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * lyd_node_module </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module of a node. Useful mainly for opaque nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Module of the node. </dd></dl>

</div>
</div>
<a id="a5c06a492c6e8af966cc3fac24fdc35a8" name="a5c06a492c6e8af966cc3fac24fdc35a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c06a492c6e8af966cc3fac24fdc35a8">&#9670;&#160;</a></span>lyd_node_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> * lyd_node_schema </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get schema node of a data node. Useful especially for opaque nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data node to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schema node represented by data <code>node</code>, NULL if there is none. </dd></dl>

</div>
</div>
<a id="ab8741b9abcc8770f30eeba991b4e5f18" name="ab8741b9abcc8770f30eeba991b4e5f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8741b9abcc8770f30eeba991b4e5f18">&#9670;&#160;</a></span>lyd_owner_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="group__schematree.html#structlys__module">lys_module</a> * lyd_owner_module </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the owner module of the data node. It is the module of the top-level schema node. Generally, in case of augments it is the target module, recursively, otherwise it is the module where the data node is defined. </p>
<p>Also works for opaque nodes, if it is possible to resolve the module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data node to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Module owner of the node. </dd></dl>

</div>
</div>
<a id="ae1dda28aa5d60cf74f1527543535ca21" name="ae1dda28aa5d60cf74f1527543535ca21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dda28aa5d60cf74f1527543535ca21">&#9670;&#160;</a></span>lyd_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL struct <a class="el" href="#structlyd__node">lyd_node</a> * lyd_parent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the generic parent pointer of a data node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node whose parent pointer to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parent node of the <code>node</code>. </dd>
<dd>
NULL in case of the top-level node or if the <code>node</code> is NULL itself. </dd></dl>

</div>
</div>
<a id="abd6149bd9380ad24c6b5591f196eb73c" name="abd6149bd9380ad24c6b5591f196eb73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6149bd9380ad24c6b5591f196eb73c">&#9670;&#160;</a></span>lyd_parse_opaq_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_parse_opaq_error </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check node parsed into an opaque node for the reason (error) why it could not be parsed as data node. </p>
<p>The node is expected to be produced by a parser and must either have no parent or a data node parent (not opaque).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Opaque node to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_EINVAL if <code>node</code> is in some way unexpected (even valid); </dd>
<dd>
LY_ERR value of the reason. </dd></dl>

</div>
</div>
<a id="a1acafa02872b3c35cf8a8df2aba48935" name="a1acafa02872b3c35cf8a8df2aba48935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acafa02872b3c35cf8a8df2aba48935">&#9670;&#160;</a></span>lyd_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL char * lyd_path </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1b6ee9ba8cea5395a5913b9a21ec24b0">LYD_PATH_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>pathtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buflen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate path of the given node in the requested format. </p>
<p>The path is constructed based on the parent node(s) of this node. When run on a node which is disconnected from its parent(s), this function might yield unexpected results such as <code>/example:b</code> instead of the expected <code>/example:a/b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data path of this node will be generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathtype</td><td>Format of the path to generate. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Prepared buffer of the <code>buflen</code> length to store the generated path. If NULL, memory for the complete path is allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size of the provided <code>buffer</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL in case of memory allocation error, path of the node otherwise. In case the <code>buffer</code> is NULL, the returned string is dynamically allocated and caller is responsible to free it. </dd></dl>

</div>
</div>
<a id="a0fa0f950b696146e44da0d4f3259e749" name="a0fa0f950b696146e44da0d4f3259e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa0f950b696146e44da0d4f3259e749">&#9670;&#160;</a></span>lyd_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const struct <a class="el" href="#structlyd__node__term">lyd_node_term</a> * lyd_target </td>
          <td>(</td>
          <td class="paramtype">const struct ly_path *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated, use <a class="el" href="#a1b699a792ef534e0326e09c4ac457e90" title="Find the target node of a compiled path (lyd_value instance-identifier).">lyd_find_target()</a> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Compiled path structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Data tree to be searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Found target node, </dd>
<dd>
NULL if not found. </dd></dl>

</div>
</div>
<a id="a89c0738724db5205b7922291740910f6" name="a89c0738724db5205b7922291740910f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c0738724db5205b7922291740910f6">&#9670;&#160;</a></span>lyd_trim_xpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DEF <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_trim_xpath </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> **</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath on data and free all the nodes except the subtrees selected by the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>Data tree to evaluate on and trim. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpath</td><td><a class="el" href="howto_x_path.html">XPath</a> to select in JSON format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>Optional <a class="el" href="howto_structures.html#sizedarrays">sized array</a> of XPath variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success. </dd>
<dd>
LY_ERR value on error. </dd></dl>

</div>
</div>
<a id="a1496e90d6566e4f5c8ac42820b7da06f" name="a1496e90d6566e4f5c8ac42820b7da06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1496e90d6566e4f5c8ac42820b7da06f">&#9670;&#160;</a></span>lyd_unlink_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_unlink_siblings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink the specified node with all the following siblings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be unlinked (together with all the children and following siblings). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af324d1f04fa5eba220e14706c6a81c67" name="af324d1f04fa5eba220e14706c6a81c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324d1f04fa5eba220e14706c6a81c67">&#9670;&#160;</a></span>lyd_unlink_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyd_unlink_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink the specified data subtree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data tree node to be unlinked (together with all the children). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea976bf69714042da3271c56c9e0690" name="a8ea976bf69714042da3271c56c9e0690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea976bf69714042da3271c56c9e0690">&#9670;&#160;</a></span>lyd_value_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_value_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node__term">lyd_node_term</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the node's value with the given string value. The string value is first validated according to the (current) node's type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Data node to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>String value to be compared. It does not need to be in a canonical form - as part of the process, it is validated and canonized if possible. But it is expected to be in JSON format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of the given <code>value</code> (mandatory). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success, </dd>
<dd>
LY_ENOT if the values do not match, </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="a19d7f170bc5a223d8b9c9404bad35c4b" name="a19d7f170bc5a223d8b9c9404bad35c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7f170bc5a223d8b9c9404bad35c4b">&#9670;&#160;</a></span>lyd_value_get_canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL const char * lyd_value_get_canonical </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__value">lyd_value</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (canonical) value of a <a class="el" href="#structlyd__value" title="YANG data representation.">lyd_value</a>. </p>
<p>Whenever possible, <a class="el" href="#abae2eeb0a95272274c72702899e864ba" title="Get the (canonical) value of a data node.">lyd_get_value()</a> or lyd_get_meta_value() should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context for the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value structure to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonical value. </dd></dl>

</div>
</div>
<a id="ac05e5554a07ea3477126ad802619315f" name="ac05e5554a07ea3477126ad802619315f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e5554a07ea3477126ad802619315f">&#9670;&#160;</a></span>lyd_value_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyd_value_validate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__context.html#structly__ctx">ly_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__node">lysc_node</a> *</td>          <td class="paramname"><span class="paramname"><em>schema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="#structlyd__node">lyd_node</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__schematree.html#structlysc__type">lysc_type</a> **</td>          <td class="paramname"><span class="paramname"><em>realtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>canonical</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check type restrictions applicable to the particular leaf/leaf-list with the given string <code>value</code>. </p>
<p>The given node is not modified in any way - it is just checked if the <code>value</code> can be set to the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>libyang context for logging (function does not log errors when <code>ctx</code> is NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>Schema node of the <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>String value to be checked, it is expected to be in JSON format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_len</td><td>Length of the given <code>value</code> (mandatory). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_node</td><td>Optional data tree context node for the value (leafref target, instance-identifier). If not set and is required for the validation to complete, <a class="el" href="group__errors.html#ggabfc4235478f06567d878806b8c0c6992ae6e061fa1dc6f6c200de678e8dee7792">LY_EINCOMPLETE</a> is be returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">realtype</td><td>Optional real type of <code>value</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">canonical</td><td>Optional canonical value of <code>value</code> (in the dictionary). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_SUCCESS on success </dd>
<dd>
LY_EINCOMPLETE in case the <code>ctx_node</code> is not provided and it was needed to finish the validation (e.g. due to require-instance). </dd>
<dd>
LY_ERR value if an error occurred. </dd></dl>

</div>
</div>
<a id="a00c3dd55db8de52aeb441cd2d62dff37" name="a00c3dd55db8de52aeb441cd2d62dff37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3dd55db8de52aeb441cd2d62dff37">&#9670;&#160;</a></span>lyxp_vars_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL void lyxp_vars_free </td>
          <td>(</td>
          <td class="paramtype">struct lyxp_var *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the XPath variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td><a class="el" href="howto_structures.html#sizedarrays">Sized array</a> of XPath variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7823f5e06f3a2ab833a0206ea2ab5427" name="a7823f5e06f3a2ab833a0206ea2ab5427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7823f5e06f3a2ab833a0206ea2ab5427">&#9670;&#160;</a></span>lyxp_vars_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBYANG_API_DECL <a class="el" href="group__errors.html#gabfc4235478f06567d878806b8c0c6992">LY_ERR</a> lyxp_vars_set </td>
          <td>(</td>
          <td class="paramtype">struct lyxp_var **</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new XPath variable to <code>vars</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vars</td><td>Pointer to <a class="el" href="howto_structures.html#sizedarrays">sized array</a> of XPath variables. To create a new array, set the <code>vars</code> target pointer to NULL. Otherwise variable named <code>name</code> with a value <code>value</code> will be added to the <code>vars</code> or its value will be changed if the variable is already defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the added/edited variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LY_ERR value. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="tree__data_8h.html">tree_data.h</a></li>
    <li class="footer">Generated on Tue Jan 28 2025 10:44:39 for libyang by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
