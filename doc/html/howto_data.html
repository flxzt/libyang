<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libyang: Data Instances</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libyang<span id="projectnumber">&#160;2.1.148</span>
   </div>
   <div id="projectbrief">libyang is YANG data modelling language parser and toolkit written (and providing API) in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('howto_data.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Data Instances</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>All the nodes in data tree comes are based on <a class="el" href="tree__data_8h.html#structlyd__node" title="Generic structure for a data node.">lyd_node</a> structure. According to the content of the <a class="el" href="tree__data_8h.html#a6f471e7e4556c269ef15b018a045d371">lyd_node.schema</a> it can be cast to several other structures.</p>
<p>In case the <a class="el" href="tree__data_8h.html#a6f471e7e4556c269ef15b018a045d371">lyd_node.schema</a> pointer is NULL, the node is actually <b>opaq</b> and can be safely cast to <a class="el" href="tree__data_8h.html#structlyd__node__opaq" title="Data node structure for unparsed (opaque) nodes.">lyd_node_opaq</a>. The opaq node represent an unknown node which wasn't mapped to any <a class="el" href="howto_schema.html">(compiled) schema</a> node in the context. Such a node can appear in several places in the data tree.</p><ul>
<li>As a part of the tree structure, but only in the case the <a class="el" href="group__dataparseroptions.html#ga61f9946bb1caff5bdf9995d051520fa7">LYD_PARSE_OPAQ</a> option was used when input data were <a class="el" href="howto_data_parsers.html">parsed</a>, because unknown data instances are ignored by default. The same way, the opaq nodes can appear as a node's attributes.</li>
<li>As a representation of YANG anydata/anyxml content.</li>
<li>As envelopes of standard data tree instances (RPCs, actions or Notifications).</li>
</ul>
<p>In case the data node has its definition in a <a class="el" href="howto_schema.html">compiled schema tree</a>, the structure of the data node is actually one of the followings according to the schema node's nodetype (<a class="el" href="group__schematree.html#a1e2dff622554029eb83a0d14bf06fce1">lysc_node.nodetype</a>).</p><ul>
<li><a class="el" href="tree__data_8h.html#structlyd__node__inner" title="Data node structure for the inner data tree nodes - containers, lists, RPCs, actions and Notification...">lyd_node_inner</a> - represents data nodes corresponding to schema nodes matching <a class="el" href="tree__data_8h.html#abab43155f05102a20b819651b543a59e">LYD_NODE_INNER</a> nodetypes. They provide structure of the tree by having children nodes.</li>
<li><a class="el" href="tree__data_8h.html#structlyd__node__term" title="Data node structure for the terminal data tree nodes - leaves and leaf-lists.">lyd_node_term</a> - represents data nodes corresponding to schema nodes matching <a class="el" href="tree__data_8h.html#a8f41da26d9b46168dcf9ee0b8c04ff03">LYD_NODE_TERM</a> nodetypes. The terminal nodes provide values of the particular configuration/status information. The values are represented as <a class="el" href="tree__data_8h.html#structlyd__value" title="YANG data representation.">lyd_value</a> structure with string representation of the value (retrieved by <a class="el" href="tree__data_8h.html#abae2eeb0a95272274c72702899e864ba" title="Get the (canonical) value of a data node.">lyd_get_value()</a> and lyd_get_meta_value()) and the type specific data stored in the structure's union according to the real type of the value (<a class="el" href="tree__data_8h.html#a222333222e4d0f8b53e99c00e46cb3f4">lyd_value.realtype</a>). The string representation provides canonical representation of the value in case the type has the canonical representation specified. Otherwise, it is the original value or, in case the value can contain prefixes, the JSON format is used to make the value unambiguous.</li>
<li><a class="el" href="tree__data_8h.html#structlyd__node__any" title="Data node structure for the anydata data tree nodes - anydata or anyxml.">lyd_node_any</a> - represents data nodes corresponding to schema nodes matching <a class="el" href="tree__data_8h.html#ac5cb5d2c5eba0e721c356d521126395b">LYD_NODE_ANY</a> nodetypes.</li>
</ul>
<p>Despite all the aforementioned structures and their members are available as part of the libyang API and callers can use it to navigate through the data tree structure or to obtain various information, we recommend to use the following macros and functions.</p><ul>
<li><a class="el" href="tree__data_8h.html#afe1dca771b11b89fe1123f4a52fe1db1" title="Get the child pointer of a generic data node.">lyd_child()</a> (or <a class="el" href="tree__data_8h.html#a78978bdaafb3f364662b12e54ac29455" title="Get the child pointer of a generic data node but skip its keys in case it is LYS_LIST.">lyd_child_no_keys()</a>) and <a class="el" href="tree__data_8h.html#ae1dda28aa5d60cf74f1527543535ca21" title="Get the generic parent pointer of a data node.">lyd_parent()</a> to get the node's child/parent node.</li>
<li><a class="el" href="group__datatree.html#gabe537ecfc0d86f208f20e174218005d0" title="Macro to get context from a data tree node.">LYD_CTX</a> to get libyang context from a data node.</li>
<li><a class="el" href="tree__data_8h.html#abae2eeb0a95272274c72702899e864ba" title="Get the (canonical) value of a data node.">lyd_get_value()</a>/lyd_get_meta_value() to get canonical string value from a terminal node/metadata instance.</li>
<li><a class="el" href="group__datatree.html#ga9a918f950bd4de092fb4ef8d92fcdbfd" title="Macro to iterate via all elements in a data tree. This is the opening part to the LYD_TREE_DFS_END - ...">LYD_TREE_DFS_BEGIN</a> and <a class="el" href="group__datatree.html#ga903709cf7c9479ed051fada71d212cef" title="Macro to iterate via all elements in a tree. This is the closing part to the LYD_TREE_DFS_BEGIN - the...">LYD_TREE_DFS_END</a> to traverse the data tree (depth-first).</li>
<li><a class="el" href="group__trees.html#ga04b6899066799af43f59cd8fa79cac61" title="Macro to iterate via all sibling elements without affecting the list itself.">LY_LIST_FOR</a> and <a class="el" href="group__trees.html#ga59697a34bce74db2074119931d9c349b" title="Sized-array iterator (for-loop).">LY_ARRAY_FOR</a> as described on <a class="el" href="howto_structures.html">Data Structures</a> page.</li>
</ul>
<p>Instead of going through the data tree on your own, a specific data node can be also located using a wide set of <b>lyd_find_*</b>() functions.</p>
<p>More information about specific operations with data instances can be found on the following pages:</p><ul>
<li><a class="el" href="howto_data_parsers.html">Parsing Data</a></li>
<li><a class="el" href="howto_data_validation.html">Validating Data</a></li>
<li><a class="el" href="howto_data_w_d.html">Default Values</a></li>
<li><a class="el" href="howto_data_manipulation.html">Manipulating Data</a></li>
<li><a class="el" href="howto_data_printers.html">Printing Data</a></li>
<li><a class="el" href="howto_data_l_y_b.html">LYB Binary Format</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>API for this group of functions is described in the <a class="el" href="group__datatree.html">Data Instances module</a>.</dd></dl>
<h2><a class="anchor" id="autotoc_md17"></a>
Functions List (not assigned to above subsections)</h2>
<ul>
<li><a class="el" href="tree__data_8h.html#afe1dca771b11b89fe1123f4a52fe1db1" title="Get the child pointer of a generic data node.">lyd_child()</a></li>
<li><a class="el" href="tree__data_8h.html#a78978bdaafb3f364662b12e54ac29455" title="Get the child pointer of a generic data node but skip its keys in case it is LYS_LIST.">lyd_child_no_keys()</a></li>
<li><a class="el" href="tree__data_8h.html#ae1dda28aa5d60cf74f1527543535ca21" title="Get the generic parent pointer of a data node.">lyd_parent()</a></li>
<li><a class="el" href="tree__data_8h.html#ab8741b9abcc8770f30eeba991b4e5f18" title="Get the owner module of the data node. It is the module of the top-level schema node....">lyd_owner_module()</a></li>
<li><a class="el" href="tree__data_8h.html#abae2eeb0a95272274c72702899e864ba" title="Get the (canonical) value of a data node.">lyd_get_value()</a></li>
<li>lyd_get_meta_value()</li>
<li><a class="el" href="tree__data_8h.html#a0e7048eaa5c9477cf0373790fa6a0f7f" title="Search in the given data for instances of nodes matching the provided XPath.">lyd_find_xpath()</a></li>
<li><a class="el" href="tree__data_8h.html#a21136839d28e3be50f59c71acb47f9a5" title="Search in given data for a node uniquely identified by a path.">lyd_find_path()</a></li>
<li><a class="el" href="tree__data_8h.html#a1b699a792ef534e0326e09c4ac457e90" title="Find the target node of a compiled path (lyd_value instance-identifier).">lyd_find_target()</a></li>
<li><a class="el" href="tree__data_8h.html#a8f65c822293a6c813fae62c343f1ba54" title="Search in the given siblings for the first schema instance. Uses hashes - should be used whenever pos...">lyd_find_sibling_val()</a></li>
<li><a class="el" href="tree__data_8h.html#a42a45977540ff618d4c129e8a4fb36dd" title="Search in the given siblings (NOT recursively) for the first target instance with the same value....">lyd_find_sibling_first()</a></li>
<li><a class="el" href="tree__data_8h.html#a08f635fdef0eaea66d2977a1f3f01fbb" title="Search the given siblings for an opaque node with a specific name.">lyd_find_sibling_opaq_next()</a></li>
<li><a class="el" href="tree__data_8h.html#aa53edb144ccb0cb1934548d532d69cdc" title="Find a specific metadata.">lyd_find_meta()</a></li>
<li><a class="el" href="tree__data_8h.html#a1acafa02872b3c35cf8a8df2aba48935" title="Generate path of the given node in the requested format.">lyd_path()</a></li>
<li><a class="el" href="tree__data_8h.html#a0fa0f950b696146e44da0d4f3259e749" title="Deprecated, use lyd_find_target() instead.">lyd_target()</a></li>
<li><a class="el" href="tree__data_8h.html#a67d05cffbc8606fd03798ce4ede72eb1" title="Learn the length of LYB data.">lyd_lyb_data_length()</a></li>
</ul>
<h1><a class="anchor" id="howtoDataMetadata"></a>
Metadata Support</h1>
<p>YANG Metadata annotations are defined in <a href="https://tools.ietf.org/html/rfc7952">RFC 7952</a> as YANG extension (and libyang <a class="el" href="howto_plugins_extensions.html">implements them as internal extension plugin</a>). In practice, it allows to have XML attributes (there is also a special encoding for JSON) in YANG modeled data. libyang does not allow to have any XML attribute without the appropriate annotation definition describing the data as it is done e.g. for leafs. When an attribute without a matching annotation definition is found in the input data, it is:</p><ul>
<li>silently dropped (with warning) or</li>
<li>an error is reported in case the <a class="el" href="group__dataparseroptions.html#ga705cb95f87e924fde9b1ed3432c8d555">LYD_PARSE_STRICT</a> parser option is provided to the <a class="el" href="howto_data_parsers.html">parser function</a> or</li>
<li>stored into a generic <a class="el" href="tree__data_8h.html#structlyd__attr" title="Generic attribute structure.">lyd_attr</a> structure without a connection with any YANG module in case the <a class="el" href="group__dataparseroptions.html#ga61f9946bb1caff5bdf9995d051520fa7">LYD_PARSE_OPAQ</a> parser options is provided to the <a class="el" href="howto_data_parsers.html">parser function</a>.</li>
</ul>
<p>There are some XML attributes, described by <a href="https://tools.ietf.org/html/rfc7950">YANG</a> and <a href="https://tools.ietf.org/html/rfc6241">NETCONF</a> specifications, which are not defined as annotations, but libyang implements them this way. In case of attributes in the YANG namespace (<code>insert</code>, <code>value</code> and <code>key</code> attributes for the NETCONF edit-config operation), they are defined in special libyang's internal module <code>yang</code>, which is available in each context and the content of this schema can be printed via <a class="el" href="howto_schema_printers.html">schema printers</a>.</p>
<p>In case of the attributes described in <a href="https://tools.ietf.org/html/rfc6241">NETCONF specification</a>, the libyang's annotations structures are hidden and cannot be printed despite, internally, they are part of the <code>ietf-netconf</code>'s schema structure. Therefore, these attributes are available only when the <code>ietf-netconf</code> schema is loaded in the context. The definitions of these annotations are as follows: </p><pre class="fragment">md:annotation operation {
  type enumeration {
    enum merge;
    enum replace;
    enum create;
    enum delete;
    enum remove;
  }
}

md:annotation type {
  type enumeration {
    enum subtree;
    enum xpath {
      if-feature "nc:xpath";
    }
  }
}

md:annotation select {
  type string;
}
</pre><p>Note, that, following the specification,</p><ul>
<li>the <code>type</code> and <code>select</code> XML attributes are supposed to be unqualified (without namespace) and that</li>
<li>the <code>select</code>'s content is XPath and it is internally transformed by libyang into the format where the XML namespace prefixes are replaced by the YANG module names.</li>
</ul>
<h1><a class="anchor" id="howtoDataYangdata"></a>
yang-data Support</h1>
<p><a href="https://tools.ietf.org/html/rfc8040">RFC 8040</a> defines ietf-restconf module, which includes yang-data extension. Despite the definition in the RESTCONF YANG module, the yang-data concept is quite generic and used even in modules without a connection to RESTCONF protocol. The extension allows to define a separated YANG trees usable separately from any datastore.</p>
<p>libyang implements support for yang-data internally as an <a class="el" href="howto_plugins_extensions.html">extension plugin</a>. To ease the use of yang-data with libyang, there are several generic functions, which are usable for yang-data:</p>
<ul>
<li><a class="el" href="group__datatree.html#ga0be7a3c411cd00c9b98aaf935d6fd785" title="Parse (and validate) data from the input handler as an extension data tree following the schema tree ...">lyd_parse_ext_data()</a></li>
<li><a class="el" href="group__datatree.html#gaead44103903fa80d61dd63cbe849e86e" title="Parse extension data into an operation data tree following only the specification from the given exte...">lyd_parse_ext_op()</a></li>
<li><a class="el" href="group__schematree.html#gabb3c0c998ea712df180cab58529513ba" title="Get next schema (sibling) node element in the schema order of an extension that can be instantiated i...">lys_getnext_ext()</a></li>
<li><a class="el" href="tree__data_8h.html#a744293d284c7a9b4b41f6290e1640af3" title="Create a new top-level inner node defined in the given extension instance.">lyd_new_ext_inner()</a></li>
<li><a class="el" href="tree__data_8h.html#a787e2a95c8187488988055b7d947ef24" title="Create a new top-level list node defined in the given extension instance.">lyd_new_ext_list()</a></li>
<li><a class="el" href="tree__data_8h.html#ac0f464b732a909c9da359299ff67e9db" title="Create a new top-level term node defined in the given extension instance.">lyd_new_ext_term()</a></li>
<li><a class="el" href="tree__data_8h.html#a47fed36624b42c6123c935ab496f7165" title="Create a new top-level any node defined in the given extension instance.">lyd_new_ext_any()</a></li>
<li><a class="el" href="tree__data_8h.html#a9319dac303b26b9a29d7ba9f31890eb0" title="Create a new node defined in the given extension instance. In case of anyxml/anydata nodes,...">lyd_new_ext_path()</a></li>
</ul>
<h1><a class="anchor" id="howtoDataMountpoint"></a>
mount-point Support</h1>
<p><a href="https://tools.ietf.org/html/rfc8528">RFC 8528</a> defines mount-point extension in ietf-yang-schema-mount YANG module. This extension is supported out-of-the-box but to be able to parse data in a mount point, additional run-time data need to be provided by a callback:</p>
<ul>
<li><a class="el" href="group__context.html#ga14853fe1a338c94d9e81be9566438243" title="Set callback providing run-time extension instance data. The expected data depend on the extension....">ly_ctx_set_ext_data_clb()</a></li>
</ul>
<p>The mounted data can be parsed directly from data files or created manually using the standard functions. However, note that the mounted data use <b>their own context</b> created as needed. For <em>inline</em> data this means that any new request for a mount-point schema node results in a new context creation because it is impossible to determine whether any existing context can be used. Also, all these contexts created for the mounted data are <b>never</b> freed automatically except when the parent context is being freed. So, to avoid redundant context creation, it is always advised to use <em>shared-schema</em> for mount-points.</p>
<p>In case it is not possible and <em>inline</em> mount point must be defined, it is still possible to avoid creating additional contexts. When the top-level node right under a schema node with a mount-point is created, always use this node for creation of any descendants. So, when using <a class="el" href="tree__data_8h.html#a164faee35d90e24371b237a0969cf73b" title="Create a new node in the data tree based on a path. If creating anyxml/anydata nodes,...">lyd_new_path()</a>, use the node as <code>parent</code> and specify relative <code>path</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="howto.html">libyang API Overview</a></li>
    <li class="footer">Generated on Tue Jan 28 2025 10:44:39 for libyang by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
